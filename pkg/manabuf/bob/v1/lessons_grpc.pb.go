// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package bpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// LessonModifierServiceClient is the client API for LessonModifierService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LessonModifierServiceClient interface {
	PreparePublish(ctx context.Context, in *PreparePublishRequest, opts ...grpc.CallOption) (*PreparePublishResponse, error)
	Unpublish(ctx context.Context, in *UnpublishRequest, opts ...grpc.CallOption) (*UnpublishResponse, error)
	CreateLiveLesson(ctx context.Context, in *CreateLiveLessonRequest, opts ...grpc.CallOption) (*CreateLiveLessonResponse, error)
	UpdateLiveLesson(ctx context.Context, in *UpdateLiveLessonRequest, opts ...grpc.CallOption) (*UpdateLiveLessonResponse, error)
	DeleteLiveLesson(ctx context.Context, in *DeleteLiveLessonRequest, opts ...grpc.CallOption) (*DeleteLiveLessonResponse, error)
	ModifyLiveLessonState(ctx context.Context, in *ModifyLiveLessonStateRequest, opts ...grpc.CallOption) (*ModifyLiveLessonStateResponse, error)
}

type lessonModifierServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLessonModifierServiceClient(cc grpc.ClientConnInterface) LessonModifierServiceClient {
	return &lessonModifierServiceClient{cc}
}

func (c *lessonModifierServiceClient) PreparePublish(ctx context.Context, in *PreparePublishRequest, opts ...grpc.CallOption) (*PreparePublishResponse, error) {
	out := new(PreparePublishResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonModifierService/PreparePublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonModifierServiceClient) Unpublish(ctx context.Context, in *UnpublishRequest, opts ...grpc.CallOption) (*UnpublishResponse, error) {
	out := new(UnpublishResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonModifierService/Unpublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonModifierServiceClient) CreateLiveLesson(ctx context.Context, in *CreateLiveLessonRequest, opts ...grpc.CallOption) (*CreateLiveLessonResponse, error) {
	out := new(CreateLiveLessonResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonModifierService/CreateLiveLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonModifierServiceClient) UpdateLiveLesson(ctx context.Context, in *UpdateLiveLessonRequest, opts ...grpc.CallOption) (*UpdateLiveLessonResponse, error) {
	out := new(UpdateLiveLessonResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonModifierService/UpdateLiveLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonModifierServiceClient) DeleteLiveLesson(ctx context.Context, in *DeleteLiveLessonRequest, opts ...grpc.CallOption) (*DeleteLiveLessonResponse, error) {
	out := new(DeleteLiveLessonResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonModifierService/DeleteLiveLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonModifierServiceClient) ModifyLiveLessonState(ctx context.Context, in *ModifyLiveLessonStateRequest, opts ...grpc.CallOption) (*ModifyLiveLessonStateResponse, error) {
	out := new(ModifyLiveLessonStateResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonModifierService/ModifyLiveLessonState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LessonModifierServiceServer is the server API for LessonModifierService service.
// All implementations should embed UnimplementedLessonModifierServiceServer
// for forward compatibility
type LessonModifierServiceServer interface {
	PreparePublish(context.Context, *PreparePublishRequest) (*PreparePublishResponse, error)
	Unpublish(context.Context, *UnpublishRequest) (*UnpublishResponse, error)
	CreateLiveLesson(context.Context, *CreateLiveLessonRequest) (*CreateLiveLessonResponse, error)
	UpdateLiveLesson(context.Context, *UpdateLiveLessonRequest) (*UpdateLiveLessonResponse, error)
	DeleteLiveLesson(context.Context, *DeleteLiveLessonRequest) (*DeleteLiveLessonResponse, error)
	ModifyLiveLessonState(context.Context, *ModifyLiveLessonStateRequest) (*ModifyLiveLessonStateResponse, error)
}

// UnimplementedLessonModifierServiceServer should be embedded to have forward compatible implementations.
type UnimplementedLessonModifierServiceServer struct {
}

func (UnimplementedLessonModifierServiceServer) PreparePublish(context.Context, *PreparePublishRequest) (*PreparePublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreparePublish not implemented")
}
func (UnimplementedLessonModifierServiceServer) Unpublish(context.Context, *UnpublishRequest) (*UnpublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unpublish not implemented")
}
func (UnimplementedLessonModifierServiceServer) CreateLiveLesson(context.Context, *CreateLiveLessonRequest) (*CreateLiveLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLiveLesson not implemented")
}
func (UnimplementedLessonModifierServiceServer) UpdateLiveLesson(context.Context, *UpdateLiveLessonRequest) (*UpdateLiveLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLiveLesson not implemented")
}
func (UnimplementedLessonModifierServiceServer) DeleteLiveLesson(context.Context, *DeleteLiveLessonRequest) (*DeleteLiveLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLiveLesson not implemented")
}
func (UnimplementedLessonModifierServiceServer) ModifyLiveLessonState(context.Context, *ModifyLiveLessonStateRequest) (*ModifyLiveLessonStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyLiveLessonState not implemented")
}

// UnsafeLessonModifierServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LessonModifierServiceServer will
// result in compilation errors.
type UnsafeLessonModifierServiceServer interface {
	mustEmbedUnimplementedLessonModifierServiceServer()
}

func RegisterLessonModifierServiceServer(s grpc.ServiceRegistrar, srv LessonModifierServiceServer) {
	s.RegisterService(&_LessonModifierService_serviceDesc, srv)
}

func _LessonModifierService_PreparePublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreparePublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonModifierServiceServer).PreparePublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonModifierService/PreparePublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonModifierServiceServer).PreparePublish(ctx, req.(*PreparePublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonModifierService_Unpublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnpublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonModifierServiceServer).Unpublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonModifierService/Unpublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonModifierServiceServer).Unpublish(ctx, req.(*UnpublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonModifierService_CreateLiveLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLiveLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonModifierServiceServer).CreateLiveLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonModifierService/CreateLiveLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonModifierServiceServer).CreateLiveLesson(ctx, req.(*CreateLiveLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonModifierService_UpdateLiveLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLiveLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonModifierServiceServer).UpdateLiveLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonModifierService/UpdateLiveLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonModifierServiceServer).UpdateLiveLesson(ctx, req.(*UpdateLiveLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonModifierService_DeleteLiveLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLiveLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonModifierServiceServer).DeleteLiveLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonModifierService/DeleteLiveLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonModifierServiceServer).DeleteLiveLesson(ctx, req.(*DeleteLiveLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonModifierService_ModifyLiveLessonState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyLiveLessonStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonModifierServiceServer).ModifyLiveLessonState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonModifierService/ModifyLiveLessonState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonModifierServiceServer).ModifyLiveLessonState(ctx, req.(*ModifyLiveLessonStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LessonModifierService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bob.v1.LessonModifierService",
	HandlerType: (*LessonModifierServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PreparePublish",
			Handler:    _LessonModifierService_PreparePublish_Handler,
		},
		{
			MethodName: "Unpublish",
			Handler:    _LessonModifierService_Unpublish_Handler,
		},
		{
			MethodName: "CreateLiveLesson",
			Handler:    _LessonModifierService_CreateLiveLesson_Handler,
		},
		{
			MethodName: "UpdateLiveLesson",
			Handler:    _LessonModifierService_UpdateLiveLesson_Handler,
		},
		{
			MethodName: "DeleteLiveLesson",
			Handler:    _LessonModifierService_DeleteLiveLesson_Handler,
		},
		{
			MethodName: "ModifyLiveLessonState",
			Handler:    _LessonModifierService_ModifyLiveLessonState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bob/v1/lessons.proto",
}

// LessonReaderServiceClient is the client API for LessonReaderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LessonReaderServiceClient interface {
	GetStreamingLearners(ctx context.Context, in *GetStreamingLearnersRequest, opts ...grpc.CallOption) (*GetStreamingLearnersResponse, error)
	RetrieveLessons(ctx context.Context, in *RetrieveLessonsRequest, opts ...grpc.CallOption) (*RetrieveLessonsResponse, error)
	RetrieveLiveLessonByLocations(ctx context.Context, in *RetrieveLiveLessonByLocationsRequest, opts ...grpc.CallOption) (*RetrieveLiveLessonByLocationsResponse, error)
	GetLiveLessonState(ctx context.Context, in *LiveLessonStateRequest, opts ...grpc.CallOption) (*LiveLessonStateResponse, error)
}

type lessonReaderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLessonReaderServiceClient(cc grpc.ClientConnInterface) LessonReaderServiceClient {
	return &lessonReaderServiceClient{cc}
}

func (c *lessonReaderServiceClient) GetStreamingLearners(ctx context.Context, in *GetStreamingLearnersRequest, opts ...grpc.CallOption) (*GetStreamingLearnersResponse, error) {
	out := new(GetStreamingLearnersResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReaderService/GetStreamingLearners", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonReaderServiceClient) RetrieveLessons(ctx context.Context, in *RetrieveLessonsRequest, opts ...grpc.CallOption) (*RetrieveLessonsResponse, error) {
	out := new(RetrieveLessonsResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReaderService/RetrieveLessons", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonReaderServiceClient) RetrieveLiveLessonByLocations(ctx context.Context, in *RetrieveLiveLessonByLocationsRequest, opts ...grpc.CallOption) (*RetrieveLiveLessonByLocationsResponse, error) {
	out := new(RetrieveLiveLessonByLocationsResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReaderService/RetrieveLiveLessonByLocations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonReaderServiceClient) GetLiveLessonState(ctx context.Context, in *LiveLessonStateRequest, opts ...grpc.CallOption) (*LiveLessonStateResponse, error) {
	out := new(LiveLessonStateResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReaderService/GetLiveLessonState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LessonReaderServiceServer is the server API for LessonReaderService service.
// All implementations should embed UnimplementedLessonReaderServiceServer
// for forward compatibility
type LessonReaderServiceServer interface {
	GetStreamingLearners(context.Context, *GetStreamingLearnersRequest) (*GetStreamingLearnersResponse, error)
	RetrieveLessons(context.Context, *RetrieveLessonsRequest) (*RetrieveLessonsResponse, error)
	RetrieveLiveLessonByLocations(context.Context, *RetrieveLiveLessonByLocationsRequest) (*RetrieveLiveLessonByLocationsResponse, error)
	GetLiveLessonState(context.Context, *LiveLessonStateRequest) (*LiveLessonStateResponse, error)
}

// UnimplementedLessonReaderServiceServer should be embedded to have forward compatible implementations.
type UnimplementedLessonReaderServiceServer struct {
}

func (UnimplementedLessonReaderServiceServer) GetStreamingLearners(context.Context, *GetStreamingLearnersRequest) (*GetStreamingLearnersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStreamingLearners not implemented")
}
func (UnimplementedLessonReaderServiceServer) RetrieveLessons(context.Context, *RetrieveLessonsRequest) (*RetrieveLessonsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveLessons not implemented")
}
func (UnimplementedLessonReaderServiceServer) RetrieveLiveLessonByLocations(context.Context, *RetrieveLiveLessonByLocationsRequest) (*RetrieveLiveLessonByLocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveLiveLessonByLocations not implemented")
}
func (UnimplementedLessonReaderServiceServer) GetLiveLessonState(context.Context, *LiveLessonStateRequest) (*LiveLessonStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiveLessonState not implemented")
}

// UnsafeLessonReaderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LessonReaderServiceServer will
// result in compilation errors.
type UnsafeLessonReaderServiceServer interface {
	mustEmbedUnimplementedLessonReaderServiceServer()
}

func RegisterLessonReaderServiceServer(s grpc.ServiceRegistrar, srv LessonReaderServiceServer) {
	s.RegisterService(&_LessonReaderService_serviceDesc, srv)
}

func _LessonReaderService_GetStreamingLearners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreamingLearnersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReaderServiceServer).GetStreamingLearners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReaderService/GetStreamingLearners",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReaderServiceServer).GetStreamingLearners(ctx, req.(*GetStreamingLearnersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonReaderService_RetrieveLessons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrieveLessonsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReaderServiceServer).RetrieveLessons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReaderService/RetrieveLessons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReaderServiceServer).RetrieveLessons(ctx, req.(*RetrieveLessonsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonReaderService_RetrieveLiveLessonByLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrieveLiveLessonByLocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReaderServiceServer).RetrieveLiveLessonByLocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReaderService/RetrieveLiveLessonByLocations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReaderServiceServer).RetrieveLiveLessonByLocations(ctx, req.(*RetrieveLiveLessonByLocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonReaderService_GetLiveLessonState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiveLessonStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReaderServiceServer).GetLiveLessonState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReaderService/GetLiveLessonState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReaderServiceServer).GetLiveLessonState(ctx, req.(*LiveLessonStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LessonReaderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bob.v1.LessonReaderService",
	HandlerType: (*LessonReaderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStreamingLearners",
			Handler:    _LessonReaderService_GetStreamingLearners_Handler,
		},
		{
			MethodName: "RetrieveLessons",
			Handler:    _LessonReaderService_RetrieveLessons_Handler,
		},
		{
			MethodName: "RetrieveLiveLessonByLocations",
			Handler:    _LessonReaderService_RetrieveLiveLessonByLocations_Handler,
		},
		{
			MethodName: "GetLiveLessonState",
			Handler:    _LessonReaderService_GetLiveLessonState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bob/v1/lessons.proto",
}

// LessonReportReaderServiceClient is the client API for LessonReportReaderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LessonReportReaderServiceClient interface {
	RetrievePartnerDomain(ctx context.Context, in *GetPartnerDomainRequest, opts ...grpc.CallOption) (*GetPartnerDomainResponse, error)
}

type lessonReportReaderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLessonReportReaderServiceClient(cc grpc.ClientConnInterface) LessonReportReaderServiceClient {
	return &lessonReportReaderServiceClient{cc}
}

func (c *lessonReportReaderServiceClient) RetrievePartnerDomain(ctx context.Context, in *GetPartnerDomainRequest, opts ...grpc.CallOption) (*GetPartnerDomainResponse, error) {
	out := new(GetPartnerDomainResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReportReaderService/RetrievePartnerDomain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LessonReportReaderServiceServer is the server API for LessonReportReaderService service.
// All implementations should embed UnimplementedLessonReportReaderServiceServer
// for forward compatibility
type LessonReportReaderServiceServer interface {
	RetrievePartnerDomain(context.Context, *GetPartnerDomainRequest) (*GetPartnerDomainResponse, error)
}

// UnimplementedLessonReportReaderServiceServer should be embedded to have forward compatible implementations.
type UnimplementedLessonReportReaderServiceServer struct {
}

func (UnimplementedLessonReportReaderServiceServer) RetrievePartnerDomain(context.Context, *GetPartnerDomainRequest) (*GetPartnerDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrievePartnerDomain not implemented")
}

// UnsafeLessonReportReaderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LessonReportReaderServiceServer will
// result in compilation errors.
type UnsafeLessonReportReaderServiceServer interface {
	mustEmbedUnimplementedLessonReportReaderServiceServer()
}

func RegisterLessonReportReaderServiceServer(s grpc.ServiceRegistrar, srv LessonReportReaderServiceServer) {
	s.RegisterService(&_LessonReportReaderService_serviceDesc, srv)
}

func _LessonReportReaderService_RetrievePartnerDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPartnerDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReportReaderServiceServer).RetrievePartnerDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReportReaderService/RetrievePartnerDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReportReaderServiceServer).RetrievePartnerDomain(ctx, req.(*GetPartnerDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LessonReportReaderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bob.v1.LessonReportReaderService",
	HandlerType: (*LessonReportReaderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RetrievePartnerDomain",
			Handler:    _LessonReportReaderService_RetrievePartnerDomain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bob/v1/lessons.proto",
}

// LessonReportModifierServiceClient is the client API for LessonReportModifierService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LessonReportModifierServiceClient interface {
	CreateIndividualLessonReport(ctx context.Context, in *CreateIndividualLessonReportRequest, opts ...grpc.CallOption) (*CreateIndividualLessonReportResponse, error)
	SubmitLessonReport(ctx context.Context, in *WriteLessonReportRequest, opts ...grpc.CallOption) (*SubmitLessonReportResponse, error)
	SaveDraftLessonReport(ctx context.Context, in *WriteLessonReportRequest, opts ...grpc.CallOption) (*SaveDraftLessonReportResponse, error)
}

type lessonReportModifierServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLessonReportModifierServiceClient(cc grpc.ClientConnInterface) LessonReportModifierServiceClient {
	return &lessonReportModifierServiceClient{cc}
}

func (c *lessonReportModifierServiceClient) CreateIndividualLessonReport(ctx context.Context, in *CreateIndividualLessonReportRequest, opts ...grpc.CallOption) (*CreateIndividualLessonReportResponse, error) {
	out := new(CreateIndividualLessonReportResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReportModifierService/CreateIndividualLessonReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonReportModifierServiceClient) SubmitLessonReport(ctx context.Context, in *WriteLessonReportRequest, opts ...grpc.CallOption) (*SubmitLessonReportResponse, error) {
	out := new(SubmitLessonReportResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReportModifierService/SubmitLessonReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonReportModifierServiceClient) SaveDraftLessonReport(ctx context.Context, in *WriteLessonReportRequest, opts ...grpc.CallOption) (*SaveDraftLessonReportResponse, error) {
	out := new(SaveDraftLessonReportResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonReportModifierService/SaveDraftLessonReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LessonReportModifierServiceServer is the server API for LessonReportModifierService service.
// All implementations should embed UnimplementedLessonReportModifierServiceServer
// for forward compatibility
type LessonReportModifierServiceServer interface {
	CreateIndividualLessonReport(context.Context, *CreateIndividualLessonReportRequest) (*CreateIndividualLessonReportResponse, error)
	SubmitLessonReport(context.Context, *WriteLessonReportRequest) (*SubmitLessonReportResponse, error)
	SaveDraftLessonReport(context.Context, *WriteLessonReportRequest) (*SaveDraftLessonReportResponse, error)
}

// UnimplementedLessonReportModifierServiceServer should be embedded to have forward compatible implementations.
type UnimplementedLessonReportModifierServiceServer struct {
}

func (UnimplementedLessonReportModifierServiceServer) CreateIndividualLessonReport(context.Context, *CreateIndividualLessonReportRequest) (*CreateIndividualLessonReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIndividualLessonReport not implemented")
}
func (UnimplementedLessonReportModifierServiceServer) SubmitLessonReport(context.Context, *WriteLessonReportRequest) (*SubmitLessonReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitLessonReport not implemented")
}
func (UnimplementedLessonReportModifierServiceServer) SaveDraftLessonReport(context.Context, *WriteLessonReportRequest) (*SaveDraftLessonReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveDraftLessonReport not implemented")
}

// UnsafeLessonReportModifierServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LessonReportModifierServiceServer will
// result in compilation errors.
type UnsafeLessonReportModifierServiceServer interface {
	mustEmbedUnimplementedLessonReportModifierServiceServer()
}

func RegisterLessonReportModifierServiceServer(s grpc.ServiceRegistrar, srv LessonReportModifierServiceServer) {
	s.RegisterService(&_LessonReportModifierService_serviceDesc, srv)
}

func _LessonReportModifierService_CreateIndividualLessonReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndividualLessonReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReportModifierServiceServer).CreateIndividualLessonReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReportModifierService/CreateIndividualLessonReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReportModifierServiceServer).CreateIndividualLessonReport(ctx, req.(*CreateIndividualLessonReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonReportModifierService_SubmitLessonReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteLessonReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReportModifierServiceServer).SubmitLessonReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReportModifierService/SubmitLessonReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReportModifierServiceServer).SubmitLessonReport(ctx, req.(*WriteLessonReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonReportModifierService_SaveDraftLessonReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteLessonReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonReportModifierServiceServer).SaveDraftLessonReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonReportModifierService/SaveDraftLessonReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonReportModifierServiceServer).SaveDraftLessonReport(ctx, req.(*WriteLessonReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LessonReportModifierService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bob.v1.LessonReportModifierService",
	HandlerType: (*LessonReportModifierServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateIndividualLessonReport",
			Handler:    _LessonReportModifierService_CreateIndividualLessonReport_Handler,
		},
		{
			MethodName: "SubmitLessonReport",
			Handler:    _LessonReportModifierService_SubmitLessonReport_Handler,
		},
		{
			MethodName: "SaveDraftLessonReport",
			Handler:    _LessonReportModifierService_SaveDraftLessonReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bob/v1/lessons.proto",
}

// LessonManagementServiceClient is the client API for LessonManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LessonManagementServiceClient interface {
	CreateLesson(ctx context.Context, in *CreateLessonRequest, opts ...grpc.CallOption) (*CreateLessonResponse, error)
	RetrieveLessons(ctx context.Context, in *RetrieveLessonsRequestV2, opts ...grpc.CallOption) (*RetrieveLessonsResponseV2, error)
	UpdateLesson(ctx context.Context, in *UpdateLessonRequest, opts ...grpc.CallOption) (*UpdateLessonResponse, error)
	DeleteLesson(ctx context.Context, in *DeleteLessonRequest, opts ...grpc.CallOption) (*DeleteLessonResponse, error)
}

type lessonManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLessonManagementServiceClient(cc grpc.ClientConnInterface) LessonManagementServiceClient {
	return &lessonManagementServiceClient{cc}
}

func (c *lessonManagementServiceClient) CreateLesson(ctx context.Context, in *CreateLessonRequest, opts ...grpc.CallOption) (*CreateLessonResponse, error) {
	out := new(CreateLessonResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonManagementService/CreateLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonManagementServiceClient) RetrieveLessons(ctx context.Context, in *RetrieveLessonsRequestV2, opts ...grpc.CallOption) (*RetrieveLessonsResponseV2, error) {
	out := new(RetrieveLessonsResponseV2)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonManagementService/RetrieveLessons", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonManagementServiceClient) UpdateLesson(ctx context.Context, in *UpdateLessonRequest, opts ...grpc.CallOption) (*UpdateLessonResponse, error) {
	out := new(UpdateLessonResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonManagementService/UpdateLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonManagementServiceClient) DeleteLesson(ctx context.Context, in *DeleteLessonRequest, opts ...grpc.CallOption) (*DeleteLessonResponse, error) {
	out := new(DeleteLessonResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.LessonManagementService/DeleteLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LessonManagementServiceServer is the server API for LessonManagementService service.
// All implementations should embed UnimplementedLessonManagementServiceServer
// for forward compatibility
type LessonManagementServiceServer interface {
	CreateLesson(context.Context, *CreateLessonRequest) (*CreateLessonResponse, error)
	RetrieveLessons(context.Context, *RetrieveLessonsRequestV2) (*RetrieveLessonsResponseV2, error)
	UpdateLesson(context.Context, *UpdateLessonRequest) (*UpdateLessonResponse, error)
	DeleteLesson(context.Context, *DeleteLessonRequest) (*DeleteLessonResponse, error)
}

// UnimplementedLessonManagementServiceServer should be embedded to have forward compatible implementations.
type UnimplementedLessonManagementServiceServer struct {
}

func (UnimplementedLessonManagementServiceServer) CreateLesson(context.Context, *CreateLessonRequest) (*CreateLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLesson not implemented")
}
func (UnimplementedLessonManagementServiceServer) RetrieveLessons(context.Context, *RetrieveLessonsRequestV2) (*RetrieveLessonsResponseV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveLessons not implemented")
}
func (UnimplementedLessonManagementServiceServer) UpdateLesson(context.Context, *UpdateLessonRequest) (*UpdateLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLesson not implemented")
}
func (UnimplementedLessonManagementServiceServer) DeleteLesson(context.Context, *DeleteLessonRequest) (*DeleteLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLesson not implemented")
}

// UnsafeLessonManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LessonManagementServiceServer will
// result in compilation errors.
type UnsafeLessonManagementServiceServer interface {
	mustEmbedUnimplementedLessonManagementServiceServer()
}

func RegisterLessonManagementServiceServer(s grpc.ServiceRegistrar, srv LessonManagementServiceServer) {
	s.RegisterService(&_LessonManagementService_serviceDesc, srv)
}

func _LessonManagementService_CreateLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonManagementServiceServer).CreateLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonManagementService/CreateLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonManagementServiceServer).CreateLesson(ctx, req.(*CreateLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonManagementService_RetrieveLessons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrieveLessonsRequestV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonManagementServiceServer).RetrieveLessons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonManagementService/RetrieveLessons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonManagementServiceServer).RetrieveLessons(ctx, req.(*RetrieveLessonsRequestV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonManagementService_UpdateLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonManagementServiceServer).UpdateLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonManagementService/UpdateLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonManagementServiceServer).UpdateLesson(ctx, req.(*UpdateLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonManagementService_DeleteLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonManagementServiceServer).DeleteLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.LessonManagementService/DeleteLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonManagementServiceServer).DeleteLesson(ctx, req.(*DeleteLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LessonManagementService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bob.v1.LessonManagementService",
	HandlerType: (*LessonManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLesson",
			Handler:    _LessonManagementService_CreateLesson_Handler,
		},
		{
			MethodName: "RetrieveLessons",
			Handler:    _LessonManagementService_RetrieveLessons_Handler,
		},
		{
			MethodName: "UpdateLesson",
			Handler:    _LessonManagementService_UpdateLesson_Handler,
		},
		{
			MethodName: "DeleteLesson",
			Handler:    _LessonManagementService_DeleteLesson_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bob/v1/lessons.proto",
}

// StudentSubscriptionServiceClient is the client API for StudentSubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StudentSubscriptionServiceClient interface {
	RetrieveStudentSubscription(ctx context.Context, in *RetrieveStudentSubscriptionRequest, opts ...grpc.CallOption) (*RetrieveStudentSubscriptionResponse, error)
	GetStudentCourseSubscriptions(ctx context.Context, in *GetStudentCourseSubscriptionsRequest, opts ...grpc.CallOption) (*GetStudentCourseSubscriptionsResponse, error)
}

type studentSubscriptionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStudentSubscriptionServiceClient(cc grpc.ClientConnInterface) StudentSubscriptionServiceClient {
	return &studentSubscriptionServiceClient{cc}
}

func (c *studentSubscriptionServiceClient) RetrieveStudentSubscription(ctx context.Context, in *RetrieveStudentSubscriptionRequest, opts ...grpc.CallOption) (*RetrieveStudentSubscriptionResponse, error) {
	out := new(RetrieveStudentSubscriptionResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.StudentSubscriptionService/RetrieveStudentSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *studentSubscriptionServiceClient) GetStudentCourseSubscriptions(ctx context.Context, in *GetStudentCourseSubscriptionsRequest, opts ...grpc.CallOption) (*GetStudentCourseSubscriptionsResponse, error) {
	out := new(GetStudentCourseSubscriptionsResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.StudentSubscriptionService/GetStudentCourseSubscriptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StudentSubscriptionServiceServer is the server API for StudentSubscriptionService service.
// All implementations should embed UnimplementedStudentSubscriptionServiceServer
// for forward compatibility
type StudentSubscriptionServiceServer interface {
	RetrieveStudentSubscription(context.Context, *RetrieveStudentSubscriptionRequest) (*RetrieveStudentSubscriptionResponse, error)
	GetStudentCourseSubscriptions(context.Context, *GetStudentCourseSubscriptionsRequest) (*GetStudentCourseSubscriptionsResponse, error)
}

// UnimplementedStudentSubscriptionServiceServer should be embedded to have forward compatible implementations.
type UnimplementedStudentSubscriptionServiceServer struct {
}

func (UnimplementedStudentSubscriptionServiceServer) RetrieveStudentSubscription(context.Context, *RetrieveStudentSubscriptionRequest) (*RetrieveStudentSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveStudentSubscription not implemented")
}
func (UnimplementedStudentSubscriptionServiceServer) GetStudentCourseSubscriptions(context.Context, *GetStudentCourseSubscriptionsRequest) (*GetStudentCourseSubscriptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStudentCourseSubscriptions not implemented")
}

// UnsafeStudentSubscriptionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StudentSubscriptionServiceServer will
// result in compilation errors.
type UnsafeStudentSubscriptionServiceServer interface {
	mustEmbedUnimplementedStudentSubscriptionServiceServer()
}

func RegisterStudentSubscriptionServiceServer(s grpc.ServiceRegistrar, srv StudentSubscriptionServiceServer) {
	s.RegisterService(&_StudentSubscriptionService_serviceDesc, srv)
}

func _StudentSubscriptionService_RetrieveStudentSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrieveStudentSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StudentSubscriptionServiceServer).RetrieveStudentSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.StudentSubscriptionService/RetrieveStudentSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StudentSubscriptionServiceServer).RetrieveStudentSubscription(ctx, req.(*RetrieveStudentSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StudentSubscriptionService_GetStudentCourseSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStudentCourseSubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StudentSubscriptionServiceServer).GetStudentCourseSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.StudentSubscriptionService/GetStudentCourseSubscriptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StudentSubscriptionServiceServer).GetStudentCourseSubscriptions(ctx, req.(*GetStudentCourseSubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _StudentSubscriptionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bob.v1.StudentSubscriptionService",
	HandlerType: (*StudentSubscriptionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RetrieveStudentSubscription",
			Handler:    _StudentSubscriptionService_RetrieveStudentSubscription_Handler,
		},
		{
			MethodName: "GetStudentCourseSubscriptions",
			Handler:    _StudentSubscriptionService_GetStudentCourseSubscriptions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bob/v1/lessons.proto",
}

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	GetTeachers(ctx context.Context, in *GetTeachersRequest, opts ...grpc.CallOption) (*GetTeachersResponse, error)
	GetUserGroup(ctx context.Context, in *GetUserGroupRequest, opts ...grpc.CallOption) (*GetUserGroupResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetTeachers(ctx context.Context, in *GetTeachersRequest, opts ...grpc.CallOption) (*GetTeachersResponse, error) {
	out := new(GetTeachersResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.UserService/GetTeachers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserGroup(ctx context.Context, in *GetUserGroupRequest, opts ...grpc.CallOption) (*GetUserGroupResponse, error) {
	out := new(GetUserGroupResponse)
	err := c.cc.Invoke(ctx, "/bob.v1.UserService/GetUserGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations should embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	GetTeachers(context.Context, *GetTeachersRequest) (*GetTeachersResponse, error)
	GetUserGroup(context.Context, *GetUserGroupRequest) (*GetUserGroupResponse, error)
}

// UnimplementedUserServiceServer should be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) GetTeachers(context.Context, *GetTeachersRequest) (*GetTeachersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeachers not implemented")
}
func (UnimplementedUserServiceServer) GetUserGroup(context.Context, *GetUserGroupRequest) (*GetUserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserGroup not implemented")
}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_GetTeachers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeachersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetTeachers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.UserService/GetTeachers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetTeachers(ctx, req.(*GetTeachersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bob.v1.UserService/GetUserGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserGroup(ctx, req.(*GetUserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bob.v1.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTeachers",
			Handler:    _UserService_GetTeachers_Handler,
		},
		{
			MethodName: "GetUserGroup",
			Handler:    _UserService_GetUserGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bob/v1/lessons.proto",
}
