// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package vpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// VirtualClassroomReaderServiceClient is the client API for VirtualClassroomReaderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VirtualClassroomReaderServiceClient interface {
	RetrieveWhiteboardToken(ctx context.Context, in *RetrieveWhiteboardTokenRequest, opts ...grpc.CallOption) (*RetrieveWhiteboardTokenResponse, error)
	GetLiveLessonState(ctx context.Context, in *GetLiveLessonStateRequest, opts ...grpc.CallOption) (*GetLiveLessonStateResponse, error)
	GetUserInformation(ctx context.Context, in *GetUserInformationRequest, opts ...grpc.CallOption) (*GetUserInformationResponse, error)
}

type virtualClassroomReaderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVirtualClassroomReaderServiceClient(cc grpc.ClientConnInterface) VirtualClassroomReaderServiceClient {
	return &virtualClassroomReaderServiceClient{cc}
}

func (c *virtualClassroomReaderServiceClient) RetrieveWhiteboardToken(ctx context.Context, in *RetrieveWhiteboardTokenRequest, opts ...grpc.CallOption) (*RetrieveWhiteboardTokenResponse, error) {
	out := new(RetrieveWhiteboardTokenResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomReaderService/RetrieveWhiteboardToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomReaderServiceClient) GetLiveLessonState(ctx context.Context, in *GetLiveLessonStateRequest, opts ...grpc.CallOption) (*GetLiveLessonStateResponse, error) {
	out := new(GetLiveLessonStateResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomReaderService/GetLiveLessonState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomReaderServiceClient) GetUserInformation(ctx context.Context, in *GetUserInformationRequest, opts ...grpc.CallOption) (*GetUserInformationResponse, error) {
	out := new(GetUserInformationResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomReaderService/GetUserInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualClassroomReaderServiceServer is the server API for VirtualClassroomReaderService service.
// All implementations should embed UnimplementedVirtualClassroomReaderServiceServer
// for forward compatibility
type VirtualClassroomReaderServiceServer interface {
	RetrieveWhiteboardToken(context.Context, *RetrieveWhiteboardTokenRequest) (*RetrieveWhiteboardTokenResponse, error)
	GetLiveLessonState(context.Context, *GetLiveLessonStateRequest) (*GetLiveLessonStateResponse, error)
	GetUserInformation(context.Context, *GetUserInformationRequest) (*GetUserInformationResponse, error)
}

// UnimplementedVirtualClassroomReaderServiceServer should be embedded to have forward compatible implementations.
type UnimplementedVirtualClassroomReaderServiceServer struct {
}

func (UnimplementedVirtualClassroomReaderServiceServer) RetrieveWhiteboardToken(context.Context, *RetrieveWhiteboardTokenRequest) (*RetrieveWhiteboardTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveWhiteboardToken not implemented")
}
func (UnimplementedVirtualClassroomReaderServiceServer) GetLiveLessonState(context.Context, *GetLiveLessonStateRequest) (*GetLiveLessonStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiveLessonState not implemented")
}
func (UnimplementedVirtualClassroomReaderServiceServer) GetUserInformation(context.Context, *GetUserInformationRequest) (*GetUserInformationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInformation not implemented")
}

// UnsafeVirtualClassroomReaderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VirtualClassroomReaderServiceServer will
// result in compilation errors.
type UnsafeVirtualClassroomReaderServiceServer interface {
	mustEmbedUnimplementedVirtualClassroomReaderServiceServer()
}

func RegisterVirtualClassroomReaderServiceServer(s grpc.ServiceRegistrar, srv VirtualClassroomReaderServiceServer) {
	s.RegisterService(&_VirtualClassroomReaderService_serviceDesc, srv)
}

func _VirtualClassroomReaderService_RetrieveWhiteboardToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrieveWhiteboardTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomReaderServiceServer).RetrieveWhiteboardToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomReaderService/RetrieveWhiteboardToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomReaderServiceServer).RetrieveWhiteboardToken(ctx, req.(*RetrieveWhiteboardTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomReaderService_GetLiveLessonState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiveLessonStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomReaderServiceServer).GetLiveLessonState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomReaderService/GetLiveLessonState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomReaderServiceServer).GetLiveLessonState(ctx, req.(*GetLiveLessonStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomReaderService_GetUserInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomReaderServiceServer).GetUserInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomReaderService/GetUserInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomReaderServiceServer).GetUserInformation(ctx, req.(*GetUserInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualClassroomReaderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtualclassroom.v1.VirtualClassroomReaderService",
	HandlerType: (*VirtualClassroomReaderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RetrieveWhiteboardToken",
			Handler:    _VirtualClassroomReaderService_RetrieveWhiteboardToken_Handler,
		},
		{
			MethodName: "GetLiveLessonState",
			Handler:    _VirtualClassroomReaderService_GetLiveLessonState_Handler,
		},
		{
			MethodName: "GetUserInformation",
			Handler:    _VirtualClassroomReaderService_GetUserInformation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtualclassroom/v1/virtualclassroom.proto",
}

// VirtualClassroomModifierServiceClient is the client API for VirtualClassroomModifierService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VirtualClassroomModifierServiceClient interface {
	JoinLiveLesson(ctx context.Context, in *JoinLiveLessonRequest, opts ...grpc.CallOption) (*JoinLiveLessonResponse, error)
	LeaveLiveLesson(ctx context.Context, in *LeaveLiveLessonRequest, opts ...grpc.CallOption) (*LeaveLiveLessonResponse, error)
	EndLiveLesson(ctx context.Context, in *EndLiveLessonRequest, opts ...grpc.CallOption) (*EndLiveLessonResponse, error)
	ModifyVirtualClassroomState(ctx context.Context, in *ModifyVirtualClassroomStateRequest, opts ...grpc.CallOption) (*ModifyVirtualClassroomStateResponse, error)
	PreparePublish(ctx context.Context, in *PreparePublishRequest, opts ...grpc.CallOption) (*PreparePublishResponse, error)
	Unpublish(ctx context.Context, in *UnpublishRequest, opts ...grpc.CallOption) (*UnpublishResponse, error)
}

type virtualClassroomModifierServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVirtualClassroomModifierServiceClient(cc grpc.ClientConnInterface) VirtualClassroomModifierServiceClient {
	return &virtualClassroomModifierServiceClient{cc}
}

func (c *virtualClassroomModifierServiceClient) JoinLiveLesson(ctx context.Context, in *JoinLiveLessonRequest, opts ...grpc.CallOption) (*JoinLiveLessonResponse, error) {
	out := new(JoinLiveLessonResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomModifierService/JoinLiveLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomModifierServiceClient) LeaveLiveLesson(ctx context.Context, in *LeaveLiveLessonRequest, opts ...grpc.CallOption) (*LeaveLiveLessonResponse, error) {
	out := new(LeaveLiveLessonResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomModifierService/LeaveLiveLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomModifierServiceClient) EndLiveLesson(ctx context.Context, in *EndLiveLessonRequest, opts ...grpc.CallOption) (*EndLiveLessonResponse, error) {
	out := new(EndLiveLessonResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomModifierService/EndLiveLesson", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomModifierServiceClient) ModifyVirtualClassroomState(ctx context.Context, in *ModifyVirtualClassroomStateRequest, opts ...grpc.CallOption) (*ModifyVirtualClassroomStateResponse, error) {
	out := new(ModifyVirtualClassroomStateResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomModifierService/ModifyVirtualClassroomState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomModifierServiceClient) PreparePublish(ctx context.Context, in *PreparePublishRequest, opts ...grpc.CallOption) (*PreparePublishResponse, error) {
	out := new(PreparePublishResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomModifierService/PreparePublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomModifierServiceClient) Unpublish(ctx context.Context, in *UnpublishRequest, opts ...grpc.CallOption) (*UnpublishResponse, error) {
	out := new(UnpublishResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomModifierService/Unpublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualClassroomModifierServiceServer is the server API for VirtualClassroomModifierService service.
// All implementations should embed UnimplementedVirtualClassroomModifierServiceServer
// for forward compatibility
type VirtualClassroomModifierServiceServer interface {
	JoinLiveLesson(context.Context, *JoinLiveLessonRequest) (*JoinLiveLessonResponse, error)
	LeaveLiveLesson(context.Context, *LeaveLiveLessonRequest) (*LeaveLiveLessonResponse, error)
	EndLiveLesson(context.Context, *EndLiveLessonRequest) (*EndLiveLessonResponse, error)
	ModifyVirtualClassroomState(context.Context, *ModifyVirtualClassroomStateRequest) (*ModifyVirtualClassroomStateResponse, error)
	PreparePublish(context.Context, *PreparePublishRequest) (*PreparePublishResponse, error)
	Unpublish(context.Context, *UnpublishRequest) (*UnpublishResponse, error)
}

// UnimplementedVirtualClassroomModifierServiceServer should be embedded to have forward compatible implementations.
type UnimplementedVirtualClassroomModifierServiceServer struct {
}

func (UnimplementedVirtualClassroomModifierServiceServer) JoinLiveLesson(context.Context, *JoinLiveLessonRequest) (*JoinLiveLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinLiveLesson not implemented")
}
func (UnimplementedVirtualClassroomModifierServiceServer) LeaveLiveLesson(context.Context, *LeaveLiveLessonRequest) (*LeaveLiveLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveLiveLesson not implemented")
}
func (UnimplementedVirtualClassroomModifierServiceServer) EndLiveLesson(context.Context, *EndLiveLessonRequest) (*EndLiveLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndLiveLesson not implemented")
}
func (UnimplementedVirtualClassroomModifierServiceServer) ModifyVirtualClassroomState(context.Context, *ModifyVirtualClassroomStateRequest) (*ModifyVirtualClassroomStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyVirtualClassroomState not implemented")
}
func (UnimplementedVirtualClassroomModifierServiceServer) PreparePublish(context.Context, *PreparePublishRequest) (*PreparePublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreparePublish not implemented")
}
func (UnimplementedVirtualClassroomModifierServiceServer) Unpublish(context.Context, *UnpublishRequest) (*UnpublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unpublish not implemented")
}

// UnsafeVirtualClassroomModifierServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VirtualClassroomModifierServiceServer will
// result in compilation errors.
type UnsafeVirtualClassroomModifierServiceServer interface {
	mustEmbedUnimplementedVirtualClassroomModifierServiceServer()
}

func RegisterVirtualClassroomModifierServiceServer(s grpc.ServiceRegistrar, srv VirtualClassroomModifierServiceServer) {
	s.RegisterService(&_VirtualClassroomModifierService_serviceDesc, srv)
}

func _VirtualClassroomModifierService_JoinLiveLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinLiveLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomModifierServiceServer).JoinLiveLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomModifierService/JoinLiveLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomModifierServiceServer).JoinLiveLesson(ctx, req.(*JoinLiveLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomModifierService_LeaveLiveLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveLiveLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomModifierServiceServer).LeaveLiveLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomModifierService/LeaveLiveLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomModifierServiceServer).LeaveLiveLesson(ctx, req.(*LeaveLiveLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomModifierService_EndLiveLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndLiveLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomModifierServiceServer).EndLiveLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomModifierService/EndLiveLesson",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomModifierServiceServer).EndLiveLesson(ctx, req.(*EndLiveLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomModifierService_ModifyVirtualClassroomState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyVirtualClassroomStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomModifierServiceServer).ModifyVirtualClassroomState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomModifierService/ModifyVirtualClassroomState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomModifierServiceServer).ModifyVirtualClassroomState(ctx, req.(*ModifyVirtualClassroomStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomModifierService_PreparePublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreparePublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomModifierServiceServer).PreparePublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomModifierService/PreparePublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomModifierServiceServer).PreparePublish(ctx, req.(*PreparePublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomModifierService_Unpublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnpublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomModifierServiceServer).Unpublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomModifierService/Unpublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomModifierServiceServer).Unpublish(ctx, req.(*UnpublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualClassroomModifierService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtualclassroom.v1.VirtualClassroomModifierService",
	HandlerType: (*VirtualClassroomModifierServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinLiveLesson",
			Handler:    _VirtualClassroomModifierService_JoinLiveLesson_Handler,
		},
		{
			MethodName: "LeaveLiveLesson",
			Handler:    _VirtualClassroomModifierService_LeaveLiveLesson_Handler,
		},
		{
			MethodName: "EndLiveLesson",
			Handler:    _VirtualClassroomModifierService_EndLiveLesson_Handler,
		},
		{
			MethodName: "ModifyVirtualClassroomState",
			Handler:    _VirtualClassroomModifierService_ModifyVirtualClassroomState_Handler,
		},
		{
			MethodName: "PreparePublish",
			Handler:    _VirtualClassroomModifierService_PreparePublish_Handler,
		},
		{
			MethodName: "Unpublish",
			Handler:    _VirtualClassroomModifierService_Unpublish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtualclassroom/v1/virtualclassroom.proto",
}

// LessonRecordingServiceClient is the client API for LessonRecordingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LessonRecordingServiceClient interface {
	StartRecording(ctx context.Context, in *StartRecordingRequest, opts ...grpc.CallOption) (*StartRecordingResponse, error)
	StopRecording(ctx context.Context, in *StopRecordingRequest, opts ...grpc.CallOption) (*StopRecordingResponse, error)
	GetRecordingByLessonID(ctx context.Context, in *GetRecordingByLessonIDRequest, opts ...grpc.CallOption) (*GetRecordingByLessonIDResponse, error)
	GetRecordingDownloadLinkByID(ctx context.Context, in *GetRecordingDownloadLinkByIDRequest, opts ...grpc.CallOption) (*GetRecordingDownloadLinkByIDResponse, error)
}

type lessonRecordingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLessonRecordingServiceClient(cc grpc.ClientConnInterface) LessonRecordingServiceClient {
	return &lessonRecordingServiceClient{cc}
}

func (c *lessonRecordingServiceClient) StartRecording(ctx context.Context, in *StartRecordingRequest, opts ...grpc.CallOption) (*StartRecordingResponse, error) {
	out := new(StartRecordingResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.LessonRecordingService/StartRecording", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonRecordingServiceClient) StopRecording(ctx context.Context, in *StopRecordingRequest, opts ...grpc.CallOption) (*StopRecordingResponse, error) {
	out := new(StopRecordingResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.LessonRecordingService/StopRecording", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonRecordingServiceClient) GetRecordingByLessonID(ctx context.Context, in *GetRecordingByLessonIDRequest, opts ...grpc.CallOption) (*GetRecordingByLessonIDResponse, error) {
	out := new(GetRecordingByLessonIDResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.LessonRecordingService/GetRecordingByLessonID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonRecordingServiceClient) GetRecordingDownloadLinkByID(ctx context.Context, in *GetRecordingDownloadLinkByIDRequest, opts ...grpc.CallOption) (*GetRecordingDownloadLinkByIDResponse, error) {
	out := new(GetRecordingDownloadLinkByIDResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.LessonRecordingService/GetRecordingDownloadLinkByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LessonRecordingServiceServer is the server API for LessonRecordingService service.
// All implementations should embed UnimplementedLessonRecordingServiceServer
// for forward compatibility
type LessonRecordingServiceServer interface {
	StartRecording(context.Context, *StartRecordingRequest) (*StartRecordingResponse, error)
	StopRecording(context.Context, *StopRecordingRequest) (*StopRecordingResponse, error)
	GetRecordingByLessonID(context.Context, *GetRecordingByLessonIDRequest) (*GetRecordingByLessonIDResponse, error)
	GetRecordingDownloadLinkByID(context.Context, *GetRecordingDownloadLinkByIDRequest) (*GetRecordingDownloadLinkByIDResponse, error)
}

// UnimplementedLessonRecordingServiceServer should be embedded to have forward compatible implementations.
type UnimplementedLessonRecordingServiceServer struct {
}

func (UnimplementedLessonRecordingServiceServer) StartRecording(context.Context, *StartRecordingRequest) (*StartRecordingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRecording not implemented")
}
func (UnimplementedLessonRecordingServiceServer) StopRecording(context.Context, *StopRecordingRequest) (*StopRecordingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopRecording not implemented")
}
func (UnimplementedLessonRecordingServiceServer) GetRecordingByLessonID(context.Context, *GetRecordingByLessonIDRequest) (*GetRecordingByLessonIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRecordingByLessonID not implemented")
}
func (UnimplementedLessonRecordingServiceServer) GetRecordingDownloadLinkByID(context.Context, *GetRecordingDownloadLinkByIDRequest) (*GetRecordingDownloadLinkByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRecordingDownloadLinkByID not implemented")
}

// UnsafeLessonRecordingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LessonRecordingServiceServer will
// result in compilation errors.
type UnsafeLessonRecordingServiceServer interface {
	mustEmbedUnimplementedLessonRecordingServiceServer()
}

func RegisterLessonRecordingServiceServer(s grpc.ServiceRegistrar, srv LessonRecordingServiceServer) {
	s.RegisterService(&_LessonRecordingService_serviceDesc, srv)
}

func _LessonRecordingService_StartRecording_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRecordingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonRecordingServiceServer).StartRecording(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.LessonRecordingService/StartRecording",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonRecordingServiceServer).StartRecording(ctx, req.(*StartRecordingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonRecordingService_StopRecording_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRecordingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonRecordingServiceServer).StopRecording(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.LessonRecordingService/StopRecording",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonRecordingServiceServer).StopRecording(ctx, req.(*StopRecordingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonRecordingService_GetRecordingByLessonID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecordingByLessonIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonRecordingServiceServer).GetRecordingByLessonID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.LessonRecordingService/GetRecordingByLessonID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonRecordingServiceServer).GetRecordingByLessonID(ctx, req.(*GetRecordingByLessonIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonRecordingService_GetRecordingDownloadLinkByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecordingDownloadLinkByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonRecordingServiceServer).GetRecordingDownloadLinkByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.LessonRecordingService/GetRecordingDownloadLinkByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonRecordingServiceServer).GetRecordingDownloadLinkByID(ctx, req.(*GetRecordingDownloadLinkByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LessonRecordingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtualclassroom.v1.LessonRecordingService",
	HandlerType: (*LessonRecordingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartRecording",
			Handler:    _LessonRecordingService_StartRecording_Handler,
		},
		{
			MethodName: "StopRecording",
			Handler:    _LessonRecordingService_StopRecording_Handler,
		},
		{
			MethodName: "GetRecordingByLessonID",
			Handler:    _LessonRecordingService_GetRecordingByLessonID_Handler,
		},
		{
			MethodName: "GetRecordingDownloadLinkByID",
			Handler:    _LessonRecordingService_GetRecordingDownloadLinkByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtualclassroom/v1/virtualclassroom.proto",
}

// VirtualClassroomChatServiceClient is the client API for VirtualClassroomChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VirtualClassroomChatServiceClient interface {
	GetConversationID(ctx context.Context, in *GetConversationIDRequest, opts ...grpc.CallOption) (*GetConversationIDResponse, error)
	GetPrivateConversationIDs(ctx context.Context, in *GetPrivateConversationIDsRequest, opts ...grpc.CallOption) (*GetPrivateConversationIDsResponse, error)
}

type virtualClassroomChatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVirtualClassroomChatServiceClient(cc grpc.ClientConnInterface) VirtualClassroomChatServiceClient {
	return &virtualClassroomChatServiceClient{cc}
}

func (c *virtualClassroomChatServiceClient) GetConversationID(ctx context.Context, in *GetConversationIDRequest, opts ...grpc.CallOption) (*GetConversationIDResponse, error) {
	out := new(GetConversationIDResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomChatService/GetConversationID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualClassroomChatServiceClient) GetPrivateConversationIDs(ctx context.Context, in *GetPrivateConversationIDsRequest, opts ...grpc.CallOption) (*GetPrivateConversationIDsResponse, error) {
	out := new(GetPrivateConversationIDsResponse)
	err := c.cc.Invoke(ctx, "/virtualclassroom.v1.VirtualClassroomChatService/GetPrivateConversationIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualClassroomChatServiceServer is the server API for VirtualClassroomChatService service.
// All implementations should embed UnimplementedVirtualClassroomChatServiceServer
// for forward compatibility
type VirtualClassroomChatServiceServer interface {
	GetConversationID(context.Context, *GetConversationIDRequest) (*GetConversationIDResponse, error)
	GetPrivateConversationIDs(context.Context, *GetPrivateConversationIDsRequest) (*GetPrivateConversationIDsResponse, error)
}

// UnimplementedVirtualClassroomChatServiceServer should be embedded to have forward compatible implementations.
type UnimplementedVirtualClassroomChatServiceServer struct {
}

func (UnimplementedVirtualClassroomChatServiceServer) GetConversationID(context.Context, *GetConversationIDRequest) (*GetConversationIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConversationID not implemented")
}
func (UnimplementedVirtualClassroomChatServiceServer) GetPrivateConversationIDs(context.Context, *GetPrivateConversationIDsRequest) (*GetPrivateConversationIDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrivateConversationIDs not implemented")
}

// UnsafeVirtualClassroomChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VirtualClassroomChatServiceServer will
// result in compilation errors.
type UnsafeVirtualClassroomChatServiceServer interface {
	mustEmbedUnimplementedVirtualClassroomChatServiceServer()
}

func RegisterVirtualClassroomChatServiceServer(s grpc.ServiceRegistrar, srv VirtualClassroomChatServiceServer) {
	s.RegisterService(&_VirtualClassroomChatService_serviceDesc, srv)
}

func _VirtualClassroomChatService_GetConversationID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomChatServiceServer).GetConversationID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomChatService/GetConversationID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomChatServiceServer).GetConversationID(ctx, req.(*GetConversationIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualClassroomChatService_GetPrivateConversationIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivateConversationIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualClassroomChatServiceServer).GetPrivateConversationIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtualclassroom.v1.VirtualClassroomChatService/GetPrivateConversationIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualClassroomChatServiceServer).GetPrivateConversationIDs(ctx, req.(*GetPrivateConversationIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualClassroomChatService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtualclassroom.v1.VirtualClassroomChatService",
	HandlerType: (*VirtualClassroomChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConversationID",
			Handler:    _VirtualClassroomChatService_GetConversationID_Handler,
		},
		{
			MethodName: "GetPrivateConversationIDs",
			Handler:    _VirtualClassroomChatService_GetPrivateConversationIDs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtualclassroom/v1/virtualclassroom.proto",
}
