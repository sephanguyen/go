// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: syllabus/v1/exam_lo_service.proto

package sspb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	cpb "github.com/manabie-com/backend/pkg/manabuf/common/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = cpb.AchievementCrown(0)
)

// Validate checks the field values on ExamLOBase with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExamLOBase) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExamLOBase with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExamLOBaseMultiError, or
// nil if none found.
func (m *ExamLOBase) ValidateAll() error {
	return m.validate(true)
}

func (m *ExamLOBase) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "Base",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "Base",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOBaseValidationError{
				field:  "Base",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Instruction

	if all {
		switch v := interface{}(m.GetGradeToPass()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "GradeToPass",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "GradeToPass",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGradeToPass()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOBaseValidationError{
				field:  "GradeToPass",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ManualGrading

	if all {
		switch v := interface{}(m.GetTimeLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "TimeLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "TimeLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOBaseValidationError{
				field:  "TimeLimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TotalQuestion

	// no validation rules for ApproveGrading

	// no validation rules for GradeCapping

	if all {
		switch v := interface{}(m.GetMaximumAttempt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "MaximumAttempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOBaseValidationError{
					field:  "MaximumAttempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaximumAttempt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOBaseValidationError{
				field:  "MaximumAttempt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReviewOption

	if len(errors) > 0 {
		return ExamLOBaseMultiError(errors)
	}

	return nil
}

// ExamLOBaseMultiError is an error wrapping multiple validation errors
// returned by ExamLOBase.ValidateAll() if the designated constraints aren't met.
type ExamLOBaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExamLOBaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExamLOBaseMultiError) AllErrors() []error { return m }

// ExamLOBaseValidationError is the validation error returned by
// ExamLOBase.Validate if the designated constraints aren't met.
type ExamLOBaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExamLOBaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExamLOBaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExamLOBaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExamLOBaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExamLOBaseValidationError) ErrorName() string { return "ExamLOBaseValidationError" }

// Error satisfies the builtin error interface
func (e ExamLOBaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExamLOBase.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExamLOBaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExamLOBaseValidationError{}

// Validate checks the field values on InsertExamLORequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InsertExamLORequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InsertExamLORequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InsertExamLORequestMultiError, or nil if none found.
func (m *InsertExamLORequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InsertExamLORequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExamLo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InsertExamLORequestValidationError{
					field:  "ExamLo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InsertExamLORequestValidationError{
					field:  "ExamLo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamLo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InsertExamLORequestValidationError{
				field:  "ExamLo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InsertExamLORequestMultiError(errors)
	}

	return nil
}

// InsertExamLORequestMultiError is an error wrapping multiple validation
// errors returned by InsertExamLORequest.ValidateAll() if the designated
// constraints aren't met.
type InsertExamLORequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InsertExamLORequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InsertExamLORequestMultiError) AllErrors() []error { return m }

// InsertExamLORequestValidationError is the validation error returned by
// InsertExamLORequest.Validate if the designated constraints aren't met.
type InsertExamLORequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InsertExamLORequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InsertExamLORequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InsertExamLORequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InsertExamLORequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InsertExamLORequestValidationError) ErrorName() string {
	return "InsertExamLORequestValidationError"
}

// Error satisfies the builtin error interface
func (e InsertExamLORequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInsertExamLORequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InsertExamLORequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InsertExamLORequestValidationError{}

// Validate checks the field values on UpsertGradeBookSettingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpsertGradeBookSettingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpsertGradeBookSettingRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpsertGradeBookSettingRequestMultiError, or nil if none found.
func (m *UpsertGradeBookSettingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpsertGradeBookSettingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Setting

	if len(errors) > 0 {
		return UpsertGradeBookSettingRequestMultiError(errors)
	}

	return nil
}

// UpsertGradeBookSettingRequestMultiError is an error wrapping multiple
// validation errors returned by UpsertGradeBookSettingRequest.ValidateAll()
// if the designated constraints aren't met.
type UpsertGradeBookSettingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpsertGradeBookSettingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpsertGradeBookSettingRequestMultiError) AllErrors() []error { return m }

// UpsertGradeBookSettingRequestValidationError is the validation error
// returned by UpsertGradeBookSettingRequest.Validate if the designated
// constraints aren't met.
type UpsertGradeBookSettingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpsertGradeBookSettingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpsertGradeBookSettingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpsertGradeBookSettingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpsertGradeBookSettingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpsertGradeBookSettingRequestValidationError) ErrorName() string {
	return "UpsertGradeBookSettingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpsertGradeBookSettingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpsertGradeBookSettingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpsertGradeBookSettingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpsertGradeBookSettingRequestValidationError{}

// Validate checks the field values on UpsertGradeBookSettingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpsertGradeBookSettingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpsertGradeBookSettingResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpsertGradeBookSettingResponseMultiError, or nil if none found.
func (m *UpsertGradeBookSettingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpsertGradeBookSettingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpsertGradeBookSettingResponseMultiError(errors)
	}

	return nil
}

// UpsertGradeBookSettingResponseMultiError is an error wrapping multiple
// validation errors returned by UpsertGradeBookSettingResponse.ValidateAll()
// if the designated constraints aren't met.
type UpsertGradeBookSettingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpsertGradeBookSettingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpsertGradeBookSettingResponseMultiError) AllErrors() []error { return m }

// UpsertGradeBookSettingResponseValidationError is the validation error
// returned by UpsertGradeBookSettingResponse.Validate if the designated
// constraints aren't met.
type UpsertGradeBookSettingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpsertGradeBookSettingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpsertGradeBookSettingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpsertGradeBookSettingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpsertGradeBookSettingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpsertGradeBookSettingResponseValidationError) ErrorName() string {
	return "UpsertGradeBookSettingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpsertGradeBookSettingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpsertGradeBookSettingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpsertGradeBookSettingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpsertGradeBookSettingResponseValidationError{}

// Validate checks the field values on InsertExamLOResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InsertExamLOResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InsertExamLOResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InsertExamLOResponseMultiError, or nil if none found.
func (m *InsertExamLOResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InsertExamLOResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LearningMaterialId

	if len(errors) > 0 {
		return InsertExamLOResponseMultiError(errors)
	}

	return nil
}

// InsertExamLOResponseMultiError is an error wrapping multiple validation
// errors returned by InsertExamLOResponse.ValidateAll() if the designated
// constraints aren't met.
type InsertExamLOResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InsertExamLOResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InsertExamLOResponseMultiError) AllErrors() []error { return m }

// InsertExamLOResponseValidationError is the validation error returned by
// InsertExamLOResponse.Validate if the designated constraints aren't met.
type InsertExamLOResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InsertExamLOResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InsertExamLOResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InsertExamLOResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InsertExamLOResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InsertExamLOResponseValidationError) ErrorName() string {
	return "InsertExamLOResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InsertExamLOResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInsertExamLOResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InsertExamLOResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InsertExamLOResponseValidationError{}

// Validate checks the field values on UpdateExamLORequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateExamLORequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateExamLORequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateExamLORequestMultiError, or nil if none found.
func (m *UpdateExamLORequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateExamLORequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExamLo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateExamLORequestValidationError{
					field:  "ExamLo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateExamLORequestValidationError{
					field:  "ExamLo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamLo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateExamLORequestValidationError{
				field:  "ExamLo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateExamLORequestMultiError(errors)
	}

	return nil
}

// UpdateExamLORequestMultiError is an error wrapping multiple validation
// errors returned by UpdateExamLORequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateExamLORequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateExamLORequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateExamLORequestMultiError) AllErrors() []error { return m }

// UpdateExamLORequestValidationError is the validation error returned by
// UpdateExamLORequest.Validate if the designated constraints aren't met.
type UpdateExamLORequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateExamLORequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateExamLORequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateExamLORequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateExamLORequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateExamLORequestValidationError) ErrorName() string {
	return "UpdateExamLORequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateExamLORequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateExamLORequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateExamLORequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateExamLORequestValidationError{}

// Validate checks the field values on UpdateExamLOResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateExamLOResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateExamLOResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateExamLOResponseMultiError, or nil if none found.
func (m *UpdateExamLOResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateExamLOResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateExamLOResponseMultiError(errors)
	}

	return nil
}

// UpdateExamLOResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateExamLOResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateExamLOResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateExamLOResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateExamLOResponseMultiError) AllErrors() []error { return m }

// UpdateExamLOResponseValidationError is the validation error returned by
// UpdateExamLOResponse.Validate if the designated constraints aren't met.
type UpdateExamLOResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateExamLOResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateExamLOResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateExamLOResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateExamLOResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateExamLOResponseValidationError) ErrorName() string {
	return "UpdateExamLOResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateExamLOResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateExamLOResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateExamLOResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateExamLOResponseValidationError{}

// Validate checks the field values on ListExamLORequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListExamLORequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLORequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamLORequestMultiError, or nil if none found.
func (m *ListExamLORequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLORequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListExamLORequestMultiError(errors)
	}

	return nil
}

// ListExamLORequestMultiError is an error wrapping multiple validation errors
// returned by ListExamLORequest.ValidateAll() if the designated constraints
// aren't met.
type ListExamLORequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLORequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLORequestMultiError) AllErrors() []error { return m }

// ListExamLORequestValidationError is the validation error returned by
// ListExamLORequest.Validate if the designated constraints aren't met.
type ListExamLORequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLORequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLORequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLORequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLORequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLORequestValidationError) ErrorName() string {
	return "ListExamLORequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLORequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLORequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLORequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLORequestValidationError{}

// Validate checks the field values on ListExamLOResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListExamLOResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLOResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamLOResponseMultiError, or nil if none found.
func (m *ListExamLOResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExamLos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamLOResponseValidationError{
						field:  fmt.Sprintf("ExamLos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamLOResponseValidationError{
						field:  fmt.Sprintf("ExamLos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamLOResponseValidationError{
					field:  fmt.Sprintf("ExamLos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListExamLOResponseMultiError(errors)
	}

	return nil
}

// ListExamLOResponseMultiError is an error wrapping multiple validation errors
// returned by ListExamLOResponse.ValidateAll() if the designated constraints
// aren't met.
type ListExamLOResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOResponseMultiError) AllErrors() []error { return m }

// ListExamLOResponseValidationError is the validation error returned by
// ListExamLOResponse.Validate if the designated constraints aren't met.
type ListExamLOResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOResponseValidationError) ErrorName() string {
	return "ListExamLOResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOResponseValidationError{}

// Validate checks the field values on ListHighestResultExamLOSubmissionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListHighestResultExamLOSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListHighestResultExamLOSubmissionRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListHighestResultExamLOSubmissionRequestMultiError, or nil if none found.
func (m *ListHighestResultExamLOSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHighestResultExamLOSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStudyPlanItemIdentities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListHighestResultExamLOSubmissionRequestValidationError{
						field:  fmt.Sprintf("StudyPlanItemIdentities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListHighestResultExamLOSubmissionRequestValidationError{
						field:  fmt.Sprintf("StudyPlanItemIdentities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListHighestResultExamLOSubmissionRequestValidationError{
					field:  fmt.Sprintf("StudyPlanItemIdentities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListHighestResultExamLOSubmissionRequestMultiError(errors)
	}

	return nil
}

// ListHighestResultExamLOSubmissionRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListHighestResultExamLOSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type ListHighestResultExamLOSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHighestResultExamLOSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHighestResultExamLOSubmissionRequestMultiError) AllErrors() []error { return m }

// ListHighestResultExamLOSubmissionRequestValidationError is the validation
// error returned by ListHighestResultExamLOSubmissionRequest.Validate if the
// designated constraints aren't met.
type ListHighestResultExamLOSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHighestResultExamLOSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHighestResultExamLOSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHighestResultExamLOSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHighestResultExamLOSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHighestResultExamLOSubmissionRequestValidationError) ErrorName() string {
	return "ListHighestResultExamLOSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListHighestResultExamLOSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHighestResultExamLOSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHighestResultExamLOSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHighestResultExamLOSubmissionRequestValidationError{}

// Validate checks the field values on
// ListHighestResultExamLOSubmissionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListHighestResultExamLOSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListHighestResultExamLOSubmissionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListHighestResultExamLOSubmissionResponseMultiError, or nil if none found.
func (m *ListHighestResultExamLOSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHighestResultExamLOSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStudyPlanItemResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListHighestResultExamLOSubmissionResponseValidationError{
						field:  fmt.Sprintf("StudyPlanItemResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListHighestResultExamLOSubmissionResponseValidationError{
						field:  fmt.Sprintf("StudyPlanItemResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListHighestResultExamLOSubmissionResponseValidationError{
					field:  fmt.Sprintf("StudyPlanItemResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListHighestResultExamLOSubmissionResponseMultiError(errors)
	}

	return nil
}

// ListHighestResultExamLOSubmissionResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListHighestResultExamLOSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type ListHighestResultExamLOSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHighestResultExamLOSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHighestResultExamLOSubmissionResponseMultiError) AllErrors() []error { return m }

// ListHighestResultExamLOSubmissionResponseValidationError is the validation
// error returned by ListHighestResultExamLOSubmissionResponse.Validate if the
// designated constraints aren't met.
type ListHighestResultExamLOSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHighestResultExamLOSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHighestResultExamLOSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHighestResultExamLOSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHighestResultExamLOSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHighestResultExamLOSubmissionResponseValidationError) ErrorName() string {
	return "ListHighestResultExamLOSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListHighestResultExamLOSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHighestResultExamLOSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHighestResultExamLOSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHighestResultExamLOSubmissionResponseValidationError{}

// Validate checks the field values on ListExamLOSubmissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListExamLOSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLOSubmissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamLOSubmissionRequestMultiError, or nil if none found.
func (m *ListExamLOSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPaging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "Paging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCourseId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "CourseId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "CourseId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCourseId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "CourseId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStudentName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "StudentName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "StudentName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudentName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "StudentName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "ExamName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "ExamName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "ExamName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCorrectorId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "CorrectorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "CorrectorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCorrectorId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "CorrectorId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubmittedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "SubmittedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "SubmittedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmittedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "SubmittedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastUpdatedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "LastUpdatedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "LastUpdatedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdatedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "LastUpdatedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubmissionId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "SubmissionId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequestValidationError{
					field:  "SubmissionId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmissionId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequestValidationError{
				field:  "SubmissionId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListExamLOSubmissionRequestMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionRequestMultiError is an error wrapping multiple
// validation errors returned by ListExamLOSubmissionRequest.ValidateAll() if
// the designated constraints aren't met.
type ListExamLOSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionRequestMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionRequestValidationError is the validation error returned
// by ListExamLOSubmissionRequest.Validate if the designated constraints
// aren't met.
type ListExamLOSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionRequestValidationError) ErrorName() string {
	return "ListExamLOSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionRequestValidationError{}

// Validate checks the field values on ListExamLOSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListExamLOSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLOSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamLOSubmissionResponseMultiError, or nil if none found.
func (m *ListExamLOSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNextPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionResponseValidationError{
					field:  "NextPage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionResponseValidationError{
					field:  "NextPage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionResponseValidationError{
				field:  "NextPage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamLOSubmissionResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamLOSubmissionResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamLOSubmissionResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListExamLOSubmissionResponseMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionResponseMultiError is an error wrapping multiple
// validation errors returned by ListExamLOSubmissionResponse.ValidateAll() if
// the designated constraints aren't met.
type ListExamLOSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionResponseMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionResponseValidationError is the validation error returned
// by ListExamLOSubmissionResponse.Validate if the designated constraints
// aren't met.
type ListExamLOSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionResponseValidationError) ErrorName() string {
	return "ListExamLOSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionResponseValidationError{}

// Validate checks the field values on ExamLOSubmission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExamLOSubmission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExamLOSubmission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExamLOSubmissionMultiError, or nil if none found.
func (m *ExamLOSubmission) ValidateAll() error {
	return m.validate(true)
}

func (m *ExamLOSubmission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubmissionId

	if all {
		switch v := interface{}(m.GetStudyPlanItemIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "StudyPlanItemIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "StudyPlanItemIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudyPlanItemIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "StudyPlanItemIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShuffledQuizSetId

	// no validation rules for SubmissionStatus

	// no validation rules for SubmissionResult

	if all {
		switch v := interface{}(m.GetSubmittedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "SubmittedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "SubmittedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmittedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "SubmittedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CourseId

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LastAction

	if all {
		switch v := interface{}(m.GetLastActionAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "LastActionAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "LastActionAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastActionAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "LastActionAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastActionBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "LastActionBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "LastActionBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastActionBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "LastActionBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCorrectorId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "CorrectorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "CorrectorId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCorrectorId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "CorrectorId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMarkDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "MarkDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionValidationError{
					field:  "MarkDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMarkDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionValidationError{
				field:  "MarkDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExamLOSubmissionMultiError(errors)
	}

	return nil
}

// ExamLOSubmissionMultiError is an error wrapping multiple validation errors
// returned by ExamLOSubmission.ValidateAll() if the designated constraints
// aren't met.
type ExamLOSubmissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExamLOSubmissionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExamLOSubmissionMultiError) AllErrors() []error { return m }

// ExamLOSubmissionValidationError is the validation error returned by
// ExamLOSubmission.Validate if the designated constraints aren't met.
type ExamLOSubmissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExamLOSubmissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExamLOSubmissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExamLOSubmissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExamLOSubmissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExamLOSubmissionValidationError) ErrorName() string { return "ExamLOSubmissionValidationError" }

// Error satisfies the builtin error interface
func (e ExamLOSubmissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExamLOSubmission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExamLOSubmissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExamLOSubmissionValidationError{}

// Validate checks the field values on ListExamLOSubmissionScoreRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListExamLOSubmissionScoreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLOSubmissionScoreRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListExamLOSubmissionScoreRequestMultiError, or nil if none found.
func (m *ListExamLOSubmissionScoreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionScoreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubmissionId

	// no validation rules for ShuffledQuizSetId

	if len(errors) > 0 {
		return ListExamLOSubmissionScoreRequestMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionScoreRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListExamLOSubmissionScoreRequest.ValidateAll() if the designated
// constraints aren't met.
type ListExamLOSubmissionScoreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionScoreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionScoreRequestMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionScoreRequestValidationError is the validation error
// returned by ListExamLOSubmissionScoreRequest.Validate if the designated
// constraints aren't met.
type ListExamLOSubmissionScoreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionScoreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionScoreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionScoreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionScoreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionScoreRequestValidationError) ErrorName() string {
	return "ListExamLOSubmissionScoreRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionScoreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionScoreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionScoreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionScoreRequestValidationError{}

// Validate checks the field values on ListExamLOSubmissionScoreResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListExamLOSubmissionScoreResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLOSubmissionScoreResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListExamLOSubmissionScoreResponseMultiError, or nil if none found.
func (m *ListExamLOSubmissionScoreResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionScoreResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSubmissionScores() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
						field:  fmt.Sprintf("SubmissionScores[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
						field:  fmt.Sprintf("SubmissionScores[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamLOSubmissionScoreResponseValidationError{
					field:  fmt.Sprintf("SubmissionScores[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TeacherFeedback

	// no validation rules for SubmissionStatus

	// no validation rules for SubmissionResult

	if all {
		switch v := interface{}(m.GetTotalGradedPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
					field:  "TotalGradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
					field:  "TotalGradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalGradedPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionScoreResponseValidationError{
				field:  "TotalGradedPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
					field:  "TotalPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
					field:  "TotalPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionScoreResponseValidationError{
				field:  "TotalPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetQuestionGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
						field:  fmt.Sprintf("QuestionGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamLOSubmissionScoreResponseValidationError{
						field:  fmt.Sprintf("QuestionGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamLOSubmissionScoreResponseValidationError{
					field:  fmt.Sprintf("QuestionGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListExamLOSubmissionScoreResponseMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionScoreResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListExamLOSubmissionScoreResponse.ValidateAll() if the designated
// constraints aren't met.
type ListExamLOSubmissionScoreResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionScoreResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionScoreResponseMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionScoreResponseValidationError is the validation error
// returned by ListExamLOSubmissionScoreResponse.Validate if the designated
// constraints aren't met.
type ListExamLOSubmissionScoreResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionScoreResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionScoreResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionScoreResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionScoreResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionScoreResponseValidationError) ErrorName() string {
	return "ListExamLOSubmissionScoreResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionScoreResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionScoreResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionScoreResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionScoreResponseValidationError{}

// Validate checks the field values on ExamLOSubmissionScore with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExamLOSubmissionScore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExamLOSubmissionScore with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExamLOSubmissionScoreMultiError, or nil if none found.
func (m *ExamLOSubmissionScore) ValidateAll() error {
	return m.validate(true)
}

func (m *ExamLOSubmissionScore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ShuffleQuizSetId

	// no validation rules for QuizType

	// no validation rules for IsAccepted

	if all {
		switch v := interface{}(m.GetCore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionScoreValidationError{
					field:  "Core",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionScoreValidationError{
					field:  "Core",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionScoreValidationError{
				field:  "Core",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TeacherComment

	if all {
		switch v := interface{}(m.GetGradedPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionScoreValidationError{
					field:  "GradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionScoreValidationError{
					field:  "GradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGradedPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionScoreValidationError{
				field:  "GradedPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionScoreValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionScoreValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionScoreValidationError{
				field:  "Point",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Result.(type) {
	case *ExamLOSubmissionScore_OrderingResult:
		if v == nil {
			err := ExamLOSubmissionScoreValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderingResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExamLOSubmissionScoreValidationError{
						field:  "OrderingResult",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExamLOSubmissionScoreValidationError{
						field:  "OrderingResult",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderingResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExamLOSubmissionScoreValidationError{
					field:  "OrderingResult",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExamLOSubmissionScoreMultiError(errors)
	}

	return nil
}

// ExamLOSubmissionScoreMultiError is an error wrapping multiple validation
// errors returned by ExamLOSubmissionScore.ValidateAll() if the designated
// constraints aren't met.
type ExamLOSubmissionScoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExamLOSubmissionScoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExamLOSubmissionScoreMultiError) AllErrors() []error { return m }

// ExamLOSubmissionScoreValidationError is the validation error returned by
// ExamLOSubmissionScore.Validate if the designated constraints aren't met.
type ExamLOSubmissionScoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExamLOSubmissionScoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExamLOSubmissionScoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExamLOSubmissionScoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExamLOSubmissionScoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExamLOSubmissionScoreValidationError) ErrorName() string {
	return "ExamLOSubmissionScoreValidationError"
}

// Error satisfies the builtin error interface
func (e ExamLOSubmissionScoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExamLOSubmissionScore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExamLOSubmissionScoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExamLOSubmissionScoreValidationError{}

// Validate checks the field values on ListExamLOSubmissionResultRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListExamLOSubmissionResultRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLOSubmissionResultRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListExamLOSubmissionResultRequestMultiError, or nil if none found.
func (m *ListExamLOSubmissionResultRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionResultRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStudyPlanItemIdentities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamLOSubmissionResultRequestValidationError{
						field:  fmt.Sprintf("StudyPlanItemIdentities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamLOSubmissionResultRequestValidationError{
						field:  fmt.Sprintf("StudyPlanItemIdentities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamLOSubmissionResultRequestValidationError{
					field:  fmt.Sprintf("StudyPlanItemIdentities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListExamLOSubmissionResultRequestMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionResultRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListExamLOSubmissionResultRequest.ValidateAll() if the designated
// constraints aren't met.
type ListExamLOSubmissionResultRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionResultRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionResultRequestMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionResultRequestValidationError is the validation error
// returned by ListExamLOSubmissionResultRequest.Validate if the designated
// constraints aren't met.
type ListExamLOSubmissionResultRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionResultRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionResultRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionResultRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionResultRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionResultRequestValidationError) ErrorName() string {
	return "ListExamLOSubmissionResultRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionResultRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionResultRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionResultRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionResultRequestValidationError{}

// Validate checks the field values on ListExamLOSubmissionResultResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListExamLOSubmissionResultResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamLOSubmissionResultResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListExamLOSubmissionResultResponseMultiError, or nil if none found.
func (m *ListExamLOSubmissionResultResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionResultResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamLOSubmissionResultResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamLOSubmissionResultResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamLOSubmissionResultResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for HighestCrown

	// no validation rules for TotalAttempts

	if all {
		switch v := interface{}(m.GetHighestScore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionResultResponseValidationError{
					field:  "HighestScore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionResultResponseValidationError{
					field:  "HighestScore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHighestScore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionResultResponseValidationError{
				field:  "HighestScore",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListExamLOSubmissionResultResponseMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionResultResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListExamLOSubmissionResultResponse.ValidateAll() if the designated
// constraints aren't met.
type ListExamLOSubmissionResultResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionResultResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionResultResponseMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionResultResponseValidationError is the validation error
// returned by ListExamLOSubmissionResultResponse.Validate if the designated
// constraints aren't met.
type ListExamLOSubmissionResultResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionResultResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionResultResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionResultResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionResultResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionResultResponseValidationError) ErrorName() string {
	return "ListExamLOSubmissionResultResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionResultResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionResultResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionResultResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionResultResponseValidationError{}

// Validate checks the field values on ExamLOSubmissions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExamLOSubmissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExamLOSubmissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExamLOSubmissionsMultiError, or nil if none found.
func (m *ExamLOSubmissions) ValidateAll() error {
	return m.validate(true)
}

func (m *ExamLOSubmissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExamLOSubmissionsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExamLOSubmissionsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExamLOSubmissionsValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExamLOSubmissionsMultiError(errors)
	}

	return nil
}

// ExamLOSubmissionsMultiError is an error wrapping multiple validation errors
// returned by ExamLOSubmissions.ValidateAll() if the designated constraints
// aren't met.
type ExamLOSubmissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExamLOSubmissionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExamLOSubmissionsMultiError) AllErrors() []error { return m }

// ExamLOSubmissionsValidationError is the validation error returned by
// ExamLOSubmissions.Validate if the designated constraints aren't met.
type ExamLOSubmissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExamLOSubmissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExamLOSubmissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExamLOSubmissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExamLOSubmissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExamLOSubmissionsValidationError) ErrorName() string {
	return "ExamLOSubmissionsValidationError"
}

// Error satisfies the builtin error interface
func (e ExamLOSubmissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExamLOSubmissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExamLOSubmissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExamLOSubmissionsValidationError{}

// Validate checks the field values on ExamLOSubmissionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExamLOSubmissionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExamLOSubmissionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExamLOSubmissionInfoMultiError, or nil if none found.
func (m *ExamLOSubmissionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ExamLOSubmissionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ShuffledQuizSetId

	if all {
		switch v := interface{}(m.GetTotalGradedPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "TotalGradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "TotalGradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalGradedPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionInfoValidationError{
				field:  "TotalGradedPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "TotalPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "TotalPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionInfoValidationError{
				field:  "TotalPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SubmissionResult

	// no validation rules for SubmissionStatus

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExamLOSubmissionInfoValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExamLOSubmissionInfoValidationError{
				field:  "CompletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TotalLearningTime

	// no validation rules for SubmissionId

	if len(errors) > 0 {
		return ExamLOSubmissionInfoMultiError(errors)
	}

	return nil
}

// ExamLOSubmissionInfoMultiError is an error wrapping multiple validation
// errors returned by ExamLOSubmissionInfo.ValidateAll() if the designated
// constraints aren't met.
type ExamLOSubmissionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExamLOSubmissionInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExamLOSubmissionInfoMultiError) AllErrors() []error { return m }

// ExamLOSubmissionInfoValidationError is the validation error returned by
// ExamLOSubmissionInfo.Validate if the designated constraints aren't met.
type ExamLOSubmissionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExamLOSubmissionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExamLOSubmissionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExamLOSubmissionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExamLOSubmissionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExamLOSubmissionInfoValidationError) ErrorName() string {
	return "ExamLOSubmissionInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ExamLOSubmissionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExamLOSubmissionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExamLOSubmissionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExamLOSubmissionInfoValidationError{}

// Validate checks the field values on GradeAManualGradingExamSubmissionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GradeAManualGradingExamSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GradeAManualGradingExamSubmissionRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GradeAManualGradingExamSubmissionRequestMultiError, or nil if none found.
func (m *GradeAManualGradingExamSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GradeAManualGradingExamSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubmissionId

	// no validation rules for ShuffledQuizSetId

	// no validation rules for TeacherFeedback

	// no validation rules for SubmissionStatus

	for idx, item := range m.GetTeacherExamGrades() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GradeAManualGradingExamSubmissionRequestValidationError{
						field:  fmt.Sprintf("TeacherExamGrades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GradeAManualGradingExamSubmissionRequestValidationError{
						field:  fmt.Sprintf("TeacherExamGrades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GradeAManualGradingExamSubmissionRequestValidationError{
					field:  fmt.Sprintf("TeacherExamGrades[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GradeAManualGradingExamSubmissionRequestMultiError(errors)
	}

	return nil
}

// GradeAManualGradingExamSubmissionRequestMultiError is an error wrapping
// multiple validation errors returned by
// GradeAManualGradingExamSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type GradeAManualGradingExamSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GradeAManualGradingExamSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GradeAManualGradingExamSubmissionRequestMultiError) AllErrors() []error { return m }

// GradeAManualGradingExamSubmissionRequestValidationError is the validation
// error returned by GradeAManualGradingExamSubmissionRequest.Validate if the
// designated constraints aren't met.
type GradeAManualGradingExamSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GradeAManualGradingExamSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GradeAManualGradingExamSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GradeAManualGradingExamSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GradeAManualGradingExamSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GradeAManualGradingExamSubmissionRequestValidationError) ErrorName() string {
	return "GradeAManualGradingExamSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GradeAManualGradingExamSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGradeAManualGradingExamSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GradeAManualGradingExamSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GradeAManualGradingExamSubmissionRequestValidationError{}

// Validate checks the field values on TeacherExamGrade with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TeacherExamGrade) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TeacherExamGrade with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TeacherExamGradeMultiError, or nil if none found.
func (m *TeacherExamGrade) ValidateAll() error {
	return m.validate(true)
}

func (m *TeacherExamGrade) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuizId

	if all {
		switch v := interface{}(m.GetTeacherPointGiven()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TeacherExamGradeValidationError{
					field:  "TeacherPointGiven",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TeacherExamGradeValidationError{
					field:  "TeacherPointGiven",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTeacherPointGiven()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TeacherExamGradeValidationError{
				field:  "TeacherPointGiven",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TeacherComment

	// no validation rules for IsAccepted

	if len(errors) > 0 {
		return TeacherExamGradeMultiError(errors)
	}

	return nil
}

// TeacherExamGradeMultiError is an error wrapping multiple validation errors
// returned by TeacherExamGrade.ValidateAll() if the designated constraints
// aren't met.
type TeacherExamGradeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TeacherExamGradeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TeacherExamGradeMultiError) AllErrors() []error { return m }

// TeacherExamGradeValidationError is the validation error returned by
// TeacherExamGrade.Validate if the designated constraints aren't met.
type TeacherExamGradeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TeacherExamGradeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TeacherExamGradeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TeacherExamGradeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TeacherExamGradeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TeacherExamGradeValidationError) ErrorName() string { return "TeacherExamGradeValidationError" }

// Error satisfies the builtin error interface
func (e TeacherExamGradeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTeacherExamGrade.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TeacherExamGradeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TeacherExamGradeValidationError{}

// Validate checks the field values on
// GradeAManualGradingExamSubmissionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GradeAManualGradingExamSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GradeAManualGradingExamSubmissionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GradeAManualGradingExamSubmissionResponseMultiError, or nil if none found.
func (m *GradeAManualGradingExamSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GradeAManualGradingExamSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTotalGradedPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GradeAManualGradingExamSubmissionResponseValidationError{
					field:  "TotalGradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GradeAManualGradingExamSubmissionResponseValidationError{
					field:  "TotalGradedPoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalGradedPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GradeAManualGradingExamSubmissionResponseValidationError{
				field:  "TotalGradedPoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GradeAManualGradingExamSubmissionResponseMultiError(errors)
	}

	return nil
}

// GradeAManualGradingExamSubmissionResponseMultiError is an error wrapping
// multiple validation errors returned by
// GradeAManualGradingExamSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type GradeAManualGradingExamSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GradeAManualGradingExamSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GradeAManualGradingExamSubmissionResponseMultiError) AllErrors() []error { return m }

// GradeAManualGradingExamSubmissionResponseValidationError is the validation
// error returned by GradeAManualGradingExamSubmissionResponse.Validate if the
// designated constraints aren't met.
type GradeAManualGradingExamSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GradeAManualGradingExamSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GradeAManualGradingExamSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GradeAManualGradingExamSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GradeAManualGradingExamSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GradeAManualGradingExamSubmissionResponseValidationError) ErrorName() string {
	return "GradeAManualGradingExamSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GradeAManualGradingExamSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGradeAManualGradingExamSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GradeAManualGradingExamSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GradeAManualGradingExamSubmissionResponseValidationError{}

// Validate checks the field values on DeleteExamLOSubmissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteExamLOSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteExamLOSubmissionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteExamLOSubmissionRequestMultiError, or nil if none found.
func (m *DeleteExamLOSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteExamLOSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubmissionId

	if len(errors) > 0 {
		return DeleteExamLOSubmissionRequestMultiError(errors)
	}

	return nil
}

// DeleteExamLOSubmissionRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteExamLOSubmissionRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteExamLOSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteExamLOSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteExamLOSubmissionRequestMultiError) AllErrors() []error { return m }

// DeleteExamLOSubmissionRequestValidationError is the validation error
// returned by DeleteExamLOSubmissionRequest.Validate if the designated
// constraints aren't met.
type DeleteExamLOSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteExamLOSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteExamLOSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteExamLOSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteExamLOSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteExamLOSubmissionRequestValidationError) ErrorName() string {
	return "DeleteExamLOSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteExamLOSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteExamLOSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteExamLOSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteExamLOSubmissionRequestValidationError{}

// Validate checks the field values on DeleteExamLOSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteExamLOSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteExamLOSubmissionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteExamLOSubmissionResponseMultiError, or nil if none found.
func (m *DeleteExamLOSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteExamLOSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteExamLOSubmissionResponseMultiError(errors)
	}

	return nil
}

// DeleteExamLOSubmissionResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteExamLOSubmissionResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteExamLOSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteExamLOSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteExamLOSubmissionResponseMultiError) AllErrors() []error { return m }

// DeleteExamLOSubmissionResponseValidationError is the validation error
// returned by DeleteExamLOSubmissionResponse.Validate if the designated
// constraints aren't met.
type DeleteExamLOSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteExamLOSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteExamLOSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteExamLOSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteExamLOSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteExamLOSubmissionResponseValidationError) ErrorName() string {
	return "DeleteExamLOSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteExamLOSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteExamLOSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteExamLOSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteExamLOSubmissionResponseValidationError{}

// Validate checks the field values on BulkApproveRejectSubmissionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BulkApproveRejectSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkApproveRejectSubmissionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BulkApproveRejectSubmissionRequestMultiError, or nil if none found.
func (m *BulkApproveRejectSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkApproveRejectSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApproveGradingAction

	if len(errors) > 0 {
		return BulkApproveRejectSubmissionRequestMultiError(errors)
	}

	return nil
}

// BulkApproveRejectSubmissionRequestMultiError is an error wrapping multiple
// validation errors returned by
// BulkApproveRejectSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type BulkApproveRejectSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkApproveRejectSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkApproveRejectSubmissionRequestMultiError) AllErrors() []error { return m }

// BulkApproveRejectSubmissionRequestValidationError is the validation error
// returned by BulkApproveRejectSubmissionRequest.Validate if the designated
// constraints aren't met.
type BulkApproveRejectSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkApproveRejectSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkApproveRejectSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkApproveRejectSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkApproveRejectSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkApproveRejectSubmissionRequestValidationError) ErrorName() string {
	return "BulkApproveRejectSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BulkApproveRejectSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkApproveRejectSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkApproveRejectSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkApproveRejectSubmissionRequestValidationError{}

// Validate checks the field values on BulkApproveRejectSubmissionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BulkApproveRejectSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkApproveRejectSubmissionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BulkApproveRejectSubmissionResponseMultiError, or nil if none found.
func (m *BulkApproveRejectSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkApproveRejectSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BulkApproveRejectSubmissionResponseMultiError(errors)
	}

	return nil
}

// BulkApproveRejectSubmissionResponseMultiError is an error wrapping multiple
// validation errors returned by
// BulkApproveRejectSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type BulkApproveRejectSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkApproveRejectSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkApproveRejectSubmissionResponseMultiError) AllErrors() []error { return m }

// BulkApproveRejectSubmissionResponseValidationError is the validation error
// returned by BulkApproveRejectSubmissionResponse.Validate if the designated
// constraints aren't met.
type BulkApproveRejectSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkApproveRejectSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkApproveRejectSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkApproveRejectSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkApproveRejectSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkApproveRejectSubmissionResponseValidationError) ErrorName() string {
	return "BulkApproveRejectSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BulkApproveRejectSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkApproveRejectSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkApproveRejectSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkApproveRejectSubmissionResponseValidationError{}

// Validate checks the field values on RetrieveMetadataTaggingResultRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *RetrieveMetadataTaggingResultRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetrieveMetadataTaggingResultRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// RetrieveMetadataTaggingResultRequestMultiError, or nil if none found.
func (m *RetrieveMetadataTaggingResultRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RetrieveMetadataTaggingResultRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubmissionId

	if len(errors) > 0 {
		return RetrieveMetadataTaggingResultRequestMultiError(errors)
	}

	return nil
}

// RetrieveMetadataTaggingResultRequestMultiError is an error wrapping multiple
// validation errors returned by
// RetrieveMetadataTaggingResultRequest.ValidateAll() if the designated
// constraints aren't met.
type RetrieveMetadataTaggingResultRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetrieveMetadataTaggingResultRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetrieveMetadataTaggingResultRequestMultiError) AllErrors() []error { return m }

// RetrieveMetadataTaggingResultRequestValidationError is the validation error
// returned by RetrieveMetadataTaggingResultRequest.Validate if the designated
// constraints aren't met.
type RetrieveMetadataTaggingResultRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetrieveMetadataTaggingResultRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetrieveMetadataTaggingResultRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetrieveMetadataTaggingResultRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetrieveMetadataTaggingResultRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetrieveMetadataTaggingResultRequestValidationError) ErrorName() string {
	return "RetrieveMetadataTaggingResultRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RetrieveMetadataTaggingResultRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetrieveMetadataTaggingResultRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetrieveMetadataTaggingResultRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetrieveMetadataTaggingResultRequestValidationError{}

// Validate checks the field values on RetrieveMetadataTaggingResultResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *RetrieveMetadataTaggingResultResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetrieveMetadataTaggingResultResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// RetrieveMetadataTaggingResultResponseMultiError, or nil if none found.
func (m *RetrieveMetadataTaggingResultResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RetrieveMetadataTaggingResultResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTaggingResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RetrieveMetadataTaggingResultResponseValidationError{
						field:  fmt.Sprintf("TaggingResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RetrieveMetadataTaggingResultResponseValidationError{
						field:  fmt.Sprintf("TaggingResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RetrieveMetadataTaggingResultResponseValidationError{
					field:  fmt.Sprintf("TaggingResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RetrieveMetadataTaggingResultResponseMultiError(errors)
	}

	return nil
}

// RetrieveMetadataTaggingResultResponseMultiError is an error wrapping
// multiple validation errors returned by
// RetrieveMetadataTaggingResultResponse.ValidateAll() if the designated
// constraints aren't met.
type RetrieveMetadataTaggingResultResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetrieveMetadataTaggingResultResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetrieveMetadataTaggingResultResponseMultiError) AllErrors() []error { return m }

// RetrieveMetadataTaggingResultResponseValidationError is the validation error
// returned by RetrieveMetadataTaggingResultResponse.Validate if the
// designated constraints aren't met.
type RetrieveMetadataTaggingResultResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetrieveMetadataTaggingResultResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetrieveMetadataTaggingResultResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetrieveMetadataTaggingResultResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetrieveMetadataTaggingResultResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetrieveMetadataTaggingResultResponseValidationError) ErrorName() string {
	return "RetrieveMetadataTaggingResultResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RetrieveMetadataTaggingResultResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetrieveMetadataTaggingResultResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetrieveMetadataTaggingResultResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetrieveMetadataTaggingResultResponseValidationError{}

// Validate checks the field values on TaggingResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaggingResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaggingResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaggingResultMultiError, or
// nil if none found.
func (m *TaggingResult) ValidateAll() error {
	return m.validate(true)
}

func (m *TaggingResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TagId

	// no validation rules for TagName

	// no validation rules for GradedPoint

	// no validation rules for TotalPoint

	if len(errors) > 0 {
		return TaggingResultMultiError(errors)
	}

	return nil
}

// TaggingResultMultiError is an error wrapping multiple validation errors
// returned by TaggingResult.ValidateAll() if the designated constraints
// aren't met.
type TaggingResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaggingResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaggingResultMultiError) AllErrors() []error { return m }

// TaggingResultValidationError is the validation error returned by
// TaggingResult.Validate if the designated constraints aren't met.
type TaggingResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaggingResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaggingResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaggingResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaggingResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaggingResultValidationError) ErrorName() string { return "TaggingResultValidationError" }

// Error satisfies the builtin error interface
func (e TaggingResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaggingResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaggingResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaggingResultValidationError{}

// Validate checks the field values on
// ListHighestResultExamLOSubmissionResponse_StudyPlanItemResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListHighestResultExamLOSubmissionResponse_StudyPlanItemResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListHighestResultExamLOSubmissionResponse_StudyPlanItemResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultMultiError, or
// nil if none found.
func (m *ListHighestResultExamLOSubmissionResponse_StudyPlanItemResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHighestResultExamLOSubmissionResponse_StudyPlanItemResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStudyPlanItemIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError{
					field:  "StudyPlanItemIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError{
					field:  "StudyPlanItemIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudyPlanItemIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError{
				field:  "StudyPlanItemIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LatestExamLoSubmissionResult

	if len(errors) > 0 {
		return ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultMultiError(errors)
	}

	return nil
}

// ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultMultiError is
// an error wrapping multiple validation errors returned by
// ListHighestResultExamLOSubmissionResponse_StudyPlanItemResult.ValidateAll()
// if the designated constraints aren't met.
type ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultMultiError) AllErrors() []error {
	return m
}

// ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError
// is the validation error returned by
// ListHighestResultExamLOSubmissionResponse_StudyPlanItemResult.Validate if
// the designated constraints aren't met.
type ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError) ErrorName() string {
	return "ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError"
}

// Error satisfies the builtin error interface
func (e ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHighestResultExamLOSubmissionResponse_StudyPlanItemResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHighestResultExamLOSubmissionResponse_StudyPlanItemResultValidationError{}

// Validate checks the field values on
// ListExamLOSubmissionRequest_SubmittedDate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListExamLOSubmissionRequest_SubmittedDate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListExamLOSubmissionRequest_SubmittedDate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListExamLOSubmissionRequest_SubmittedDateMultiError, or nil if none found.
func (m *ListExamLOSubmissionRequest_SubmittedDate) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionRequest_SubmittedDate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_SubmittedDateValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_SubmittedDateValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequest_SubmittedDateValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_SubmittedDateValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_SubmittedDateValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequest_SubmittedDateValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListExamLOSubmissionRequest_SubmittedDateMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionRequest_SubmittedDateMultiError is an error wrapping
// multiple validation errors returned by
// ListExamLOSubmissionRequest_SubmittedDate.ValidateAll() if the designated
// constraints aren't met.
type ListExamLOSubmissionRequest_SubmittedDateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionRequest_SubmittedDateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionRequest_SubmittedDateMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionRequest_SubmittedDateValidationError is the validation
// error returned by ListExamLOSubmissionRequest_SubmittedDate.Validate if the
// designated constraints aren't met.
type ListExamLOSubmissionRequest_SubmittedDateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionRequest_SubmittedDateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionRequest_SubmittedDateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionRequest_SubmittedDateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionRequest_SubmittedDateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionRequest_SubmittedDateValidationError) ErrorName() string {
	return "ListExamLOSubmissionRequest_SubmittedDateValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionRequest_SubmittedDateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionRequest_SubmittedDate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionRequest_SubmittedDateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionRequest_SubmittedDateValidationError{}

// Validate checks the field values on
// ListExamLOSubmissionRequest_LastUpdatedDate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListExamLOSubmissionRequest_LastUpdatedDate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListExamLOSubmissionRequest_LastUpdatedDate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListExamLOSubmissionRequest_LastUpdatedDateMultiError, or nil if none found.
func (m *ListExamLOSubmissionRequest_LastUpdatedDate) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionRequest_LastUpdatedDate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_LastUpdatedDateValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_LastUpdatedDateValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequest_LastUpdatedDateValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_LastUpdatedDateValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionRequest_LastUpdatedDateValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionRequest_LastUpdatedDateValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListExamLOSubmissionRequest_LastUpdatedDateMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionRequest_LastUpdatedDateMultiError is an error wrapping
// multiple validation errors returned by
// ListExamLOSubmissionRequest_LastUpdatedDate.ValidateAll() if the designated
// constraints aren't met.
type ListExamLOSubmissionRequest_LastUpdatedDateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionRequest_LastUpdatedDateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionRequest_LastUpdatedDateMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionRequest_LastUpdatedDateValidationError is the validation
// error returned by ListExamLOSubmissionRequest_LastUpdatedDate.Validate if
// the designated constraints aren't met.
type ListExamLOSubmissionRequest_LastUpdatedDateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionRequest_LastUpdatedDateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionRequest_LastUpdatedDateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionRequest_LastUpdatedDateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionRequest_LastUpdatedDateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionRequest_LastUpdatedDateValidationError) ErrorName() string {
	return "ListExamLOSubmissionRequest_LastUpdatedDateValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionRequest_LastUpdatedDateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionRequest_LastUpdatedDate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionRequest_LastUpdatedDateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionRequest_LastUpdatedDateValidationError{}

// Validate checks the field values on ListExamLOSubmissionResultResponseItem
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListExamLOSubmissionResultResponseItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListExamLOSubmissionResultResponseItem with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListExamLOSubmissionResultResponseItemMultiError, or nil if none found.
func (m *ListExamLOSubmissionResultResponseItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamLOSubmissionResultResponseItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStudyPlanItemIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionResultResponseItemValidationError{
					field:  "StudyPlanItemIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionResultResponseItemValidationError{
					field:  "StudyPlanItemIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudyPlanItemIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionResultResponseItemValidationError{
				field:  "StudyPlanItemIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamLoSubmissions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListExamLOSubmissionResultResponseItemValidationError{
					field:  "ExamLoSubmissions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListExamLOSubmissionResultResponseItemValidationError{
					field:  "ExamLoSubmissions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamLoSubmissions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListExamLOSubmissionResultResponseItemValidationError{
				field:  "ExamLoSubmissions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListExamLOSubmissionResultResponseItemMultiError(errors)
	}

	return nil
}

// ListExamLOSubmissionResultResponseItemMultiError is an error wrapping
// multiple validation errors returned by
// ListExamLOSubmissionResultResponseItem.ValidateAll() if the designated
// constraints aren't met.
type ListExamLOSubmissionResultResponseItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamLOSubmissionResultResponseItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamLOSubmissionResultResponseItemMultiError) AllErrors() []error { return m }

// ListExamLOSubmissionResultResponseItemValidationError is the validation
// error returned by ListExamLOSubmissionResultResponseItem.Validate if the
// designated constraints aren't met.
type ListExamLOSubmissionResultResponseItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamLOSubmissionResultResponseItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamLOSubmissionResultResponseItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamLOSubmissionResultResponseItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamLOSubmissionResultResponseItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamLOSubmissionResultResponseItemValidationError) ErrorName() string {
	return "ListExamLOSubmissionResultResponseItemValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamLOSubmissionResultResponseItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamLOSubmissionResultResponseItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamLOSubmissionResultResponseItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamLOSubmissionResultResponseItemValidationError{}
