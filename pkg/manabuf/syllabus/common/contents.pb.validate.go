// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: syllabus/common/contents.proto

package scpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ContentBasicInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContentBasicInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContentBasicInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContentBasicInfoMultiError, or nil if none found.
func (m *ContentBasicInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ContentBasicInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Country

	// no validation rules for Subject

	// no validation rules for Grade

	// no validation rules for SchoolId

	// no validation rules for DisplayOrder

	// no validation rules for MasterId

	// no validation rules for IconUrl

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContentBasicInfoValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContentBasicInfoValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContentBasicInfoValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContentBasicInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContentBasicInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContentBasicInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContentBasicInfoValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContentBasicInfoValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContentBasicInfoValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContentBasicInfoMultiError(errors)
	}

	return nil
}

// ContentBasicInfoMultiError is an error wrapping multiple validation errors
// returned by ContentBasicInfo.ValidateAll() if the designated constraints
// aren't met.
type ContentBasicInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContentBasicInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContentBasicInfoMultiError) AllErrors() []error { return m }

// ContentBasicInfoValidationError is the validation error returned by
// ContentBasicInfo.Validate if the designated constraints aren't met.
type ContentBasicInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContentBasicInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContentBasicInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContentBasicInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContentBasicInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContentBasicInfoValidationError) ErrorName() string { return "ContentBasicInfoValidationError" }

// Error satisfies the builtin error interface
func (e ContentBasicInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContentBasicInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContentBasicInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContentBasicInfoValidationError{}

// Validate checks the field values on Course with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Course) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Course with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CourseMultiError, or nil if none found.
func (m *Course) ValidateAll() error {
	return m.validate(true)
}

func (m *Course) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CourseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CourseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CourseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CourseStatus

	for idx, item := range m.GetTeachers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CourseValidationError{
						field:  fmt.Sprintf("Teachers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CourseValidationError{
						field:  fmt.Sprintf("Teachers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CourseValidationError{
					field:  fmt.Sprintf("Teachers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CourseMultiError(errors)
	}

	return nil
}

// CourseMultiError is an error wrapping multiple validation errors returned by
// Course.ValidateAll() if the designated constraints aren't met.
type CourseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourseMultiError) AllErrors() []error { return m }

// CourseValidationError is the validation error returned by Course.Validate if
// the designated constraints aren't met.
type CourseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourseValidationError) ErrorName() string { return "CourseValidationError" }

// Error satisfies the builtin error interface
func (e CourseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourseValidationError{}

// Validate checks the field values on Lesson with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Lesson) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Lesson with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LessonMultiError, or nil if none found.
func (m *Lesson) ValidateAll() error {
	return m.validate(true)
}

func (m *Lesson) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LessonValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LessonValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LessonValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CourseId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetTopic()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LessonValidationError{
					field:  "Topic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LessonValidationError{
					field:  "Topic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTopic()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LessonValidationError{
				field:  "Topic",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TotalLearner

	for idx, item := range m.GetTeachers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LessonValidationError{
						field:  fmt.Sprintf("Teachers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LessonValidationError{
						field:  fmt.Sprintf("Teachers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LessonValidationError{
					field:  fmt.Sprintf("Teachers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LessonMultiError(errors)
	}

	return nil
}

// LessonMultiError is an error wrapping multiple validation errors returned by
// Lesson.ValidateAll() if the designated constraints aren't met.
type LessonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LessonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LessonMultiError) AllErrors() []error { return m }

// LessonValidationError is the validation error returned by Lesson.Validate if
// the designated constraints aren't met.
type LessonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LessonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LessonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LessonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LessonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LessonValidationError) ErrorName() string { return "LessonValidationError" }

// Error satisfies the builtin error interface
func (e LessonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLesson.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LessonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LessonValidationError{}

// Validate checks the field values on Book with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Book) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Book with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BookMultiError, or nil if none found.
func (m *Book) ValidateAll() error {
	return m.validate(true)
}

func (m *Book) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BookValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BookValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BookValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BookMultiError(errors)
	}

	return nil
}

// BookMultiError is an error wrapping multiple validation errors returned by
// Book.ValidateAll() if the designated constraints aren't met.
type BookMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BookMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BookMultiError) AllErrors() []error { return m }

// BookValidationError is the validation error returned by Book.Validate if the
// designated constraints aren't met.
type BookValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BookValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BookValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BookValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BookValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BookValidationError) ErrorName() string { return "BookValidationError" }

// Error satisfies the builtin error interface
func (e BookValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBook.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BookValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BookValidationError{}

// Validate checks the field values on Chapter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Chapter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Chapter with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChapterMultiError, or nil if none found.
func (m *Chapter) ValidateAll() error {
	return m.validate(true)
}

func (m *Chapter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChapterValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChapterValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChapterValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BookId

	if len(errors) > 0 {
		return ChapterMultiError(errors)
	}

	return nil
}

// ChapterMultiError is an error wrapping multiple validation errors returned
// by Chapter.ValidateAll() if the designated constraints aren't met.
type ChapterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChapterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChapterMultiError) AllErrors() []error { return m }

// ChapterValidationError is the validation error returned by Chapter.Validate
// if the designated constraints aren't met.
type ChapterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChapterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChapterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChapterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChapterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChapterValidationError) ErrorName() string { return "ChapterValidationError" }

// Error satisfies the builtin error interface
func (e ChapterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChapter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChapterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChapterValidationError{}

// Validate checks the field values on Topic with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Topic) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Topic with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TopicMultiError, or nil if none found.
func (m *Topic) ValidateAll() error {
	return m.validate(true)
}

func (m *Topic) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TopicValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TopicValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TopicValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ChapterId

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for Instruction

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TopicValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TopicValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TopicValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TopicMultiError(errors)
	}

	return nil
}

// TopicMultiError is an error wrapping multiple validation errors returned by
// Topic.ValidateAll() if the designated constraints aren't met.
type TopicMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopicMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopicMultiError) AllErrors() []error { return m }

// TopicValidationError is the validation error returned by Topic.Validate if
// the designated constraints aren't met.
type TopicValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopicValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopicValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopicValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopicValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopicValidationError) ErrorName() string { return "TopicValidationError" }

// Error satisfies the builtin error interface
func (e TopicValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopicValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopicValidationError{}

// Validate checks the field values on LearningObjective with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LearningObjective) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LearningObjective with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LearningObjectiveMultiError, or nil if none found.
func (m *LearningObjective) ValidateAll() error {
	return m.validate(true)
}

func (m *LearningObjective) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LearningObjectiveValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TopicId

	// no validation rules for Video

	// no validation rules for StudyGuide

	// no validation rules for Type

	// no validation rules for Instruction

	if all {
		switch v := interface{}(m.GetGradeToPass()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "GradeToPass",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "GradeToPass",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGradeToPass()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LearningObjectiveValidationError{
				field:  "GradeToPass",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ManualGrading

	if all {
		switch v := interface{}(m.GetTimeLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "TimeLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "TimeLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LearningObjectiveValidationError{
				field:  "TimeLimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaximumAttempt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "MaximumAttempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LearningObjectiveValidationError{
					field:  "MaximumAttempt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaximumAttempt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LearningObjectiveValidationError{
				field:  "MaximumAttempt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApproveGrading

	// no validation rules for GradeCapping

	// no validation rules for ReviewOption

	// no validation rules for VendorType

	if len(errors) > 0 {
		return LearningObjectiveMultiError(errors)
	}

	return nil
}

// LearningObjectiveMultiError is an error wrapping multiple validation errors
// returned by LearningObjective.ValidateAll() if the designated constraints
// aren't met.
type LearningObjectiveMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LearningObjectiveMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LearningObjectiveMultiError) AllErrors() []error { return m }

// LearningObjectiveValidationError is the validation error returned by
// LearningObjective.Validate if the designated constraints aren't met.
type LearningObjectiveValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LearningObjectiveValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LearningObjectiveValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LearningObjectiveValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LearningObjectiveValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LearningObjectiveValidationError) ErrorName() string {
	return "LearningObjectiveValidationError"
}

// Error satisfies the builtin error interface
func (e LearningObjectiveValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLearningObjective.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LearningObjectiveValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LearningObjectiveValidationError{}

// Validate checks the field values on TopicLearningObjective with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TopicLearningObjective) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TopicLearningObjective with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TopicLearningObjectiveMultiError, or nil if none found.
func (m *TopicLearningObjective) ValidateAll() error {
	return m.validate(true)
}

func (m *TopicLearningObjective) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TopicId

	// no validation rules for LoId

	// no validation rules for DisplayOrder

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TopicLearningObjectiveValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TopicLearningObjectiveValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TopicLearningObjectiveValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TopicLearningObjectiveValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TopicLearningObjectiveValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TopicLearningObjectiveValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TopicLearningObjectiveMultiError(errors)
	}

	return nil
}

// TopicLearningObjectiveMultiError is an error wrapping multiple validation
// errors returned by TopicLearningObjective.ValidateAll() if the designated
// constraints aren't met.
type TopicLearningObjectiveMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopicLearningObjectiveMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopicLearningObjectiveMultiError) AllErrors() []error { return m }

// TopicLearningObjectiveValidationError is the validation error returned by
// TopicLearningObjective.Validate if the designated constraints aren't met.
type TopicLearningObjectiveValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopicLearningObjectiveValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopicLearningObjectiveValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopicLearningObjectiveValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopicLearningObjectiveValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopicLearningObjectiveValidationError) ErrorName() string {
	return "TopicLearningObjectiveValidationError"
}

// Error satisfies the builtin error interface
func (e TopicLearningObjectiveValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopicLearningObjective.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopicLearningObjectiveValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopicLearningObjectiveValidationError{}

// Validate checks the field values on QuizItemAttribute with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QuizItemAttribute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuizItemAttribute with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QuizItemAttributeMultiError, or nil if none found.
func (m *QuizItemAttribute) ValidateAll() error {
	return m.validate(true)
}

func (m *QuizItemAttribute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ImgLink

	// no validation rules for AudioLink

	if len(errors) > 0 {
		return QuizItemAttributeMultiError(errors)
	}

	return nil
}

// QuizItemAttributeMultiError is an error wrapping multiple validation errors
// returned by QuizItemAttribute.ValidateAll() if the designated constraints
// aren't met.
type QuizItemAttributeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuizItemAttributeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuizItemAttributeMultiError) AllErrors() []error { return m }

// QuizItemAttributeValidationError is the validation error returned by
// QuizItemAttribute.Validate if the designated constraints aren't met.
type QuizItemAttributeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuizItemAttributeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuizItemAttributeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuizItemAttributeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuizItemAttributeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuizItemAttributeValidationError) ErrorName() string {
	return "QuizItemAttributeValidationError"
}

// Error satisfies the builtin error interface
func (e QuizItemAttributeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuizItemAttribute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuizItemAttributeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuizItemAttributeValidationError{}

// Validate checks the field values on QuizCore with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuizCore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuizCore with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuizCoreMultiError, or nil
// if none found.
func (m *QuizCore) ValidateAll() error {
	return m.validate(true)
}

func (m *QuizCore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizCoreValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExternalId

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetQuestion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Question",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Question",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuestion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizCoreValidationError{
				field:  "Question",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExplanation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Explanation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Explanation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExplanation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizCoreValidationError{
				field:  "Explanation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DifficultyLevel

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuizCoreValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuizCoreValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuizCoreValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetAttribute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Attribute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Attribute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttribute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizCoreValidationError{
				field:  "Attribute",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizCoreValidationError{
				field:  "Point",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQuestionGroupId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "QuestionGroupId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizCoreValidationError{
					field:  "QuestionGroupId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuestionGroupId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizCoreValidationError{
				field:  "QuestionGroupId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.AnswerConfig.(type) {
	case *QuizCore_Essay:
		if v == nil {
			err := QuizCoreValidationError{
				field:  "AnswerConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEssay()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuizCoreValidationError{
						field:  "Essay",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuizCoreValidationError{
						field:  "Essay",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEssay()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuizCoreValidationError{
					field:  "Essay",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return QuizCoreMultiError(errors)
	}

	return nil
}

// QuizCoreMultiError is an error wrapping multiple validation errors returned
// by QuizCore.ValidateAll() if the designated constraints aren't met.
type QuizCoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuizCoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuizCoreMultiError) AllErrors() []error { return m }

// QuizCoreValidationError is the validation error returned by
// QuizCore.Validate if the designated constraints aren't met.
type QuizCoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuizCoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuizCoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuizCoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuizCoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuizCoreValidationError) ErrorName() string { return "QuizCoreValidationError" }

// Error satisfies the builtin error interface
func (e QuizCoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuizCore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuizCoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuizCoreValidationError{}

// Validate checks the field values on Quiz with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Quiz) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Quiz with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QuizMultiError, or nil if none found.
func (m *Quiz) ValidateAll() error {
	return m.validate(true)
}

func (m *Quiz) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizValidationError{
					field:  "Core",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizValidationError{
					field:  "Core",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizValidationError{
				field:  "Core",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LoId

	// no validation rules for QuestionUrl

	// no validation rules for ExplanationUrl

	// no validation rules for Status

	if len(errors) > 0 {
		return QuizMultiError(errors)
	}

	return nil
}

// QuizMultiError is an error wrapping multiple validation errors returned by
// Quiz.ValidateAll() if the designated constraints aren't met.
type QuizMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuizMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuizMultiError) AllErrors() []error { return m }

// QuizValidationError is the validation error returned by Quiz.Validate if the
// designated constraints aren't met.
type QuizValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuizValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuizValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuizValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuizValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuizValidationError) ErrorName() string { return "QuizValidationError" }

// Error satisfies the builtin error interface
func (e QuizValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuiz.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuizValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuizValidationError{}

// Validate checks the field values on RichText with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RichText) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RichText with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RichTextMultiError, or nil
// if none found.
func (m *RichText) ValidateAll() error {
	return m.validate(true)
}

func (m *RichText) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Raw

	// no validation rules for Rendered

	if len(errors) > 0 {
		return RichTextMultiError(errors)
	}

	return nil
}

// RichTextMultiError is an error wrapping multiple validation errors returned
// by RichText.ValidateAll() if the designated constraints aren't met.
type RichTextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RichTextMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RichTextMultiError) AllErrors() []error { return m }

// RichTextValidationError is the validation error returned by
// RichText.Validate if the designated constraints aren't met.
type RichTextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RichTextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RichTextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RichTextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RichTextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RichTextValidationError) ErrorName() string { return "RichTextValidationError" }

// Error satisfies the builtin error interface
func (e RichTextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRichText.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RichTextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RichTextValidationError{}

// Validate checks the field values on QuizOption with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuizOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuizOption with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuizOptionMultiError, or
// nil if none found.
func (m *QuizOption) ValidateAll() error {
	return m.validate(true)
}

func (m *QuizOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizOptionValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizOptionValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizOptionValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Correctness

	// no validation rules for Label

	// no validation rules for Key

	if all {
		switch v := interface{}(m.GetAttribute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizOptionValidationError{
					field:  "Attribute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizOptionValidationError{
					field:  "Attribute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttribute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizOptionValidationError{
				field:  "Attribute",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QuizOptionMultiError(errors)
	}

	return nil
}

// QuizOptionMultiError is an error wrapping multiple validation errors
// returned by QuizOption.ValidateAll() if the designated constraints aren't met.
type QuizOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuizOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuizOptionMultiError) AllErrors() []error { return m }

// QuizOptionValidationError is the validation error returned by
// QuizOption.Validate if the designated constraints aren't met.
type QuizOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuizOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuizOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuizOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuizOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuizOptionValidationError) ErrorName() string { return "QuizOptionValidationError" }

// Error satisfies the builtin error interface
func (e QuizOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuizOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuizOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuizOptionValidationError{}

// Validate checks the field values on OrderingResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderingResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderingResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderingResultMultiError,
// or nil if none found.
func (m *OrderingResult) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderingResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OrderingResultMultiError(errors)
	}

	return nil
}

// OrderingResultMultiError is an error wrapping multiple validation errors
// returned by OrderingResult.ValidateAll() if the designated constraints
// aren't met.
type OrderingResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderingResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderingResultMultiError) AllErrors() []error { return m }

// OrderingResultValidationError is the validation error returned by
// OrderingResult.Validate if the designated constraints aren't met.
type OrderingResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderingResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderingResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderingResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderingResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderingResultValidationError) ErrorName() string { return "OrderingResultValidationError" }

// Error satisfies the builtin error interface
func (e OrderingResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderingResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderingResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderingResultValidationError{}

// Validate checks the field values on AnswerLog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AnswerLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnswerLog with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnswerLogMultiError, or nil
// if none found.
func (m *AnswerLog) ValidateAll() error {
	return m.validate(true)
}

func (m *AnswerLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuizId

	// no validation rules for QuizType

	// no validation rules for IsAccepted

	if all {
		switch v := interface{}(m.GetCore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnswerLogValidationError{
					field:  "Core",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnswerLogValidationError{
					field:  "Core",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnswerLogValidationError{
				field:  "Core",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubmittedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnswerLogValidationError{
					field:  "SubmittedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnswerLogValidationError{
					field:  "SubmittedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmittedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnswerLogValidationError{
				field:  "SubmittedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Result.(type) {
	case *AnswerLog_OrderingResult:
		if v == nil {
			err := AnswerLogValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderingResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnswerLogValidationError{
						field:  "OrderingResult",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnswerLogValidationError{
						field:  "OrderingResult",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderingResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnswerLogValidationError{
					field:  "OrderingResult",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AnswerLogMultiError(errors)
	}

	return nil
}

// AnswerLogMultiError is an error wrapping multiple validation errors returned
// by AnswerLog.ValidateAll() if the designated constraints aren't met.
type AnswerLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnswerLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnswerLogMultiError) AllErrors() []error { return m }

// AnswerLogValidationError is the validation error returned by
// AnswerLog.Validate if the designated constraints aren't met.
type AnswerLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnswerLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnswerLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnswerLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnswerLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnswerLogValidationError) ErrorName() string { return "AnswerLogValidationError" }

// Error satisfies the builtin error interface
func (e AnswerLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnswerLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnswerLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnswerLogValidationError{}

// Validate checks the field values on QuizTestInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuizTestInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuizTestInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuizTestInfoMultiError, or
// nil if none found.
func (m *QuizTestInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *QuizTestInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SetId

	// no validation rules for TotalCorrectness

	// no validation rules for TotalQuiz

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizTestInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizTestInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizTestInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuizTestInfoValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuizTestInfoValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuizTestInfoValidationError{
				field:  "CompletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TotalLearningTime

	// no validation rules for IsRetry

	if len(errors) > 0 {
		return QuizTestInfoMultiError(errors)
	}

	return nil
}

// QuizTestInfoMultiError is an error wrapping multiple validation errors
// returned by QuizTestInfo.ValidateAll() if the designated constraints aren't met.
type QuizTestInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuizTestInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuizTestInfoMultiError) AllErrors() []error { return m }

// QuizTestInfoValidationError is the validation error returned by
// QuizTestInfo.Validate if the designated constraints aren't met.
type QuizTestInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuizTestInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuizTestInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuizTestInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuizTestInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuizTestInfoValidationError) ErrorName() string { return "QuizTestInfoValidationError" }

// Error satisfies the builtin error interface
func (e QuizTestInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuizTestInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuizTestInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuizTestInfoValidationError{}

// Validate checks the field values on HighestQuizScore with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HighestQuizScore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HighestQuizScore with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HighestQuizScoreMultiError, or nil if none found.
func (m *HighestQuizScore) ValidateAll() error {
	return m.validate(true)
}

func (m *HighestQuizScore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CorrectQuestion

	// no validation rules for TotalQuestion

	if len(errors) > 0 {
		return HighestQuizScoreMultiError(errors)
	}

	return nil
}

// HighestQuizScoreMultiError is an error wrapping multiple validation errors
// returned by HighestQuizScore.ValidateAll() if the designated constraints
// aren't met.
type HighestQuizScoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HighestQuizScoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HighestQuizScoreMultiError) AllErrors() []error { return m }

// HighestQuizScoreValidationError is the validation error returned by
// HighestQuizScore.Validate if the designated constraints aren't met.
type HighestQuizScoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HighestQuizScoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HighestQuizScoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HighestQuizScoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HighestQuizScoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HighestQuizScoreValidationError) ErrorName() string { return "HighestQuizScoreValidationError" }

// Error satisfies the builtin error interface
func (e HighestQuizScoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHighestQuizScore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HighestQuizScoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HighestQuizScoreValidationError{}

// Validate checks the field values on QuizTests with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuizTests) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuizTests with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuizTestsMultiError, or nil
// if none found.
func (m *QuizTests) ValidateAll() error {
	return m.validate(true)
}

func (m *QuizTests) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuizTestsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuizTestsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuizTestsValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QuizTestsMultiError(errors)
	}

	return nil
}

// QuizTestsMultiError is an error wrapping multiple validation errors returned
// by QuizTests.ValidateAll() if the designated constraints aren't met.
type QuizTestsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuizTestsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuizTestsMultiError) AllErrors() []error { return m }

// QuizTestsValidationError is the validation error returned by
// QuizTests.Validate if the designated constraints aren't met.
type QuizTestsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuizTestsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuizTestsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuizTestsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuizTestsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuizTestsValidationError) ErrorName() string { return "QuizTestsValidationError" }

// Error satisfies the builtin error interface
func (e QuizTestsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuizTests.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuizTestsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuizTestsValidationError{}

// Validate checks the field values on Attachment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Attachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Attachment with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AttachmentMultiError, or
// nil if none found.
func (m *Attachment) ValidateAll() error {
	return m.validate(true)
}

func (m *Attachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Url

	if len(errors) > 0 {
		return AttachmentMultiError(errors)
	}

	return nil
}

// AttachmentMultiError is an error wrapping multiple validation errors
// returned by Attachment.ValidateAll() if the designated constraints aren't met.
type AttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachmentMultiError) AllErrors() []error { return m }

// AttachmentValidationError is the validation error returned by
// Attachment.Validate if the designated constraints aren't met.
type AttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachmentValidationError) ErrorName() string { return "AttachmentValidationError" }

// Error satisfies the builtin error interface
func (e AttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachmentValidationError{}

// Validate checks the field values on Completenes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Completenes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Completenes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompletenesMultiError, or
// nil if none found.
func (m *Completenes) ValidateAll() error {
	return m.validate(true)
}

func (m *Completenes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QuizFinished

	// no validation rules for VideoFinished

	// no validation rules for StudyGuideFinished

	// no validation rules for FirstQuizCorrectness

	if len(errors) > 0 {
		return CompletenesMultiError(errors)
	}

	return nil
}

// CompletenesMultiError is an error wrapping multiple validation errors
// returned by Completenes.ValidateAll() if the designated constraints aren't met.
type CompletenesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompletenesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompletenesMultiError) AllErrors() []error { return m }

// CompletenesValidationError is the validation error returned by
// Completenes.Validate if the designated constraints aren't met.
type CompletenesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompletenesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompletenesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompletenesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompletenesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompletenesValidationError) ErrorName() string { return "CompletenesValidationError" }

// Error satisfies the builtin error interface
func (e CompletenesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompletenes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompletenesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompletenesValidationError{}

// Validate checks the field values on CourseAccessibility with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CourseAccessibility) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CourseAccessibility with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CourseAccessibilityMultiError, or nil if none found.
func (m *CourseAccessibility) ValidateAll() error {
	return m.validate(true)
}

func (m *CourseAccessibility) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanWatchVideo

	// no validation rules for CanViewStudyGuide

	// no validation rules for CanDoQuiz

	if len(errors) > 0 {
		return CourseAccessibilityMultiError(errors)
	}

	return nil
}

// CourseAccessibilityMultiError is an error wrapping multiple validation
// errors returned by CourseAccessibility.ValidateAll() if the designated
// constraints aren't met.
type CourseAccessibilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourseAccessibilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourseAccessibilityMultiError) AllErrors() []error { return m }

// CourseAccessibilityValidationError is the validation error returned by
// CourseAccessibility.Validate if the designated constraints aren't met.
type CourseAccessibilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourseAccessibilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourseAccessibilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourseAccessibilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourseAccessibilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourseAccessibilityValidationError) ErrorName() string {
	return "CourseAccessibilityValidationError"
}

// Error satisfies the builtin error interface
func (e CourseAccessibilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourseAccessibility.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourseAccessibilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourseAccessibilityValidationError{}

// Validate checks the field values on EssayConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EssayConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EssayConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EssayConfigMultiError, or
// nil if none found.
func (m *EssayConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EssayConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LimitEnabled

	// no validation rules for LimitType

	// no validation rules for Limit

	if len(errors) > 0 {
		return EssayConfigMultiError(errors)
	}

	return nil
}

// EssayConfigMultiError is an error wrapping multiple validation errors
// returned by EssayConfig.ValidateAll() if the designated constraints aren't met.
type EssayConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EssayConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EssayConfigMultiError) AllErrors() []error { return m }

// EssayConfigValidationError is the validation error returned by
// EssayConfig.Validate if the designated constraints aren't met.
type EssayConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EssayConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EssayConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EssayConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EssayConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EssayConfigValidationError) ErrorName() string { return "EssayConfigValidationError" }

// Error satisfies the builtin error interface
func (e EssayConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEssayConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EssayConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EssayConfigValidationError{}
