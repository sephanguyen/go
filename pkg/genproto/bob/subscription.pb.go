// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: subscription.proto

package pb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PromoType int32

const (
	PROMOTION            PromoType = 0
	PROMOTION_TEACHER    PromoType = 1
	PROMOTION_REFERRAL   PromoType = 2
	PROMOTION_LD         PromoType = 3
	PROMOTION_SC         PromoType = 4
	PROMOTION_KOL        PromoType = 5
	PROMOTION_ACTIVATION PromoType = 6
)

var PromoType_name = map[int32]string{
	0: "PROMOTION",
	1: "PROMOTION_TEACHER",
	2: "PROMOTION_REFERRAL",
	3: "PROMOTION_LD",
	4: "PROMOTION_SC",
	5: "PROMOTION_KOL",
	6: "PROMOTION_ACTIVATION",
}

var PromoType_value = map[string]int32{
	"PROMOTION":            0,
	"PROMOTION_TEACHER":    1,
	"PROMOTION_REFERRAL":   2,
	"PROMOTION_LD":         3,
	"PROMOTION_SC":         4,
	"PROMOTION_KOL":        5,
	"PROMOTION_ACTIVATION": 6,
}

func (PromoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{0}
}

type PromoDiscountType int32

const (
	PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT PromoDiscountType = 0
	PROMOTION_DISCOUNT_TYPE_PERCENTAGE   PromoDiscountType = 1
)

var PromoDiscountType_name = map[int32]string{
	0: "PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT",
	1: "PROMOTION_DISCOUNT_TYPE_PERCENTAGE",
}

var PromoDiscountType_value = map[string]int32{
	"PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT": 0,
	"PROMOTION_DISCOUNT_TYPE_PERCENTAGE":   1,
}

func (PromoDiscountType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{1}
}

type PromoStatus int32

const (
	PROMOTION_STATUS_PUBLISHED PromoStatus = 0
	PROMOTION_STATUS_ARCHIVED  PromoStatus = 1
)

var PromoStatus_name = map[int32]string{
	0: "PROMOTION_STATUS_PUBLISHED",
	1: "PROMOTION_STATUS_ARCHIVED",
}

var PromoStatus_value = map[string]int32{
	"PROMOTION_STATUS_PUBLISHED": 0,
	"PROMOTION_STATUS_ARCHIVED":  1,
}

func (PromoStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{2}
}

type Plan struct {
	Id              string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Description     string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	AdvertisedPrice string   `protobuf:"bytes,3,opt,name=advertised_price,json=advertisedPrice,proto3" json:"advertised_price,omitempty"` // Deprecated: Do not use.
	IsPurchasable   bool     `protobuf:"varint,4,opt,name=is_purchasable,json=isPurchasable,proto3" json:"is_purchasable,omitempty"`
	UpgradeableTo   []string `protobuf:"bytes,5,rep,name=upgradeable_to,json=upgradeableTo,proto3" json:"upgradeable_to,omitempty"` // Deprecated: Do not use.
	Benefits        []string `protobuf:"bytes,6,rep,name=benefits,proto3" json:"benefits,omitempty"`
	PrioritizeLevel int32    `protobuf:"varint,7,opt,name=prioritize_level,json=prioritizeLevel,proto3" json:"prioritize_level,omitempty"`
	IsHidden        bool     `protobuf:"varint,8,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"` // Deprecated: Do not use.
}

func (m *Plan) Reset()      { *m = Plan{} }
func (*Plan) ProtoMessage() {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{0}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.Size()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Plan) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Deprecated: Do not use.
func (m *Plan) GetAdvertisedPrice() string {
	if m != nil {
		return m.AdvertisedPrice
	}
	return ""
}

func (m *Plan) GetIsPurchasable() bool {
	if m != nil {
		return m.IsPurchasable
	}
	return false
}

// Deprecated: Do not use.
func (m *Plan) GetUpgradeableTo() []string {
	if m != nil {
		return m.UpgradeableTo
	}
	return nil
}

func (m *Plan) GetBenefits() []string {
	if m != nil {
		return m.Benefits
	}
	return nil
}

func (m *Plan) GetPrioritizeLevel() int32 {
	if m != nil {
		return m.PrioritizeLevel
	}
	return 0
}

// Deprecated: Do not use.
func (m *Plan) GetIsHidden() bool {
	if m != nil {
		return m.IsHidden
	}
	return false
}

type Package struct {
	Id                int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name              string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Price             int32            `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
	DiscountedPrice   int32            `protobuf:"varint,4,opt,name=discounted_price,json=discountedPrice,proto3" json:"discounted_price,omitempty"`
	Description       []string         `protobuf:"bytes,5,rep,name=description,proto3" json:"description,omitempty"`
	Notice            string           `protobuf:"bytes,6,opt,name=notice,proto3" json:"notice,omitempty"`
	Period            *types.Timestamp `protobuf:"bytes,7,opt,name=period,proto3" json:"period,omitempty"`
	IsRecommended     bool             `protobuf:"varint,8,opt,name=is_recommended,json=isRecommended,proto3" json:"is_recommended,omitempty"`
	IsEnabled         bool             `protobuf:"varint,9,opt,name=is_enabled,json=isEnabled,proto3" json:"is_enabled,omitempty"`
	IsHidden          bool             `protobuf:"varint,10,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"`                               // Deprecated: Do not use.
	CarriedOverAmount float64          `protobuf:"fixed64,11,opt,name=carried_over_amount,json=carriedOverAmount,proto3" json:"carried_over_amount,omitempty"` // Deprecated: Do not use.
	PlanId            string           `protobuf:"bytes,12,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`                                      // Deprecated: Do not use.
	Country           Country          `protobuf:"varint,13,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
	PrioritizeLevel   int32            `protobuf:"varint,14,opt,name=prioritize_level,json=prioritizeLevel,proto3" json:"prioritize_level,omitempty"`
	PackageItems      []*PackageItem   `protobuf:"bytes,15,rep,name=package_items,json=packageItems,proto3" json:"package_items,omitempty"`
	IosBundleId       string           `protobuf:"bytes,16,opt,name=ios_bundle_id,json=iosBundleId,proto3" json:"ios_bundle_id,omitempty"`
}

func (m *Package) Reset()      { *m = Package{} }
func (*Package) ProtoMessage() {}
func (*Package) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{1}
}
func (m *Package) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Package) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Package.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Package) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Package.Merge(m, src)
}
func (m *Package) XXX_Size() int {
	return m.Size()
}
func (m *Package) XXX_DiscardUnknown() {
	xxx_messageInfo_Package.DiscardUnknown(m)
}

var xxx_messageInfo_Package proto.InternalMessageInfo

func (m *Package) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Package) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Package) GetDiscountedPrice() int32 {
	if m != nil {
		return m.DiscountedPrice
	}
	return 0
}

func (m *Package) GetDescription() []string {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *Package) GetNotice() string {
	if m != nil {
		return m.Notice
	}
	return ""
}

func (m *Package) GetPeriod() *types.Timestamp {
	if m != nil {
		return m.Period
	}
	return nil
}

func (m *Package) GetIsRecommended() bool {
	if m != nil {
		return m.IsRecommended
	}
	return false
}

func (m *Package) GetIsEnabled() bool {
	if m != nil {
		return m.IsEnabled
	}
	return false
}

// Deprecated: Do not use.
func (m *Package) GetIsHidden() bool {
	if m != nil {
		return m.IsHidden
	}
	return false
}

// Deprecated: Do not use.
func (m *Package) GetCarriedOverAmount() float64 {
	if m != nil {
		return m.CarriedOverAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *Package) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *Package) GetCountry() Country {
	if m != nil {
		return m.Country
	}
	return COUNTRY_NONE
}

func (m *Package) GetPrioritizeLevel() int32 {
	if m != nil {
		return m.PrioritizeLevel
	}
	return 0
}

func (m *Package) GetPackageItems() []*PackageItem {
	if m != nil {
		return m.PackageItems
	}
	return nil
}

func (m *Package) GetIosBundleId() string {
	if m != nil {
		return m.IosBundleId
	}
	return ""
}

type PackageItem struct {
	Id        string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PackageId int32            `protobuf:"varint,2,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	PlanId    string           `protobuf:"bytes,3,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	ExpiredAt *types.Timestamp `protobuf:"bytes,4,opt,name=expired_at,json=expiredAt,proto3" json:"expired_at,omitempty"`
	Duration  int32            `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
	Subject   []Subject        `protobuf:"varint,6,rep,packed,name=subject,proto3,enum=manabie.bob.Subject" json:"subject,omitempty"`
	Grades    []int32          `protobuf:"varint,7,rep,packed,name=grades,proto3" json:"grades,omitempty"`
}

func (m *PackageItem) Reset()      { *m = PackageItem{} }
func (*PackageItem) ProtoMessage() {}
func (*PackageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{2}
}
func (m *PackageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackageItem.Merge(m, src)
}
func (m *PackageItem) XXX_Size() int {
	return m.Size()
}
func (m *PackageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PackageItem.DiscardUnknown(m)
}

var xxx_messageInfo_PackageItem proto.InternalMessageInfo

func (m *PackageItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PackageItem) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *PackageItem) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *PackageItem) GetExpiredAt() *types.Timestamp {
	if m != nil {
		return m.ExpiredAt
	}
	return nil
}

func (m *PackageItem) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *PackageItem) GetSubject() []Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *PackageItem) GetGrades() []int32 {
	if m != nil {
		return m.Grades
	}
	return nil
}

type CodOrderInfo struct {
	CustomerName         string           `protobuf:"bytes,1,opt,name=customer_name,json=customerName,proto3" json:"customer_name,omitempty"`
	CustomerPhoneNumber  string           `protobuf:"bytes,2,opt,name=customer_phone_number,json=customerPhoneNumber,proto3" json:"customer_phone_number,omitempty"`
	CustomerAddress      string           `protobuf:"bytes,3,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address,omitempty"`
	ExpectedDeliveryTime *types.Timestamp `protobuf:"bytes,4,opt,name=expected_delivery_time,json=expectedDeliveryTime,proto3" json:"expected_delivery_time,omitempty"`
	Status               CodOrderStatus   `protobuf:"varint,5,opt,name=status,proto3,enum=manabie.bob.CodOrderStatus" json:"status,omitempty"`
}

func (m *CodOrderInfo) Reset()      { *m = CodOrderInfo{} }
func (*CodOrderInfo) ProtoMessage() {}
func (*CodOrderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{3}
}
func (m *CodOrderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodOrderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodOrderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodOrderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodOrderInfo.Merge(m, src)
}
func (m *CodOrderInfo) XXX_Size() int {
	return m.Size()
}
func (m *CodOrderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CodOrderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CodOrderInfo proto.InternalMessageInfo

func (m *CodOrderInfo) GetCustomerName() string {
	if m != nil {
		return m.CustomerName
	}
	return ""
}

func (m *CodOrderInfo) GetCustomerPhoneNumber() string {
	if m != nil {
		return m.CustomerPhoneNumber
	}
	return ""
}

func (m *CodOrderInfo) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

func (m *CodOrderInfo) GetExpectedDeliveryTime() *types.Timestamp {
	if m != nil {
		return m.ExpectedDeliveryTime
	}
	return nil
}

func (m *CodOrderInfo) GetStatus() CodOrderStatus {
	if m != nil {
		return m.Status
	}
	return COD_ORDER_STATUS_NONE
}

type StudentSubscription struct {
	PlanId   string             `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	Grades   []int32            `protobuf:"varint,2,rep,packed,name=grades,proto3" json:"grades,omitempty"`
	Subjects []Subject          `protobuf:"varint,3,rep,packed,name=subjects,proto3,enum=manabie.bob.Subject" json:"subjects,omitempty"`
	Start    *types.Timestamp   `protobuf:"bytes,4,opt,name=start,proto3" json:"start,omitempty"`
	End      *types.Timestamp   `protobuf:"bytes,5,opt,name=end,proto3" json:"end,omitempty"`
	Status   SubscriptionStatus `protobuf:"varint,6,opt,name=status,proto3,enum=manabie.bob.SubscriptionStatus" json:"status,omitempty"`
}

func (m *StudentSubscription) Reset()      { *m = StudentSubscription{} }
func (*StudentSubscription) ProtoMessage() {}
func (*StudentSubscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{4}
}
func (m *StudentSubscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudentSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StudentSubscription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StudentSubscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudentSubscription.Merge(m, src)
}
func (m *StudentSubscription) XXX_Size() int {
	return m.Size()
}
func (m *StudentSubscription) XXX_DiscardUnknown() {
	xxx_messageInfo_StudentSubscription.DiscardUnknown(m)
}

var xxx_messageInfo_StudentSubscription proto.InternalMessageInfo

func (m *StudentSubscription) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *StudentSubscription) GetGrades() []int32 {
	if m != nil {
		return m.Grades
	}
	return nil
}

func (m *StudentSubscription) GetSubjects() []Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *StudentSubscription) GetStart() *types.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *StudentSubscription) GetEnd() *types.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *StudentSubscription) GetStatus() SubscriptionStatus {
	if m != nil {
		return m.Status
	}
	return SUBSCRIPTION_STATUS_NONE
}

type Order struct {
	Id                int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Amount            float64                `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount,omitempty"`
	PlanId            string                 `protobuf:"bytes,3,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`       // Deprecated: Do not use.
	PlanName          string                 `protobuf:"bytes,4,opt,name=plan_name,json=planName,proto3" json:"plan_name,omitempty"` // Deprecated: Do not use.
	ManualCreatedBy   string                 `protobuf:"bytes,5,opt,name=manual_created_by,json=manualCreatedBy,proto3" json:"manual_created_by,omitempty"`
	Status            OrderStatus            `protobuf:"varint,6,opt,name=status,proto3,enum=manabie.bob.OrderStatus" json:"status,omitempty"`
	Coupon            string                 `protobuf:"bytes,7,opt,name=coupon,proto3" json:"coupon,omitempty"`
	CouponAmount      float64                `protobuf:"fixed64,8,opt,name=coupon_amount,json=couponAmount,proto3" json:"coupon_amount,omitempty"`
	CarriedOverAmount float64                `protobuf:"fixed64,9,opt,name=carried_over_amount,json=carriedOverAmount,proto3" json:"carried_over_amount,omitempty"` // Deprecated: Do not use.
	CarriedOverFrom   int32                  `protobuf:"varint,10,opt,name=carried_over_from,json=carriedOverFrom,proto3" json:"carried_over_from,omitempty"`       // Deprecated: Do not use.
	Start             *types.Timestamp       `protobuf:"bytes,11,opt,name=start,proto3" json:"start,omitempty"`                                                     // Deprecated: Do not use.
	End               *types.Timestamp       `protobuf:"bytes,12,opt,name=end,proto3" json:"end,omitempty"`                                                         // Deprecated: Do not use.
	UpdatedAt         *types.Timestamp       `protobuf:"bytes,13,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	CreatedAt         *types.Timestamp       `protobuf:"bytes,14,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Currency          string                 `protobuf:"bytes,15,opt,name=currency,proto3" json:"currency,omitempty"`
	PaymentMethod     string                 `protobuf:"bytes,16,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
	PaymentLink       string                 `protobuf:"bytes,17,opt,name=payment_link,json=paymentLink,proto3" json:"payment_link,omitempty"`
	PackageId         int32                  `protobuf:"varint,18,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	PackageName       string                 `protobuf:"bytes,19,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	Country           Country                `protobuf:"varint,20,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
	StudentId         string                 `protobuf:"bytes,21,opt,name=student_id,json=studentId,proto3" json:"student_id,omitempty"`
	ReferenceNumber   string                 `protobuf:"bytes,22,opt,name=reference_number,json=referenceNumber,proto3" json:"reference_number,omitempty"`
	CodOrderInfo      *CodOrderInfo          `protobuf:"bytes,23,opt,name=cod_order_info,json=codOrderInfo,proto3" json:"cod_order_info,omitempty"`
	MustPayBefore     *types.Timestamp       `protobuf:"bytes,24,opt,name=must_pay_before,json=mustPayBefore,proto3" json:"must_pay_before,omitempty"`
	Subscriptions     []*StudentSubscription `protobuf:"bytes,25,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{5}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Order) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// Deprecated: Do not use.
func (m *Order) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

// Deprecated: Do not use.
func (m *Order) GetPlanName() string {
	if m != nil {
		return m.PlanName
	}
	return ""
}

func (m *Order) GetManualCreatedBy() string {
	if m != nil {
		return m.ManualCreatedBy
	}
	return ""
}

func (m *Order) GetStatus() OrderStatus {
	if m != nil {
		return m.Status
	}
	return ORDER_STATUS_NONE
}

func (m *Order) GetCoupon() string {
	if m != nil {
		return m.Coupon
	}
	return ""
}

func (m *Order) GetCouponAmount() float64 {
	if m != nil {
		return m.CouponAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *Order) GetCarriedOverAmount() float64 {
	if m != nil {
		return m.CarriedOverAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *Order) GetCarriedOverFrom() int32 {
	if m != nil {
		return m.CarriedOverFrom
	}
	return 0
}

// Deprecated: Do not use.
func (m *Order) GetStart() *types.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

// Deprecated: Do not use.
func (m *Order) GetEnd() *types.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Order) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *Order) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Order) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Order) GetPaymentMethod() string {
	if m != nil {
		return m.PaymentMethod
	}
	return ""
}

func (m *Order) GetPaymentLink() string {
	if m != nil {
		return m.PaymentLink
	}
	return ""
}

func (m *Order) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *Order) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *Order) GetCountry() Country {
	if m != nil {
		return m.Country
	}
	return COUNTRY_NONE
}

func (m *Order) GetStudentId() string {
	if m != nil {
		return m.StudentId
	}
	return ""
}

func (m *Order) GetReferenceNumber() string {
	if m != nil {
		return m.ReferenceNumber
	}
	return ""
}

func (m *Order) GetCodOrderInfo() *CodOrderInfo {
	if m != nil {
		return m.CodOrderInfo
	}
	return nil
}

func (m *Order) GetMustPayBefore() *types.Timestamp {
	if m != nil {
		return m.MustPayBefore
	}
	return nil
}

func (m *Order) GetSubscriptions() []*StudentSubscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

type UpdateAsiaPayOrderRequest struct {
	OrderId       int32  `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	ResponseCode  int32  `protobuf:"varint,2,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	FullResponse  string `protobuf:"bytes,3,opt,name=full_response,json=fullResponse,proto3" json:"full_response,omitempty"`
	PaymentMethod string `protobuf:"bytes,4,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
}

func (m *UpdateAsiaPayOrderRequest) Reset()      { *m = UpdateAsiaPayOrderRequest{} }
func (*UpdateAsiaPayOrderRequest) ProtoMessage() {}
func (*UpdateAsiaPayOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{6}
}
func (m *UpdateAsiaPayOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateAsiaPayOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateAsiaPayOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateAsiaPayOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateAsiaPayOrderRequest.Merge(m, src)
}
func (m *UpdateAsiaPayOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateAsiaPayOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateAsiaPayOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateAsiaPayOrderRequest proto.InternalMessageInfo

func (m *UpdateAsiaPayOrderRequest) GetOrderId() int32 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *UpdateAsiaPayOrderRequest) GetResponseCode() int32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *UpdateAsiaPayOrderRequest) GetFullResponse() string {
	if m != nil {
		return m.FullResponse
	}
	return ""
}

func (m *UpdateAsiaPayOrderRequest) GetPaymentMethod() string {
	if m != nil {
		return m.PaymentMethod
	}
	return ""
}

type UpdateAsiaPayOrderResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *UpdateAsiaPayOrderResponse) Reset()      { *m = UpdateAsiaPayOrderResponse{} }
func (*UpdateAsiaPayOrderResponse) ProtoMessage() {}
func (*UpdateAsiaPayOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{7}
}
func (m *UpdateAsiaPayOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateAsiaPayOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateAsiaPayOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateAsiaPayOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateAsiaPayOrderResponse.Merge(m, src)
}
func (m *UpdateAsiaPayOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateAsiaPayOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateAsiaPayOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateAsiaPayOrderResponse proto.InternalMessageInfo

func (m *UpdateAsiaPayOrderResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type Promotion struct {
	PromoType              PromoType         `protobuf:"varint,1,opt,name=promo_type,json=promoType,proto3,enum=manabie.bob.PromoType" json:"promo_type,omitempty"`
	Country                Country           `protobuf:"varint,2,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
	CodePrefix             string            `protobuf:"bytes,3,opt,name=code_prefix,json=codePrefix,proto3" json:"code_prefix,omitempty"`
	Code                   string            `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	DiscountType           PromoDiscountType `protobuf:"varint,5,opt,name=discount_type,json=discountType,proto3,enum=manabie.bob.PromoDiscountType" json:"discount_type,omitempty"`
	DiscountAmount         float64           `protobuf:"fixed64,6,opt,name=discount_amount,json=discountAmount,proto3" json:"discount_amount,omitempty"`
	Status                 PromoStatus       `protobuf:"varint,7,opt,name=status,proto3,enum=manabie.bob.PromoStatus" json:"status,omitempty"`
	StartedDate            *types.Timestamp  `protobuf:"bytes,8,opt,name=started_date,json=startedDate,proto3" json:"started_date,omitempty"`
	ExpiredDate            *types.Timestamp  `protobuf:"bytes,9,opt,name=expired_date,json=expiredDate,proto3" json:"expired_date,omitempty"`
	RedemptionLimitPerCode int32             `protobuf:"varint,10,opt,name=redemption_limit_per_code,json=redemptionLimitPerCode,proto3" json:"redemption_limit_per_code,omitempty"`
	RedemptionLimitPerUser int32             `protobuf:"varint,11,opt,name=redemption_limit_per_user,json=redemptionLimitPerUser,proto3" json:"redemption_limit_per_user,omitempty"`
	Notes                  string            `protobuf:"bytes,12,opt,name=notes,proto3" json:"notes,omitempty"`
	Rules                  []*PromotionRule  `protobuf:"bytes,13,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *Promotion) Reset()      { *m = Promotion{} }
func (*Promotion) ProtoMessage() {}
func (*Promotion) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{8}
}
func (m *Promotion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Promotion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Promotion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Promotion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Promotion.Merge(m, src)
}
func (m *Promotion) XXX_Size() int {
	return m.Size()
}
func (m *Promotion) XXX_DiscardUnknown() {
	xxx_messageInfo_Promotion.DiscardUnknown(m)
}

var xxx_messageInfo_Promotion proto.InternalMessageInfo

func (m *Promotion) GetPromoType() PromoType {
	if m != nil {
		return m.PromoType
	}
	return PROMOTION
}

func (m *Promotion) GetCountry() Country {
	if m != nil {
		return m.Country
	}
	return COUNTRY_NONE
}

func (m *Promotion) GetCodePrefix() string {
	if m != nil {
		return m.CodePrefix
	}
	return ""
}

func (m *Promotion) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Promotion) GetDiscountType() PromoDiscountType {
	if m != nil {
		return m.DiscountType
	}
	return PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT
}

func (m *Promotion) GetDiscountAmount() float64 {
	if m != nil {
		return m.DiscountAmount
	}
	return 0
}

func (m *Promotion) GetStatus() PromoStatus {
	if m != nil {
		return m.Status
	}
	return PROMOTION_STATUS_PUBLISHED
}

func (m *Promotion) GetStartedDate() *types.Timestamp {
	if m != nil {
		return m.StartedDate
	}
	return nil
}

func (m *Promotion) GetExpiredDate() *types.Timestamp {
	if m != nil {
		return m.ExpiredDate
	}
	return nil
}

func (m *Promotion) GetRedemptionLimitPerCode() int32 {
	if m != nil {
		return m.RedemptionLimitPerCode
	}
	return 0
}

func (m *Promotion) GetRedemptionLimitPerUser() int32 {
	if m != nil {
		return m.RedemptionLimitPerUser
	}
	return 0
}

func (m *Promotion) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *Promotion) GetRules() []*PromotionRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type PromotionRule struct {
	PromoType      PromoType         `protobuf:"varint,1,opt,name=promo_type,json=promoType,proto3,enum=manabie.bob.PromoType" json:"promo_type,omitempty"`
	DiscountType   PromoDiscountType `protobuf:"varint,2,opt,name=discount_type,json=discountType,proto3,enum=manabie.bob.PromoDiscountType" json:"discount_type,omitempty"`
	DiscountAmount float64           `protobuf:"fixed64,3,opt,name=discount_amount,json=discountAmount,proto3" json:"discount_amount,omitempty"`
	Conditions     *types.Struct     `protobuf:"bytes,4,opt,name=conditions,proto3" json:"conditions,omitempty"`
	Rewards        *types.Struct     `protobuf:"bytes,5,opt,name=rewards,proto3" json:"rewards,omitempty"`
}

func (m *PromotionRule) Reset()      { *m = PromotionRule{} }
func (*PromotionRule) ProtoMessage() {}
func (*PromotionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{9}
}
func (m *PromotionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PromotionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PromotionRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PromotionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PromotionRule.Merge(m, src)
}
func (m *PromotionRule) XXX_Size() int {
	return m.Size()
}
func (m *PromotionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PromotionRule.DiscardUnknown(m)
}

var xxx_messageInfo_PromotionRule proto.InternalMessageInfo

func (m *PromotionRule) GetPromoType() PromoType {
	if m != nil {
		return m.PromoType
	}
	return PROMOTION
}

func (m *PromotionRule) GetDiscountType() PromoDiscountType {
	if m != nil {
		return m.DiscountType
	}
	return PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT
}

func (m *PromotionRule) GetDiscountAmount() float64 {
	if m != nil {
		return m.DiscountAmount
	}
	return 0
}

func (m *PromotionRule) GetConditions() *types.Struct {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *PromotionRule) GetRewards() *types.Struct {
	if m != nil {
		return m.Rewards
	}
	return nil
}

type UpdateGHNOrderRequest struct {
	GhnOrderId string                   `protobuf:"bytes,1,opt,name=ghn_order_id,json=ghnOrderId,proto3" json:"ghn_order_id,omitempty"`
	Action     CodOrderTransitionAction `protobuf:"varint,2,opt,name=action,proto3,enum=manabie.bob.CodOrderTransitionAction" json:"action,omitempty"`
}

func (m *UpdateGHNOrderRequest) Reset()      { *m = UpdateGHNOrderRequest{} }
func (*UpdateGHNOrderRequest) ProtoMessage() {}
func (*UpdateGHNOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{10}
}
func (m *UpdateGHNOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGHNOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGHNOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGHNOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGHNOrderRequest.Merge(m, src)
}
func (m *UpdateGHNOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGHNOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGHNOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGHNOrderRequest proto.InternalMessageInfo

func (m *UpdateGHNOrderRequest) GetGhnOrderId() string {
	if m != nil {
		return m.GhnOrderId
	}
	return ""
}

func (m *UpdateGHNOrderRequest) GetAction() CodOrderTransitionAction {
	if m != nil {
		return m.Action
	}
	return COD_ORDER_TRANSITION_NONE
}

type UpdateGHNOrderResponse struct {
}

func (m *UpdateGHNOrderResponse) Reset()      { *m = UpdateGHNOrderResponse{} }
func (*UpdateGHNOrderResponse) ProtoMessage() {}
func (*UpdateGHNOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{11}
}
func (m *UpdateGHNOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGHNOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGHNOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGHNOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGHNOrderResponse.Merge(m, src)
}
func (m *UpdateGHNOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGHNOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGHNOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGHNOrderResponse proto.InternalMessageInfo

type GetAdvertisePackageRequest struct {
}

func (m *GetAdvertisePackageRequest) Reset()      { *m = GetAdvertisePackageRequest{} }
func (*GetAdvertisePackageRequest) ProtoMessage() {}
func (*GetAdvertisePackageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{12}
}
func (m *GetAdvertisePackageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAdvertisePackageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdvertisePackageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAdvertisePackageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdvertisePackageRequest.Merge(m, src)
}
func (m *GetAdvertisePackageRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAdvertisePackageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdvertisePackageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdvertisePackageRequest proto.InternalMessageInfo

type GetAdvertisePackageResponse struct {
	Packages []*GetAdvertisePackageResponse_AdvertisePackage `protobuf:"bytes,1,rep,name=packages,proto3" json:"packages,omitempty"`
}

func (m *GetAdvertisePackageResponse) Reset()      { *m = GetAdvertisePackageResponse{} }
func (*GetAdvertisePackageResponse) ProtoMessage() {}
func (*GetAdvertisePackageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{13}
}
func (m *GetAdvertisePackageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAdvertisePackageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdvertisePackageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAdvertisePackageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdvertisePackageResponse.Merge(m, src)
}
func (m *GetAdvertisePackageResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAdvertisePackageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdvertisePackageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdvertisePackageResponse proto.InternalMessageInfo

func (m *GetAdvertisePackageResponse) GetPackages() []*GetAdvertisePackageResponse_AdvertisePackage {
	if m != nil {
		return m.Packages
	}
	return nil
}

type GetAdvertisePackageResponse_AdvertisePackageItem struct {
	PackageId     int32  `protobuf:"varint,1,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	PlanId        string `protobuf:"bytes,2,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	PackageItemId string `protobuf:"bytes,3,opt,name=package_item_id,json=packageItemId,proto3" json:"package_item_id,omitempty"`
}

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) Reset() {
	*m = GetAdvertisePackageResponse_AdvertisePackageItem{}
}
func (*GetAdvertisePackageResponse_AdvertisePackageItem) ProtoMessage() {}
func (*GetAdvertisePackageResponse_AdvertisePackageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{13, 0}
}
func (m *GetAdvertisePackageResponse_AdvertisePackageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAdvertisePackageResponse_AdvertisePackageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAdvertisePackageResponse_AdvertisePackageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackageItem.Merge(m, src)
}
func (m *GetAdvertisePackageResponse_AdvertisePackageItem) XXX_Size() int {
	return m.Size()
}
func (m *GetAdvertisePackageResponse_AdvertisePackageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackageItem.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackageItem proto.InternalMessageInfo

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) GetPackageItemId() string {
	if m != nil {
		return m.PackageItemId
	}
	return ""
}

type GetAdvertisePackageResponse_AdvertisePackage struct {
	PackageId       int32                                               `protobuf:"varint,1,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	Name            string                                              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Price           int32                                               `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
	Description     []string                                            `protobuf:"bytes,4,rep,name=description,proto3" json:"description,omitempty"`
	Country         Country                                             `protobuf:"varint,5,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
	PrioritizeLevel int32                                               `protobuf:"varint,6,opt,name=prioritize_level,json=prioritizeLevel,proto3" json:"prioritize_level,omitempty"`
	PackageItems    []*GetAdvertisePackageResponse_AdvertisePackageItem `protobuf:"bytes,7,rep,name=package_items,json=packageItems,proto3" json:"package_items,omitempty"`
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) Reset() {
	*m = GetAdvertisePackageResponse_AdvertisePackage{}
}
func (*GetAdvertisePackageResponse_AdvertisePackage) ProtoMessage() {}
func (*GetAdvertisePackageResponse_AdvertisePackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4f8ad1a64b2bad6, []int{13, 1}
}
func (m *GetAdvertisePackageResponse_AdvertisePackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAdvertisePackageResponse_AdvertisePackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAdvertisePackageResponse_AdvertisePackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackage.Merge(m, src)
}
func (m *GetAdvertisePackageResponse_AdvertisePackage) XXX_Size() int {
	return m.Size()
}
func (m *GetAdvertisePackageResponse_AdvertisePackage) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackage.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdvertisePackageResponse_AdvertisePackage proto.InternalMessageInfo

func (m *GetAdvertisePackageResponse_AdvertisePackage) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) GetDescription() []string {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) GetCountry() Country {
	if m != nil {
		return m.Country
	}
	return COUNTRY_NONE
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) GetPrioritizeLevel() int32 {
	if m != nil {
		return m.PrioritizeLevel
	}
	return 0
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) GetPackageItems() []*GetAdvertisePackageResponse_AdvertisePackageItem {
	if m != nil {
		return m.PackageItems
	}
	return nil
}

func init() {
	proto.RegisterEnum("manabie.bob.PromoType", PromoType_name, PromoType_value)
	golang_proto.RegisterEnum("manabie.bob.PromoType", PromoType_name, PromoType_value)
	proto.RegisterEnum("manabie.bob.PromoDiscountType", PromoDiscountType_name, PromoDiscountType_value)
	golang_proto.RegisterEnum("manabie.bob.PromoDiscountType", PromoDiscountType_name, PromoDiscountType_value)
	proto.RegisterEnum("manabie.bob.PromoStatus", PromoStatus_name, PromoStatus_value)
	golang_proto.RegisterEnum("manabie.bob.PromoStatus", PromoStatus_name, PromoStatus_value)
	proto.RegisterType((*Plan)(nil), "manabie.bob.Plan")
	golang_proto.RegisterType((*Plan)(nil), "manabie.bob.Plan")
	proto.RegisterType((*Package)(nil), "manabie.bob.Package")
	golang_proto.RegisterType((*Package)(nil), "manabie.bob.Package")
	proto.RegisterType((*PackageItem)(nil), "manabie.bob.PackageItem")
	golang_proto.RegisterType((*PackageItem)(nil), "manabie.bob.PackageItem")
	proto.RegisterType((*CodOrderInfo)(nil), "manabie.bob.CodOrderInfo")
	golang_proto.RegisterType((*CodOrderInfo)(nil), "manabie.bob.CodOrderInfo")
	proto.RegisterType((*StudentSubscription)(nil), "manabie.bob.StudentSubscription")
	golang_proto.RegisterType((*StudentSubscription)(nil), "manabie.bob.StudentSubscription")
	proto.RegisterType((*Order)(nil), "manabie.bob.Order")
	golang_proto.RegisterType((*Order)(nil), "manabie.bob.Order")
	proto.RegisterType((*UpdateAsiaPayOrderRequest)(nil), "manabie.bob.UpdateAsiaPayOrderRequest")
	golang_proto.RegisterType((*UpdateAsiaPayOrderRequest)(nil), "manabie.bob.UpdateAsiaPayOrderRequest")
	proto.RegisterType((*UpdateAsiaPayOrderResponse)(nil), "manabie.bob.UpdateAsiaPayOrderResponse")
	golang_proto.RegisterType((*UpdateAsiaPayOrderResponse)(nil), "manabie.bob.UpdateAsiaPayOrderResponse")
	proto.RegisterType((*Promotion)(nil), "manabie.bob.Promotion")
	golang_proto.RegisterType((*Promotion)(nil), "manabie.bob.Promotion")
	proto.RegisterType((*PromotionRule)(nil), "manabie.bob.PromotionRule")
	golang_proto.RegisterType((*PromotionRule)(nil), "manabie.bob.PromotionRule")
	proto.RegisterType((*UpdateGHNOrderRequest)(nil), "manabie.bob.UpdateGHNOrderRequest")
	golang_proto.RegisterType((*UpdateGHNOrderRequest)(nil), "manabie.bob.UpdateGHNOrderRequest")
	proto.RegisterType((*UpdateGHNOrderResponse)(nil), "manabie.bob.UpdateGHNOrderResponse")
	golang_proto.RegisterType((*UpdateGHNOrderResponse)(nil), "manabie.bob.UpdateGHNOrderResponse")
	proto.RegisterType((*GetAdvertisePackageRequest)(nil), "manabie.bob.GetAdvertisePackageRequest")
	golang_proto.RegisterType((*GetAdvertisePackageRequest)(nil), "manabie.bob.GetAdvertisePackageRequest")
	proto.RegisterType((*GetAdvertisePackageResponse)(nil), "manabie.bob.GetAdvertisePackageResponse")
	golang_proto.RegisterType((*GetAdvertisePackageResponse)(nil), "manabie.bob.GetAdvertisePackageResponse")
	proto.RegisterType((*GetAdvertisePackageResponse_AdvertisePackageItem)(nil), "manabie.bob.GetAdvertisePackageResponse.AdvertisePackageItem")
	golang_proto.RegisterType((*GetAdvertisePackageResponse_AdvertisePackageItem)(nil), "manabie.bob.GetAdvertisePackageResponse.AdvertisePackageItem")
	proto.RegisterType((*GetAdvertisePackageResponse_AdvertisePackage)(nil), "manabie.bob.GetAdvertisePackageResponse.AdvertisePackage")
	golang_proto.RegisterType((*GetAdvertisePackageResponse_AdvertisePackage)(nil), "manabie.bob.GetAdvertisePackageResponse.AdvertisePackage")
}

func init() { proto.RegisterFile("subscription.proto", fileDescriptor_c4f8ad1a64b2bad6) }
func init() { golang_proto.RegisterFile("subscription.proto", fileDescriptor_c4f8ad1a64b2bad6) }

var fileDescriptor_c4f8ad1a64b2bad6 = []byte{
	// 2133 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x73, 0x1b, 0x49,
	0x15, 0xf7, 0xc8, 0x96, 0x2c, 0x3d, 0x4b, 0xb2, 0xdc, 0x71, 0x9c, 0xb1, 0xb2, 0x51, 0x84, 0x96,
	0x4d, 0xbc, 0x29, 0xa2, 0x04, 0x2d, 0xd4, 0x56, 0x0a, 0x52, 0x94, 0x2c, 0x2b, 0x89, 0x0a, 0xc7,
	0x56, 0x8d, 0xe5, 0x2d, 0xe0, 0xc0, 0xd4, 0x68, 0xa6, 0x2d, 0xcf, 0x5a, 0xf3, 0x41, 0xf7, 0x8c,
	0x89, 0x38, 0x51, 0xc5, 0x85, 0x23, 0x1c, 0xe1, 0x04, 0x27, 0xa8, 0xe2, 0x2f, 0xa0, 0x8a, 0x03,
	0x47, 0x8e, 0x29, 0x4e, 0x7b, 0x24, 0xce, 0x85, 0xe3, 0x1e, 0xf8, 0x03, 0xa8, 0x7e, 0xd3, 0x23,
	0x8d, 0x3e, 0xfc, 0x51, 0xa9, 0xbd, 0xe9, 0xfd, 0xde, 0x7b, 0xd3, 0xdd, 0xaf, 0x7f, 0xfd, 0xeb,
	0x7e, 0x02, 0xc2, 0xc3, 0x3e, 0x37, 0x99, 0xed, 0x07, 0xb6, 0xe7, 0xd6, 0x7d, 0xe6, 0x05, 0x1e,
	0x59, 0x73, 0x0c, 0xd7, 0xe8, 0xdb, 0xb4, 0xde, 0xf7, 0xfa, 0x65, 0xa0, 0x6e, 0xe8, 0x44, 0x8e,
	0xf2, 0x47, 0x03, 0xcf, 0x1b, 0x0c, 0xe9, 0x13, 0xb4, 0xfa, 0xe1, 0xc9, 0x13, 0x1e, 0xb0, 0xd0,
	0x0c, 0xa4, 0xf7, 0xfe, 0xac, 0x37, 0xb0, 0x1d, 0xca, 0x03, 0xc3, 0xf1, 0x65, 0xc0, 0xe3, 0x81,
	0x1d, 0x9c, 0x86, 0xfd, 0xba, 0xe9, 0x39, 0x4f, 0x06, 0xde, 0xc0, 0x9b, 0x44, 0x0a, 0x0b, 0x0d,
	0xfc, 0x15, 0x85, 0xd7, 0xfe, 0x9c, 0x82, 0x95, 0xee, 0xd0, 0x70, 0x49, 0x11, 0x52, 0xb6, 0xa5,
	0x2a, 0x55, 0x65, 0x27, 0xa7, 0xa5, 0x6c, 0x8b, 0x54, 0x61, 0xcd, 0xa2, 0xe3, 0x49, 0xab, 0x29,
	0x74, 0x24, 0x21, 0xf2, 0x18, 0x4a, 0x86, 0x75, 0x4e, 0x59, 0x60, 0x73, 0x6a, 0xe9, 0x3e, 0xb3,
	0x4d, 0xaa, 0x2e, 0x8b, 0xb0, 0xdd, 0x94, 0xaa, 0x68, 0xeb, 0x13, 0x5f, 0x57, 0xb8, 0xc8, 0x27,
	0x50, 0xb4, 0xb9, 0xee, 0x87, 0xcc, 0x3c, 0x35, 0xb8, 0xd1, 0x1f, 0x52, 0x75, 0xa5, 0xaa, 0xec,
	0x64, 0xb5, 0x82, 0xcd, 0xbb, 0x13, 0x90, 0x7c, 0x0a, 0xc5, 0xd0, 0x1f, 0x30, 0xc3, 0xa2, 0xc2,
	0xd4, 0x03, 0x4f, 0x4d, 0x57, 0x97, 0xe5, 0x37, 0x0b, 0x09, 0x4f, 0xcf, 0x23, 0x65, 0xc8, 0xf6,
	0xa9, 0x4b, 0x4f, 0xec, 0x80, 0xab, 0x19, 0x11, 0xa4, 0x8d, 0x6d, 0xf2, 0x29, 0x94, 0x7c, 0x66,
	0x7b, 0xcc, 0x0e, 0xec, 0x5f, 0x51, 0x7d, 0x48, 0xcf, 0xe9, 0x50, 0x5d, 0xad, 0x2a, 0x3b, 0x69,
	0x6d, 0x7d, 0x82, 0xef, 0x0b, 0x98, 0xdc, 0x87, 0x9c, 0xcd, 0xf5, 0x53, 0xdb, 0xb2, 0xa8, 0xab,
	0x66, 0xc5, 0x9c, 0x70, 0xb0, 0xac, 0xcd, 0x5f, 0x21, 0x56, 0xfb, 0xf7, 0x0a, 0xac, 0x76, 0x0d,
	0xf3, 0xcc, 0x18, 0xd0, 0x44, 0x99, 0xd2, 0x58, 0x26, 0x02, 0x2b, 0xae, 0xe1, 0x50, 0x59, 0x1f,
	0xfc, 0x4d, 0x36, 0x21, 0x3d, 0xa9, 0x46, 0x5a, 0x8b, 0x0c, 0x31, 0x23, 0xcb, 0xe6, 0xa6, 0x17,
	0xba, 0xc1, 0xb8, 0x5c, 0x2b, 0xd1, 0x8c, 0x26, 0x78, 0x54, 0xaa, 0x99, 0xda, 0x63, 0x01, 0xa6,
	0x6b, 0xbf, 0x05, 0x19, 0xd7, 0x0b, 0xc4, 0x27, 0x32, 0x38, 0xb0, 0xb4, 0x48, 0x03, 0x32, 0x3e,
	0x65, 0xb6, 0x67, 0xe1, 0x62, 0xd7, 0x1a, 0xe5, 0x7a, 0xc4, 0x97, 0x7a, 0xcc, 0x82, 0x7a, 0x2f,
	0xe6, 0x8b, 0x26, 0x23, 0xe5, 0xc6, 0x30, 0x6a, 0x7a, 0x8e, 0x43, 0x5d, 0x8b, 0x5a, 0x51, 0x11,
	0xc4, 0xc6, 0x68, 0x13, 0x90, 0xdc, 0x03, 0xb0, 0xb9, 0x4e, 0x5d, 0x51, 0x7c, 0x4b, 0xcd, 0x61,
	0x48, 0xce, 0xe6, 0xed, 0x08, 0x98, 0xae, 0x22, 0xcc, 0x57, 0x91, 0x34, 0xe0, 0x96, 0x69, 0x30,
	0x66, 0x53, 0x4b, 0xf7, 0xce, 0x29, 0xd3, 0x0d, 0x47, 0x2c, 0x59, 0x5d, 0xab, 0x2a, 0x3b, 0x0a,
	0x86, 0x6e, 0x48, 0xf7, 0xe1, 0x39, 0x65, 0x4d, 0x74, 0x92, 0xbb, 0xb0, 0xea, 0x0f, 0x0d, 0x57,
	0xb7, 0x2d, 0x35, 0x3f, 0x66, 0x56, 0x46, 0x40, 0x1d, 0x8b, 0xd4, 0x61, 0x15, 0xab, 0xc6, 0x46,
	0x6a, 0xa1, 0xaa, 0xec, 0x14, 0x1b, 0x9b, 0xf5, 0xc4, 0x99, 0xaa, 0xb7, 0x22, 0x9f, 0x16, 0x07,
	0x2d, 0xa4, 0x44, 0x71, 0x31, 0x25, 0x9e, 0x43, 0xc1, 0x8f, 0x36, 0x5c, 0xb7, 0x03, 0xea, 0x70,
	0x75, 0xbd, 0xba, 0xbc, 0xb3, 0xd6, 0x50, 0xa7, 0x06, 0x90, 0x94, 0xe8, 0x04, 0xd4, 0xd1, 0xf2,
	0xfe, 0xc4, 0xe0, 0xa4, 0x06, 0x05, 0xdb, 0xe3, 0x7a, 0x3f, 0x74, 0xad, 0x21, 0x15, 0x93, 0x2f,
	0x45, 0xa7, 0xc7, 0xf6, 0xf8, 0x2e, 0x62, 0x1d, 0xab, 0xf6, 0x3f, 0x05, 0xd6, 0x12, 0x5f, 0x98,
	0x3b, 0x7f, 0xf7, 0x00, 0xc6, 0x53, 0xb0, 0x90, 0x5e, 0x69, 0x2d, 0x17, 0x8f, 0x62, 0x91, 0x3b,
	0x93, 0xca, 0x2c, 0x47, 0x0c, 0x90, 0x55, 0x79, 0x06, 0x40, 0xdf, 0xf8, 0x36, 0xa3, 0x96, 0x6e,
	0x04, 0x48, 0xb0, 0xab, 0x59, 0x90, 0x93, 0xd1, 0xcd, 0x40, 0x9c, 0x27, 0x2b, 0x64, 0x86, 0xe4,
	0x9c, 0x18, 0x70, 0x6c, 0x8b, 0x62, 0xf3, 0xb0, 0xff, 0x25, 0x35, 0x03, 0x3c, 0x6a, 0xb3, 0xc5,
	0x3e, 0x8a, 0x7c, 0x5a, 0x1c, 0x24, 0x08, 0x8a, 0x47, 0x95, 0xab, 0xab, 0xd5, 0xe5, 0x9d, 0xb4,
	0x26, 0xad, 0xda, 0x1f, 0x52, 0x90, 0x6f, 0x79, 0xd6, 0x21, 0xb3, 0x28, 0xeb, 0xb8, 0x27, 0x1e,
	0xf9, 0x18, 0x0a, 0x66, 0xc8, 0x03, 0xcf, 0xa1, 0x4c, 0xc7, 0x93, 0x14, 0x95, 0x20, 0x1f, 0x83,
	0x07, 0xe2, 0x44, 0x35, 0xe0, 0xf6, 0x38, 0xc8, 0x3f, 0xf5, 0x5c, 0xaa, 0xbb, 0xa1, 0xd3, 0xa7,
	0x4c, 0x1e, 0xbb, 0x5b, 0xb1, 0xb3, 0x2b, 0x7c, 0x07, 0xe8, 0x12, 0xdb, 0x3d, 0xce, 0x31, 0x2c,
	0x8b, 0x51, 0xce, 0x65, 0xa9, 0xd6, 0x63, 0xbc, 0x19, 0xc1, 0xa4, 0x0b, 0x5b, 0xf4, 0x8d, 0x4f,
	0x4d, 0x71, 0x30, 0x2d, 0x3a, 0xb4, 0xcf, 0x29, 0x1b, 0xe9, 0x42, 0x58, 0x6f, 0x50, 0xbf, 0xcd,
	0x38, 0x73, 0x4f, 0x26, 0x0a, 0x17, 0xf9, 0x0c, 0x32, 0x3c, 0x30, 0x82, 0x90, 0x63, 0x21, 0x8b,
	0x8d, 0xbb, 0x33, 0xd4, 0x8c, 0x0a, 0x70, 0x84, 0x21, 0x9a, 0x0c, 0xad, 0xfd, 0x3e, 0x05, 0xb7,
	0x8e, 0x82, 0xd0, 0xa2, 0x6e, 0x70, 0x94, 0xb8, 0x30, 0x92, 0x7b, 0xad, 0x4c, 0xed, 0xf5, 0xa4,
	0xc8, 0xa9, 0x64, 0x91, 0xc9, 0x53, 0xc8, 0xca, 0x7d, 0x10, 0x4b, 0xbe, 0x7c, 0xb7, 0xc6, 0x51,
	0xe4, 0x29, 0xa4, 0x79, 0x60, 0xb0, 0x9b, 0x10, 0x26, 0x0a, 0x24, 0xdf, 0x81, 0x65, 0xea, 0x5a,
	0xb8, 0xbc, 0xab, 0xe3, 0x45, 0x18, 0xf9, 0x7c, 0x5c, 0x8f, 0x0c, 0xd6, 0xe3, 0xfe, 0xec, 0x7c,
	0xc6, 0xab, 0x9d, 0xa9, 0xc9, 0xdf, 0xb3, 0x90, 0xc6, 0x5a, 0xcd, 0x29, 0xef, 0x16, 0x64, 0xa4,
	0x84, 0x08, 0x12, 0x28, 0x9a, 0xb4, 0x92, 0x9a, 0xb1, 0x3c, 0xa7, 0x19, 0xf7, 0x21, 0x87, 0x4e,
	0x64, 0xda, 0xca, 0xd8, 0x9d, 0x15, 0x20, 0x32, 0xed, 0x11, 0x6c, 0x38, 0x86, 0x1b, 0x1a, 0x43,
	0xdd, 0x64, 0xd4, 0x10, 0x84, 0xe8, 0x8f, 0x70, 0x91, 0x39, 0x6d, 0x3d, 0x72, 0xb4, 0x22, 0x7c,
	0x77, 0x44, 0x9e, 0xce, 0x2c, 0x6a, 0x5a, 0x1e, 0x16, 0xec, 0xb0, 0x98, 0xb3, 0xe9, 0x85, 0xbe,
	0xe7, 0xa2, 0x3c, 0xe7, 0x34, 0x69, 0xe1, 0x21, 0xc0, 0x5f, 0xb1, 0x2a, 0x66, 0x71, 0x49, 0xf9,
	0x08, 0x94, 0x62, 0x78, 0x89, 0x80, 0xe6, 0xae, 0x12, 0xd0, 0x3a, 0x6c, 0x4c, 0xe5, 0x9c, 0x30,
	0xcf, 0x41, 0x75, 0x4e, 0x47, 0x97, 0x74, 0x22, 0xe3, 0x05, 0xf3, 0x1c, 0xf2, 0xbd, 0x98, 0x07,
	0x6b, 0xd7, 0xed, 0x2b, 0xe6, 0x4b, 0x2e, 0x3c, 0x8d, 0xb8, 0x90, 0xbf, 0x51, 0x0e, 0xf2, 0xe1,
	0x19, 0x40, 0xe8, 0x5b, 0x58, 0x5f, 0x23, 0x40, 0xf9, 0xbe, 0x46, 0xa5, 0x64, 0x74, 0x33, 0x10,
	0xa9, 0xf1, 0xd6, 0x18, 0x01, 0x0a, 0xf8, 0x35, 0xa9, 0x32, 0x3a, 0x12, 0x38, 0x33, 0x64, 0x8c,
	0xba, 0xe6, 0x48, 0x5d, 0xc7, 0x0d, 0x18, 0xdb, 0xe2, 0x16, 0xf4, 0x8d, 0x91, 0x43, 0xdd, 0x40,
	0x77, 0x68, 0x70, 0xea, 0xc5, 0xa2, 0x5d, 0x90, 0xe8, 0x6b, 0x04, 0xc9, 0xb7, 0x20, 0x1f, 0x87,
	0x0d, 0x6d, 0xf7, 0x4c, 0xdd, 0x88, 0x94, 0x5d, 0x62, 0xfb, 0xb6, 0x7b, 0x36, 0xa3, 0xdc, 0x64,
	0x56, 0xb9, 0xf1, 0x0b, 0x91, 0x1b, 0x59, 0x78, 0x2b, 0xfe, 0x02, 0x62, 0x48, 0xc2, 0xc4, 0xcd,
	0xb6, 0x79, 0x93, 0x9b, 0xed, 0x1e, 0x00, 0x8f, 0x74, 0x43, 0x8c, 0x78, 0x1b, 0x3f, 0x98, 0x93,
	0x48, 0xc7, 0x12, 0x4a, 0xc8, 0xe8, 0x09, 0x15, 0xeb, 0x1c, 0x0b, 0xe7, 0x56, 0x44, 0xe9, 0x31,
	0x2e, 0x45, 0xf3, 0x47, 0x50, 0x34, 0x3d, 0x4b, 0xf7, 0x04, 0x77, 0x75, 0xdb, 0x3d, 0xf1, 0xd4,
	0x3b, 0x58, 0xe0, 0xed, 0x85, 0xfa, 0x25, 0x04, 0x5c, 0x90, 0x34, 0x21, 0xe7, 0xbb, 0xb0, 0xee,
	0x84, 0x3c, 0xd0, 0x7d, 0x63, 0xa4, 0xf7, 0xe9, 0x89, 0xc7, 0xa8, 0xaa, 0x5e, 0xbb, 0x45, 0x05,
	0x91, 0xd2, 0x35, 0x46, 0xbb, 0x98, 0x40, 0x5e, 0x40, 0x21, 0xf9, 0x60, 0xe6, 0xea, 0x36, 0xde,
	0xbe, 0xd5, 0x69, 0xcd, 0x98, 0x17, 0x4a, 0x6d, 0x3a, 0xad, 0xf6, 0x17, 0x05, 0xb6, 0x8f, 0x91,
	0x37, 0x4d, 0x6e, 0x1b, 0x5d, 0x63, 0x84, 0xd3, 0xd4, 0xe8, 0x2f, 0x42, 0xca, 0x03, 0xb2, 0x0d,
	0x59, 0xb9, 0xcc, 0x58, 0x55, 0x56, 0xd1, 0xee, 0x58, 0xe2, 0x38, 0x32, 0xca, 0x7d, 0xcf, 0xe5,
	0x54, 0x37, 0x3d, 0x8b, 0xca, 0xeb, 0x37, 0x1f, 0x83, 0x2d, 0xcf, 0xa2, 0x22, 0xe8, 0x24, 0x1c,
	0x0e, 0xf5, 0x18, 0x94, 0x97, 0x4b, 0x5e, 0x80, 0x9a, 0xc4, 0x16, 0xb0, 0x6a, 0x65, 0x01, 0xab,
	0x6a, 0x3f, 0x84, 0xf2, 0xa2, 0x89, 0xca, 0x8f, 0x54, 0x00, 0x78, 0x68, 0x9a, 0x94, 0xf3, 0x93,
	0x70, 0x88, 0x73, 0xcd, 0x6a, 0x09, 0xa4, 0xf6, 0x9b, 0x34, 0xe4, 0xba, 0xcc, 0x73, 0x3c, 0xbc,
	0x2d, 0xbe, 0x0f, 0xe0, 0x0b, 0x43, 0x0f, 0x46, 0x7e, 0x74, 0x9b, 0x16, 0x1b, 0x5b, 0xd3, 0x0f,
	0x17, 0xe1, 0xee, 0x8d, 0x7c, 0xaa, 0xe5, 0xfc, 0xf8, 0x67, 0x92, 0x73, 0xa9, 0x9b, 0x70, 0xee,
	0x3e, 0xac, 0x89, 0xd2, 0xe8, 0x3e, 0xa3, 0x27, 0xf6, 0x1b, 0xb9, 0x78, 0x10, 0x50, 0x17, 0x11,
	0xf1, 0x32, 0xc6, 0xda, 0x45, 0x0b, 0xc6, 0xdf, 0xa4, 0x05, 0x85, 0xf8, 0xad, 0x1b, 0x4d, 0x2f,
	0xba, 0x1d, 0x2b, 0xf3, 0xd3, 0xdb, 0x93, 0x61, 0x38, 0xcd, 0xbc, 0x95, 0xb0, 0xc8, 0x43, 0x18,
	0x3f, 0x98, 0x63, 0x0d, 0xcc, 0xa0, 0x5c, 0x16, 0x63, 0x58, 0x8a, 0xdf, 0x44, 0x9f, 0x57, 0x17,
	0xe8, 0x33, 0x0e, 0x33, 0xa3, 0xcf, 0xcf, 0x21, 0x8f, 0x8a, 0x26, 0xde, 0x01, 0x46, 0x40, 0x51,
	0x86, 0xaf, 0xa6, 0xee, 0x9a, 0x8c, 0xdf, 0x33, 0x02, 0x2a, 0xd2, 0xe3, 0xb7, 0x17, 0xa6, 0xe7,
	0xae, 0x4f, 0x97, 0xf1, 0x98, 0xfe, 0x0c, 0xb6, 0x19, 0xb5, 0xa8, 0x83, 0xf4, 0xd5, 0x87, 0xb6,
	0x63, 0x07, 0xba, 0x4f, 0x59, 0x44, 0x41, 0x14, 0x6d, 0x6d, 0x6b, 0x12, 0xb0, 0x2f, 0xfc, 0x5d,
	0xca, 0x90, 0x8c, 0x97, 0xa5, 0x86, 0x9c, 0x32, 0xd4, 0xf2, 0x85, 0xa9, 0xc7, 0x9c, 0x32, 0xd1,
	0xad, 0xb8, 0x5e, 0x40, 0x79, 0xf4, 0xc2, 0xd6, 0x22, 0x43, 0x3c, 0x08, 0x58, 0x38, 0xa4, 0x5c,
	0x2d, 0xe0, 0xd9, 0x2b, 0xcf, 0x97, 0x0e, 0x4f, 0x5c, 0x38, 0xa4, 0x5a, 0x14, 0x58, 0xfb, 0x53,
	0x0a, 0x0a, 0x53, 0x8e, 0x0f, 0x65, 0xe2, 0x1c, 0x49, 0x52, 0xdf, 0x0c, 0x49, 0x96, 0x17, 0x92,
	0xe4, 0x73, 0x00, 0xd3, 0x73, 0x2d, 0x3b, 0x52, 0x9a, 0xe8, 0xf9, 0x73, 0x67, 0x6e, 0xc7, 0x8e,
	0xb0, 0x07, 0xd7, 0x12, 0xa1, 0xe4, 0xbb, 0xb0, 0xca, 0xe8, 0x2f, 0x0d, 0x66, 0x71, 0xf9, 0x08,
	0xba, 0x34, 0x2b, 0x8e, 0xab, 0xbd, 0x81, 0xdb, 0xd1, 0x31, 0x7f, 0xf9, 0xea, 0x60, 0x4a, 0x8b,
	0xaa, 0x90, 0x1f, 0x9c, 0xba, 0xfa, 0x94, 0x1e, 0xe5, 0x34, 0x18, 0x9c, 0xba, 0x87, 0x52, 0x92,
	0x9e, 0x43, 0xc6, 0x30, 0xc7, 0x9d, 0x78, 0xb1, 0xf1, 0xc9, 0x42, 0x41, 0xee, 0x31, 0xc3, 0xe5,
	0x38, 0xbf, 0x26, 0x06, 0x6b, 0x32, 0xa9, 0xa6, 0xc2, 0xd6, 0xec, 0xc8, 0x91, 0xb8, 0xd4, 0x3e,
	0x82, 0xf2, 0x4b, 0x1a, 0x34, 0xe3, 0x66, 0x5d, 0xb6, 0x24, 0x72, 0x62, 0xb5, 0xbf, 0xad, 0xc0,
	0xdd, 0x85, 0x6e, 0x29, 0x4d, 0xc7, 0x90, 0x95, 0x17, 0x17, 0x57, 0x15, 0x64, 0xca, 0xb3, 0xa9,
	0x89, 0x5d, 0x91, 0x5b, 0x9f, 0x73, 0x8c, 0x3f, 0x55, 0x3e, 0x87, 0xcd, 0x59, 0x2f, 0x36, 0x49,
	0xd3, 0x57, 0xab, 0x72, 0x45, 0x53, 0x94, 0x9a, 0x7a, 0x28, 0x3f, 0x80, 0xf5, 0x64, 0x3f, 0x37,
	0xe9, 0x9a, 0x0a, 0x89, 0xbe, 0xad, 0x63, 0x95, 0xff, 0x91, 0x82, 0xd2, 0xec, 0xc0, 0xd7, 0x0d,
	0x7a, 0xf3, 0x7f, 0x00, 0x66, 0xda, 0xfa, 0x95, 0xf9, 0xb6, 0x3e, 0x21, 0xc2, 0xe9, 0x0f, 0x6d,
	0x69, 0x33, 0x8b, 0x5b, 0xda, 0xfe, 0x6c, 0x4b, 0xbb, 0x8a, 0xdb, 0xf5, 0xfc, 0x83, 0xb7, 0x6b,
	0xbe, 0xef, 0x7d, 0xf4, 0x47, 0x45, 0x5e, 0x44, 0x78, 0x04, 0x0b, 0x90, 0xeb, 0x6a, 0x87, 0xaf,
	0x0f, 0x7b, 0x9d, 0xc3, 0x83, 0xd2, 0x12, 0xb9, 0x0d, 0x1b, 0x63, 0x53, 0xef, 0xb5, 0x9b, 0xad,
	0x57, 0x6d, 0xad, 0xa4, 0x90, 0x2d, 0x20, 0x13, 0x58, 0x6b, 0xbf, 0x68, 0x6b, 0x5a, 0x73, 0xbf,
	0x94, 0x22, 0x25, 0xc8, 0x4f, 0xf0, 0xfd, 0xbd, 0xd2, 0xf2, 0x34, 0x72, 0xd4, 0x2a, 0xad, 0x90,
	0x0d, 0x28, 0x4c, 0x90, 0x1f, 0x1f, 0xee, 0x97, 0xd2, 0x44, 0x85, 0xcd, 0x09, 0xd4, 0x6c, 0xf5,
	0x3a, 0x5f, 0x34, 0x71, 0xfc, 0xcc, 0x23, 0x0a, 0x1b, 0x73, 0xa2, 0x41, 0x76, 0xe0, 0xdb, 0x93,
	0xf0, 0xbd, 0xce, 0x51, 0xeb, 0xf0, 0xf8, 0xa0, 0xa7, 0xf7, 0x7e, 0xda, 0x6d, 0xeb, 0x2f, 0x3a,
	0x3f, 0x69, 0xef, 0xe9, 0xcd, 0xd7, 0x02, 0x29, 0x2d, 0x91, 0x07, 0x50, 0xbb, 0x2c, 0xb2, 0xdb,
	0xd6, 0x5a, 0xed, 0x83, 0x5e, 0xf3, 0x65, 0xbb, 0xa4, 0x3c, 0xda, 0x87, 0xb5, 0xc4, 0xcd, 0x42,
	0x2a, 0x50, 0x4e, 0x4c, 0xba, 0xd7, 0xec, 0x1d, 0x1f, 0xe9, 0xdd, 0xe3, 0xdd, 0xfd, 0xce, 0xd1,
	0xab, 0xf6, 0x5e, 0x69, 0x89, 0xdc, 0x83, 0xed, 0x39, 0x7f, 0x53, 0x6b, 0xbd, 0xea, 0x7c, 0xd1,
	0xde, 0x2b, 0x29, 0x8d, 0xb7, 0xa2, 0x25, 0x4c, 0x76, 0x47, 0x94, 0x9d, 0x0b, 0x2a, 0x7d, 0x09,
	0x64, 0xfe, 0xc1, 0x40, 0x1e, 0x4c, 0x6d, 0xe6, 0xa5, 0x4f, 0x9f, 0xf2, 0xc3, 0x6b, 0xe3, 0xa4,
	0x38, 0x2c, 0xff, 0x36, 0xa5, 0x90, 0x9f, 0x43, 0x71, 0x5a, 0x3b, 0x48, 0x6d, 0x41, 0xfe, 0x8c,
	0xa4, 0x95, 0x3f, 0xbe, 0x32, 0x26, 0xf9, 0x7d, 0x07, 0x6e, 0x2d, 0xe0, 0x1d, 0x79, 0x78, 0x3d,
	0x33, 0xa3, 0x91, 0x76, 0x6e, 0x4a, 0x61, 0x1c, 0x6e, 0x77, 0xf8, 0xf6, 0x5d, 0x65, 0xe9, 0xab,
	0x77, 0x95, 0xa5, 0xaf, 0xdf, 0x55, 0x94, 0x5f, 0x5f, 0x54, 0x94, 0xbf, 0x5e, 0x54, 0x94, 0x7f,
	0x5d, 0x54, 0x94, 0xb7, 0x17, 0x15, 0xe5, 0x3f, 0x17, 0x15, 0xe5, 0xbf, 0x17, 0x95, 0xa5, 0xaf,
	0x2f, 0x2a, 0xca, 0xef, 0xde, 0x57, 0x96, 0xfe, 0xf9, 0xbe, 0xa2, 0xbc, 0x7d, 0x5f, 0x59, 0xfa,
	0xea, 0x7d, 0x65, 0xe9, 0x67, 0x8d, 0xc4, 0x5f, 0xab, 0x72, 0xc8, 0xc7, 0xe2, 0x77, 0xdf, 0x30,
	0xcf, 0xa8, 0x6b, 0x3d, 0xf1, 0xcf, 0x06, 0x4f, 0x06, 0xd4, 0x8d, 0xfe, 0x63, 0xed, 0x7b, 0xfd,
	0x1f, 0xf8, 0xfd, 0x7e, 0x06, 0xad, 0xcf, 0xfe, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x09, 0x6d, 0x33,
	0xd2, 0x03, 0x16, 0x00, 0x00,
}

func (x PromoType) String() string {
	s, ok := PromoType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PromoDiscountType) String() string {
	s, ok := PromoDiscountType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PromoStatus) String() string {
	s, ok := PromoStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Plan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Plan)
	if !ok {
		that2, ok := that.(Plan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.AdvertisedPrice != that1.AdvertisedPrice {
		return false
	}
	if this.IsPurchasable != that1.IsPurchasable {
		return false
	}
	if len(this.UpgradeableTo) != len(that1.UpgradeableTo) {
		return false
	}
	for i := range this.UpgradeableTo {
		if this.UpgradeableTo[i] != that1.UpgradeableTo[i] {
			return false
		}
	}
	if len(this.Benefits) != len(that1.Benefits) {
		return false
	}
	for i := range this.Benefits {
		if this.Benefits[i] != that1.Benefits[i] {
			return false
		}
	}
	if this.PrioritizeLevel != that1.PrioritizeLevel {
		return false
	}
	if this.IsHidden != that1.IsHidden {
		return false
	}
	return true
}
func (this *Package) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Package)
	if !ok {
		that2, ok := that.(Package)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.DiscountedPrice != that1.DiscountedPrice {
		return false
	}
	if len(this.Description) != len(that1.Description) {
		return false
	}
	for i := range this.Description {
		if this.Description[i] != that1.Description[i] {
			return false
		}
	}
	if this.Notice != that1.Notice {
		return false
	}
	if !this.Period.Equal(that1.Period) {
		return false
	}
	if this.IsRecommended != that1.IsRecommended {
		return false
	}
	if this.IsEnabled != that1.IsEnabled {
		return false
	}
	if this.IsHidden != that1.IsHidden {
		return false
	}
	if this.CarriedOverAmount != that1.CarriedOverAmount {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	if this.PrioritizeLevel != that1.PrioritizeLevel {
		return false
	}
	if len(this.PackageItems) != len(that1.PackageItems) {
		return false
	}
	for i := range this.PackageItems {
		if !this.PackageItems[i].Equal(that1.PackageItems[i]) {
			return false
		}
	}
	if this.IosBundleId != that1.IosBundleId {
		return false
	}
	return true
}
func (this *PackageItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PackageItem)
	if !ok {
		that2, ok := that.(PackageItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if !this.ExpiredAt.Equal(that1.ExpiredAt) {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if len(this.Subject) != len(that1.Subject) {
		return false
	}
	for i := range this.Subject {
		if this.Subject[i] != that1.Subject[i] {
			return false
		}
	}
	if len(this.Grades) != len(that1.Grades) {
		return false
	}
	for i := range this.Grades {
		if this.Grades[i] != that1.Grades[i] {
			return false
		}
	}
	return true
}
func (this *CodOrderInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodOrderInfo)
	if !ok {
		that2, ok := that.(CodOrderInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomerName != that1.CustomerName {
		return false
	}
	if this.CustomerPhoneNumber != that1.CustomerPhoneNumber {
		return false
	}
	if this.CustomerAddress != that1.CustomerAddress {
		return false
	}
	if !this.ExpectedDeliveryTime.Equal(that1.ExpectedDeliveryTime) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *StudentSubscription) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StudentSubscription)
	if !ok {
		that2, ok := that.(StudentSubscription)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if len(this.Grades) != len(that1.Grades) {
		return false
	}
	for i := range this.Grades {
		if this.Grades[i] != that1.Grades[i] {
			return false
		}
	}
	if len(this.Subjects) != len(that1.Subjects) {
		return false
	}
	for i := range this.Subjects {
		if this.Subjects[i] != that1.Subjects[i] {
			return false
		}
	}
	if !this.Start.Equal(that1.Start) {
		return false
	}
	if !this.End.Equal(that1.End) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if this.PlanName != that1.PlanName {
		return false
	}
	if this.ManualCreatedBy != that1.ManualCreatedBy {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Coupon != that1.Coupon {
		return false
	}
	if this.CouponAmount != that1.CouponAmount {
		return false
	}
	if this.CarriedOverAmount != that1.CarriedOverAmount {
		return false
	}
	if this.CarriedOverFrom != that1.CarriedOverFrom {
		return false
	}
	if !this.Start.Equal(that1.Start) {
		return false
	}
	if !this.End.Equal(that1.End) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Currency != that1.Currency {
		return false
	}
	if this.PaymentMethod != that1.PaymentMethod {
		return false
	}
	if this.PaymentLink != that1.PaymentLink {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	if this.PackageName != that1.PackageName {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	if this.StudentId != that1.StudentId {
		return false
	}
	if this.ReferenceNumber != that1.ReferenceNumber {
		return false
	}
	if !this.CodOrderInfo.Equal(that1.CodOrderInfo) {
		return false
	}
	if !this.MustPayBefore.Equal(that1.MustPayBefore) {
		return false
	}
	if len(this.Subscriptions) != len(that1.Subscriptions) {
		return false
	}
	for i := range this.Subscriptions {
		if !this.Subscriptions[i].Equal(that1.Subscriptions[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateAsiaPayOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateAsiaPayOrderRequest)
	if !ok {
		that2, ok := that.(UpdateAsiaPayOrderRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.FullResponse != that1.FullResponse {
		return false
	}
	if this.PaymentMethod != that1.PaymentMethod {
		return false
	}
	return true
}
func (this *UpdateAsiaPayOrderResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateAsiaPayOrderResponse)
	if !ok {
		that2, ok := that.(UpdateAsiaPayOrderResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *Promotion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Promotion)
	if !ok {
		that2, ok := that.(Promotion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PromoType != that1.PromoType {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	if this.CodePrefix != that1.CodePrefix {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.DiscountType != that1.DiscountType {
		return false
	}
	if this.DiscountAmount != that1.DiscountAmount {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.StartedDate.Equal(that1.StartedDate) {
		return false
	}
	if !this.ExpiredDate.Equal(that1.ExpiredDate) {
		return false
	}
	if this.RedemptionLimitPerCode != that1.RedemptionLimitPerCode {
		return false
	}
	if this.RedemptionLimitPerUser != that1.RedemptionLimitPerUser {
		return false
	}
	if this.Notes != that1.Notes {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *PromotionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PromotionRule)
	if !ok {
		that2, ok := that.(PromotionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PromoType != that1.PromoType {
		return false
	}
	if this.DiscountType != that1.DiscountType {
		return false
	}
	if this.DiscountAmount != that1.DiscountAmount {
		return false
	}
	if !this.Conditions.Equal(that1.Conditions) {
		return false
	}
	if !this.Rewards.Equal(that1.Rewards) {
		return false
	}
	return true
}
func (this *UpdateGHNOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGHNOrderRequest)
	if !ok {
		that2, ok := that.(UpdateGHNOrderRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GhnOrderId != that1.GhnOrderId {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *UpdateGHNOrderResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGHNOrderResponse)
	if !ok {
		that2, ok := that.(UpdateGHNOrderResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetAdvertisePackageRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAdvertisePackageRequest)
	if !ok {
		that2, ok := that.(GetAdvertisePackageRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetAdvertisePackageResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAdvertisePackageResponse)
	if !ok {
		that2, ok := that.(GetAdvertisePackageResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Packages) != len(that1.Packages) {
		return false
	}
	for i := range this.Packages {
		if !this.Packages[i].Equal(that1.Packages[i]) {
			return false
		}
	}
	return true
}
func (this *GetAdvertisePackageResponse_AdvertisePackageItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAdvertisePackageResponse_AdvertisePackageItem)
	if !ok {
		that2, ok := that.(GetAdvertisePackageResponse_AdvertisePackageItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if this.PackageItemId != that1.PackageItemId {
		return false
	}
	return true
}
func (this *GetAdvertisePackageResponse_AdvertisePackage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAdvertisePackageResponse_AdvertisePackage)
	if !ok {
		that2, ok := that.(GetAdvertisePackageResponse_AdvertisePackage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if len(this.Description) != len(that1.Description) {
		return false
	}
	for i := range this.Description {
		if this.Description[i] != that1.Description[i] {
			return false
		}
	}
	if this.Country != that1.Country {
		return false
	}
	if this.PrioritizeLevel != that1.PrioritizeLevel {
		return false
	}
	if len(this.PackageItems) != len(that1.PackageItems) {
		return false
	}
	for i := range this.PackageItems {
		if !this.PackageItems[i].Equal(that1.PackageItems[i]) {
			return false
		}
	}
	return true
}
func (this *Plan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&pb.Plan{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "AdvertisedPrice: "+fmt.Sprintf("%#v", this.AdvertisedPrice)+",\n")
	s = append(s, "IsPurchasable: "+fmt.Sprintf("%#v", this.IsPurchasable)+",\n")
	s = append(s, "UpgradeableTo: "+fmt.Sprintf("%#v", this.UpgradeableTo)+",\n")
	s = append(s, "Benefits: "+fmt.Sprintf("%#v", this.Benefits)+",\n")
	s = append(s, "PrioritizeLevel: "+fmt.Sprintf("%#v", this.PrioritizeLevel)+",\n")
	s = append(s, "IsHidden: "+fmt.Sprintf("%#v", this.IsHidden)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Package) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&pb.Package{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "DiscountedPrice: "+fmt.Sprintf("%#v", this.DiscountedPrice)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Notice: "+fmt.Sprintf("%#v", this.Notice)+",\n")
	if this.Period != nil {
		s = append(s, "Period: "+fmt.Sprintf("%#v", this.Period)+",\n")
	}
	s = append(s, "IsRecommended: "+fmt.Sprintf("%#v", this.IsRecommended)+",\n")
	s = append(s, "IsEnabled: "+fmt.Sprintf("%#v", this.IsEnabled)+",\n")
	s = append(s, "IsHidden: "+fmt.Sprintf("%#v", this.IsHidden)+",\n")
	s = append(s, "CarriedOverAmount: "+fmt.Sprintf("%#v", this.CarriedOverAmount)+",\n")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "PrioritizeLevel: "+fmt.Sprintf("%#v", this.PrioritizeLevel)+",\n")
	if this.PackageItems != nil {
		s = append(s, "PackageItems: "+fmt.Sprintf("%#v", this.PackageItems)+",\n")
	}
	s = append(s, "IosBundleId: "+fmt.Sprintf("%#v", this.IosBundleId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PackageItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&pb.PackageItem{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	if this.ExpiredAt != nil {
		s = append(s, "ExpiredAt: "+fmt.Sprintf("%#v", this.ExpiredAt)+",\n")
	}
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	s = append(s, "Subject: "+fmt.Sprintf("%#v", this.Subject)+",\n")
	s = append(s, "Grades: "+fmt.Sprintf("%#v", this.Grades)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodOrderInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.CodOrderInfo{")
	s = append(s, "CustomerName: "+fmt.Sprintf("%#v", this.CustomerName)+",\n")
	s = append(s, "CustomerPhoneNumber: "+fmt.Sprintf("%#v", this.CustomerPhoneNumber)+",\n")
	s = append(s, "CustomerAddress: "+fmt.Sprintf("%#v", this.CustomerAddress)+",\n")
	if this.ExpectedDeliveryTime != nil {
		s = append(s, "ExpectedDeliveryTime: "+fmt.Sprintf("%#v", this.ExpectedDeliveryTime)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StudentSubscription) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&pb.StudentSubscription{")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	s = append(s, "Grades: "+fmt.Sprintf("%#v", this.Grades)+",\n")
	s = append(s, "Subjects: "+fmt.Sprintf("%#v", this.Subjects)+",\n")
	if this.Start != nil {
		s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	}
	if this.End != nil {
		s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 29)
	s = append(s, "&pb.Order{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	s = append(s, "PlanName: "+fmt.Sprintf("%#v", this.PlanName)+",\n")
	s = append(s, "ManualCreatedBy: "+fmt.Sprintf("%#v", this.ManualCreatedBy)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Coupon: "+fmt.Sprintf("%#v", this.Coupon)+",\n")
	s = append(s, "CouponAmount: "+fmt.Sprintf("%#v", this.CouponAmount)+",\n")
	s = append(s, "CarriedOverAmount: "+fmt.Sprintf("%#v", this.CarriedOverAmount)+",\n")
	s = append(s, "CarriedOverFrom: "+fmt.Sprintf("%#v", this.CarriedOverFrom)+",\n")
	if this.Start != nil {
		s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	}
	if this.End != nil {
		s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	}
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "PaymentMethod: "+fmt.Sprintf("%#v", this.PaymentMethod)+",\n")
	s = append(s, "PaymentLink: "+fmt.Sprintf("%#v", this.PaymentLink)+",\n")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "PackageName: "+fmt.Sprintf("%#v", this.PackageName)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "StudentId: "+fmt.Sprintf("%#v", this.StudentId)+",\n")
	s = append(s, "ReferenceNumber: "+fmt.Sprintf("%#v", this.ReferenceNumber)+",\n")
	if this.CodOrderInfo != nil {
		s = append(s, "CodOrderInfo: "+fmt.Sprintf("%#v", this.CodOrderInfo)+",\n")
	}
	if this.MustPayBefore != nil {
		s = append(s, "MustPayBefore: "+fmt.Sprintf("%#v", this.MustPayBefore)+",\n")
	}
	if this.Subscriptions != nil {
		s = append(s, "Subscriptions: "+fmt.Sprintf("%#v", this.Subscriptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateAsiaPayOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pb.UpdateAsiaPayOrderRequest{")
	s = append(s, "OrderId: "+fmt.Sprintf("%#v", this.OrderId)+",\n")
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "FullResponse: "+fmt.Sprintf("%#v", this.FullResponse)+",\n")
	s = append(s, "PaymentMethod: "+fmt.Sprintf("%#v", this.PaymentMethod)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateAsiaPayOrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UpdateAsiaPayOrderResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Promotion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&pb.Promotion{")
	s = append(s, "PromoType: "+fmt.Sprintf("%#v", this.PromoType)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "CodePrefix: "+fmt.Sprintf("%#v", this.CodePrefix)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "DiscountType: "+fmt.Sprintf("%#v", this.DiscountType)+",\n")
	s = append(s, "DiscountAmount: "+fmt.Sprintf("%#v", this.DiscountAmount)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.StartedDate != nil {
		s = append(s, "StartedDate: "+fmt.Sprintf("%#v", this.StartedDate)+",\n")
	}
	if this.ExpiredDate != nil {
		s = append(s, "ExpiredDate: "+fmt.Sprintf("%#v", this.ExpiredDate)+",\n")
	}
	s = append(s, "RedemptionLimitPerCode: "+fmt.Sprintf("%#v", this.RedemptionLimitPerCode)+",\n")
	s = append(s, "RedemptionLimitPerUser: "+fmt.Sprintf("%#v", this.RedemptionLimitPerUser)+",\n")
	s = append(s, "Notes: "+fmt.Sprintf("%#v", this.Notes)+",\n")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PromotionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.PromotionRule{")
	s = append(s, "PromoType: "+fmt.Sprintf("%#v", this.PromoType)+",\n")
	s = append(s, "DiscountType: "+fmt.Sprintf("%#v", this.DiscountType)+",\n")
	s = append(s, "DiscountAmount: "+fmt.Sprintf("%#v", this.DiscountAmount)+",\n")
	if this.Conditions != nil {
		s = append(s, "Conditions: "+fmt.Sprintf("%#v", this.Conditions)+",\n")
	}
	if this.Rewards != nil {
		s = append(s, "Rewards: "+fmt.Sprintf("%#v", this.Rewards)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGHNOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.UpdateGHNOrderRequest{")
	s = append(s, "GhnOrderId: "+fmt.Sprintf("%#v", this.GhnOrderId)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGHNOrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&pb.UpdateGHNOrderResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAdvertisePackageRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&pb.GetAdvertisePackageRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAdvertisePackageResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.GetAdvertisePackageResponse{")
	if this.Packages != nil {
		s = append(s, "Packages: "+fmt.Sprintf("%#v", this.Packages)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAdvertisePackageResponse_AdvertisePackageItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.GetAdvertisePackageResponse_AdvertisePackageItem{")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	s = append(s, "PackageItemId: "+fmt.Sprintf("%#v", this.PackageItemId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAdvertisePackageResponse_AdvertisePackage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&pb.GetAdvertisePackageResponse_AdvertisePackage{")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "PrioritizeLevel: "+fmt.Sprintf("%#v", this.PrioritizeLevel)+",\n")
	if this.PackageItems != nil {
		s = append(s, "PackageItems: "+fmt.Sprintf("%#v", this.PackageItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSubscription(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SubscriptionServiceClient is the client API for SubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubscriptionServiceClient interface {
	UpdateAsiaPayOrder(ctx context.Context, in *UpdateAsiaPayOrderRequest, opts ...grpc.CallOption) (*UpdateAsiaPayOrderResponse, error)
	UpdateGHNOrder(ctx context.Context, in *UpdateGHNOrderRequest, opts ...grpc.CallOption) (*UpdateGHNOrderResponse, error)
	GetAdvertisePackage(ctx context.Context, in *GetAdvertisePackageRequest, opts ...grpc.CallOption) (*GetAdvertisePackageResponse, error)
}

type subscriptionServiceClient struct {
	cc *grpc.ClientConn
}

func NewSubscriptionServiceClient(cc *grpc.ClientConn) SubscriptionServiceClient {
	return &subscriptionServiceClient{cc}
}

// Deprecated: Do not use.
func (c *subscriptionServiceClient) UpdateAsiaPayOrder(ctx context.Context, in *UpdateAsiaPayOrderRequest, opts ...grpc.CallOption) (*UpdateAsiaPayOrderResponse, error) {
	out := new(UpdateAsiaPayOrderResponse)
	err := c.cc.Invoke(ctx, "/manabie.bob.SubscriptionService/UpdateAsiaPayOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *subscriptionServiceClient) UpdateGHNOrder(ctx context.Context, in *UpdateGHNOrderRequest, opts ...grpc.CallOption) (*UpdateGHNOrderResponse, error) {
	out := new(UpdateGHNOrderResponse)
	err := c.cc.Invoke(ctx, "/manabie.bob.SubscriptionService/UpdateGHNOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *subscriptionServiceClient) GetAdvertisePackage(ctx context.Context, in *GetAdvertisePackageRequest, opts ...grpc.CallOption) (*GetAdvertisePackageResponse, error) {
	out := new(GetAdvertisePackageResponse)
	err := c.cc.Invoke(ctx, "/manabie.bob.SubscriptionService/GetAdvertisePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscriptionServiceServer is the server API for SubscriptionService service.
type SubscriptionServiceServer interface {
	UpdateAsiaPayOrder(context.Context, *UpdateAsiaPayOrderRequest) (*UpdateAsiaPayOrderResponse, error)
	UpdateGHNOrder(context.Context, *UpdateGHNOrderRequest) (*UpdateGHNOrderResponse, error)
	GetAdvertisePackage(context.Context, *GetAdvertisePackageRequest) (*GetAdvertisePackageResponse, error)
}

// UnimplementedSubscriptionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSubscriptionServiceServer struct {
}

func (*UnimplementedSubscriptionServiceServer) UpdateAsiaPayOrder(ctx context.Context, req *UpdateAsiaPayOrderRequest) (*UpdateAsiaPayOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAsiaPayOrder not implemented")
}
func (*UnimplementedSubscriptionServiceServer) UpdateGHNOrder(ctx context.Context, req *UpdateGHNOrderRequest) (*UpdateGHNOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGHNOrder not implemented")
}
func (*UnimplementedSubscriptionServiceServer) GetAdvertisePackage(ctx context.Context, req *GetAdvertisePackageRequest) (*GetAdvertisePackageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdvertisePackage not implemented")
}

func RegisterSubscriptionServiceServer(s *grpc.Server, srv SubscriptionServiceServer) {
	s.RegisterService(&_SubscriptionService_serviceDesc, srv)
}

func _SubscriptionService_UpdateAsiaPayOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAsiaPayOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).UpdateAsiaPayOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.bob.SubscriptionService/UpdateAsiaPayOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).UpdateAsiaPayOrder(ctx, req.(*UpdateAsiaPayOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_UpdateGHNOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGHNOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).UpdateGHNOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.bob.SubscriptionService/UpdateGHNOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).UpdateGHNOrder(ctx, req.(*UpdateGHNOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_GetAdvertisePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdvertisePackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).GetAdvertisePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.bob.SubscriptionService/GetAdvertisePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).GetAdvertisePackage(ctx, req.(*GetAdvertisePackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SubscriptionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "manabie.bob.SubscriptionService",
	HandlerType: (*SubscriptionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateAsiaPayOrder",
			Handler:    _SubscriptionService_UpdateAsiaPayOrder_Handler,
		},
		{
			MethodName: "UpdateGHNOrder",
			Handler:    _SubscriptionService_UpdateGHNOrder_Handler,
		},
		{
			MethodName: "GetAdvertisePackage",
			Handler:    _SubscriptionService_GetAdvertisePackage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "subscription.proto",
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.PrioritizeLevel != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PrioritizeLevel))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Benefits) > 0 {
		for iNdEx := len(m.Benefits) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Benefits[iNdEx])
			copy(dAtA[i:], m.Benefits[iNdEx])
			i = encodeVarintSubscription(dAtA, i, uint64(len(m.Benefits[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.UpgradeableTo) > 0 {
		for iNdEx := len(m.UpgradeableTo) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpgradeableTo[iNdEx])
			copy(dAtA[i:], m.UpgradeableTo[iNdEx])
			i = encodeVarintSubscription(dAtA, i, uint64(len(m.UpgradeableTo[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IsPurchasable {
		i--
		if m.IsPurchasable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.AdvertisedPrice) > 0 {
		i -= len(m.AdvertisedPrice)
		copy(dAtA[i:], m.AdvertisedPrice)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.AdvertisedPrice)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Package) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Package) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Package) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IosBundleId) > 0 {
		i -= len(m.IosBundleId)
		copy(dAtA[i:], m.IosBundleId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.IosBundleId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.PackageItems) > 0 {
		for iNdEx := len(m.PackageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.PrioritizeLevel != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PrioritizeLevel))
		i--
		dAtA[i] = 0x70
	}
	if m.Country != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x68
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0x62
	}
	if m.CarriedOverAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CarriedOverAmount))))
		i--
		dAtA[i] = 0x59
	}
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IsEnabled {
		i--
		if m.IsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IsRecommended {
		i--
		if m.IsRecommended {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Period != nil {
		{
			size, err := m.Period.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Notice) > 0 {
		i -= len(m.Notice)
		copy(dAtA[i:], m.Notice)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Notice)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		for iNdEx := len(m.Description) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Description[iNdEx])
			copy(dAtA[i:], m.Description[iNdEx])
			i = encodeVarintSubscription(dAtA, i, uint64(len(m.Description[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DiscountedPrice != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.DiscountedPrice))
		i--
		dAtA[i] = 0x20
	}
	if m.Price != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PackageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PackageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Grades) > 0 {
		dAtA3 := make([]byte, len(m.Grades)*10)
		var j2 int
		for _, num1 := range m.Grades {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintSubscription(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Subject) > 0 {
		dAtA5 := make([]byte, len(m.Subject)*10)
		var j4 int
		for _, num := range m.Subject {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintSubscription(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x32
	}
	if m.Duration != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpiredAt != nil {
		{
			size, err := m.ExpiredAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PackageId != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodOrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodOrderInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodOrderInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpectedDeliveryTime != nil {
		{
			size, err := m.ExpectedDeliveryTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CustomerPhoneNumber) > 0 {
		i -= len(m.CustomerPhoneNumber)
		copy(dAtA[i:], m.CustomerPhoneNumber)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.CustomerPhoneNumber)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CustomerName) > 0 {
		i -= len(m.CustomerName)
		copy(dAtA[i:], m.CustomerName)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.CustomerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StudentSubscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudentSubscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudentSubscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Subjects) > 0 {
		dAtA11 := make([]byte, len(m.Subjects)*10)
		var j10 int
		for _, num := range m.Subjects {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintSubscription(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grades) > 0 {
		dAtA13 := make([]byte, len(m.Grades)*10)
		var j12 int
		for _, num1 := range m.Grades {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintSubscription(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Subscriptions) > 0 {
		for iNdEx := len(m.Subscriptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subscriptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.MustPayBefore != nil {
		{
			size, err := m.MustPayBefore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.CodOrderInfo != nil {
		{
			size, err := m.CodOrderInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ReferenceNumber) > 0 {
		i -= len(m.ReferenceNumber)
		copy(dAtA[i:], m.ReferenceNumber)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.ReferenceNumber)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.StudentId) > 0 {
		i -= len(m.StudentId)
		copy(dAtA[i:], m.StudentId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.StudentId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Country != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.PackageName) > 0 {
		i -= len(m.PackageName)
		copy(dAtA[i:], m.PackageName)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PackageName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.PackageId != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.PaymentLink) > 0 {
		i -= len(m.PaymentLink)
		copy(dAtA[i:], m.PaymentLink)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PaymentLink)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PaymentMethod) > 0 {
		i -= len(m.PaymentMethod)
		copy(dAtA[i:], m.PaymentMethod)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PaymentMethod)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x7a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CarriedOverFrom != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.CarriedOverFrom))
		i--
		dAtA[i] = 0x50
	}
	if m.CarriedOverAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CarriedOverAmount))))
		i--
		dAtA[i] = 0x49
	}
	if m.CouponAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CouponAmount))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.Coupon) > 0 {
		i -= len(m.Coupon)
		copy(dAtA[i:], m.Coupon)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Coupon)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ManualCreatedBy) > 0 {
		i -= len(m.ManualCreatedBy)
		copy(dAtA[i:], m.ManualCreatedBy)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.ManualCreatedBy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PlanName) > 0 {
		i -= len(m.PlanName)
		copy(dAtA[i:], m.PlanName)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PlanName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x11
	}
	if m.Id != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateAsiaPayOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAsiaPayOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateAsiaPayOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PaymentMethod) > 0 {
		i -= len(m.PaymentMethod)
		copy(dAtA[i:], m.PaymentMethod)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PaymentMethod)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FullResponse) > 0 {
		i -= len(m.FullResponse)
		copy(dAtA[i:], m.FullResponse)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.FullResponse)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ResponseCode != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x10
	}
	if m.OrderId != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateAsiaPayOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAsiaPayOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateAsiaPayOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Promotion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Promotion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Promotion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x62
	}
	if m.RedemptionLimitPerUser != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.RedemptionLimitPerUser))
		i--
		dAtA[i] = 0x58
	}
	if m.RedemptionLimitPerCode != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.RedemptionLimitPerCode))
		i--
		dAtA[i] = 0x50
	}
	if m.ExpiredDate != nil {
		{
			size, err := m.ExpiredDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.StartedDate != nil {
		{
			size, err := m.StartedDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Status != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.DiscountAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiscountAmount))))
		i--
		dAtA[i] = 0x31
	}
	if m.DiscountType != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.DiscountType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CodePrefix) > 0 {
		i -= len(m.CodePrefix)
		copy(dAtA[i:], m.CodePrefix)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.CodePrefix)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Country != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x10
	}
	if m.PromoType != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PromoType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PromotionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PromotionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PromotionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rewards != nil {
		{
			size, err := m.Rewards.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Conditions != nil {
		{
			size, err := m.Conditions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DiscountAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiscountAmount))))
		i--
		dAtA[i] = 0x19
	}
	if m.DiscountType != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.DiscountType))
		i--
		dAtA[i] = 0x10
	}
	if m.PromoType != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PromoType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGHNOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGHNOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGHNOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GhnOrderId) > 0 {
		i -= len(m.GhnOrderId)
		copy(dAtA[i:], m.GhnOrderId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.GhnOrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGHNOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGHNOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGHNOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetAdvertisePackageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdvertisePackageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdvertisePackageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetAdvertisePackageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdvertisePackageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdvertisePackageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Packages) > 0 {
		for iNdEx := len(m.Packages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Packages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PackageItemId) > 0 {
		i -= len(m.PackageItemId)
		copy(dAtA[i:], m.PackageItemId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PackageItemId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0x12
	}
	if m.PackageId != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PackageItems) > 0 {
		for iNdEx := len(m.PackageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.PrioritizeLevel != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PrioritizeLevel))
		i--
		dAtA[i] = 0x30
	}
	if m.Country != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		for iNdEx := len(m.Description) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Description[iNdEx])
			copy(dAtA[i:], m.Description[iNdEx])
			i = encodeVarintSubscription(dAtA, i, uint64(len(m.Description[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Price != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.PackageId != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSubscription(dAtA []byte, offset int, v uint64) int {
	offset -= sovSubscription(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Plan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.AdvertisedPrice)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.IsPurchasable {
		n += 2
	}
	if len(m.UpgradeableTo) > 0 {
		for _, s := range m.UpgradeableTo {
			l = len(s)
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	if len(m.Benefits) > 0 {
		for _, s := range m.Benefits {
			l = len(s)
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	if m.PrioritizeLevel != 0 {
		n += 1 + sovSubscription(uint64(m.PrioritizeLevel))
	}
	if m.IsHidden {
		n += 2
	}
	return n
}

func (m *Package) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSubscription(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovSubscription(uint64(m.Price))
	}
	if m.DiscountedPrice != 0 {
		n += 1 + sovSubscription(uint64(m.DiscountedPrice))
	}
	if len(m.Description) > 0 {
		for _, s := range m.Description {
			l = len(s)
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	l = len(m.Notice)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Period != nil {
		l = m.Period.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.IsRecommended {
		n += 2
	}
	if m.IsEnabled {
		n += 2
	}
	if m.IsHidden {
		n += 2
	}
	if m.CarriedOverAmount != 0 {
		n += 9
	}
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Country != 0 {
		n += 1 + sovSubscription(uint64(m.Country))
	}
	if m.PrioritizeLevel != 0 {
		n += 1 + sovSubscription(uint64(m.PrioritizeLevel))
	}
	if len(m.PackageItems) > 0 {
		for _, e := range m.PackageItems {
			l = e.Size()
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	l = len(m.IosBundleId)
	if l > 0 {
		n += 2 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *PackageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.PackageId != 0 {
		n += 1 + sovSubscription(uint64(m.PackageId))
	}
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.ExpiredAt != nil {
		l = m.ExpiredAt.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovSubscription(uint64(m.Duration))
	}
	if len(m.Subject) > 0 {
		l = 0
		for _, e := range m.Subject {
			l += sovSubscription(uint64(e))
		}
		n += 1 + sovSubscription(uint64(l)) + l
	}
	if len(m.Grades) > 0 {
		l = 0
		for _, e := range m.Grades {
			l += sovSubscription(uint64(e))
		}
		n += 1 + sovSubscription(uint64(l)) + l
	}
	return n
}

func (m *CodOrderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerName)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.CustomerPhoneNumber)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.ExpectedDeliveryTime != nil {
		l = m.ExpectedDeliveryTime.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovSubscription(uint64(m.Status))
	}
	return n
}

func (m *StudentSubscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if len(m.Grades) > 0 {
		l = 0
		for _, e := range m.Grades {
			l += sovSubscription(uint64(e))
		}
		n += 1 + sovSubscription(uint64(l)) + l
	}
	if len(m.Subjects) > 0 {
		l = 0
		for _, e := range m.Subjects {
			l += sovSubscription(uint64(e))
		}
		n += 1 + sovSubscription(uint64(l)) + l
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovSubscription(uint64(m.Status))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSubscription(uint64(m.Id))
	}
	if m.Amount != 0 {
		n += 9
	}
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.PlanName)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.ManualCreatedBy)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovSubscription(uint64(m.Status))
	}
	l = len(m.Coupon)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.CouponAmount != 0 {
		n += 9
	}
	if m.CarriedOverAmount != 0 {
		n += 9
	}
	if m.CarriedOverFrom != 0 {
		n += 1 + sovSubscription(uint64(m.CarriedOverFrom))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.PaymentMethod)
	if l > 0 {
		n += 2 + l + sovSubscription(uint64(l))
	}
	l = len(m.PaymentLink)
	if l > 0 {
		n += 2 + l + sovSubscription(uint64(l))
	}
	if m.PackageId != 0 {
		n += 2 + sovSubscription(uint64(m.PackageId))
	}
	l = len(m.PackageName)
	if l > 0 {
		n += 2 + l + sovSubscription(uint64(l))
	}
	if m.Country != 0 {
		n += 2 + sovSubscription(uint64(m.Country))
	}
	l = len(m.StudentId)
	if l > 0 {
		n += 2 + l + sovSubscription(uint64(l))
	}
	l = len(m.ReferenceNumber)
	if l > 0 {
		n += 2 + l + sovSubscription(uint64(l))
	}
	if m.CodOrderInfo != nil {
		l = m.CodOrderInfo.Size()
		n += 2 + l + sovSubscription(uint64(l))
	}
	if m.MustPayBefore != nil {
		l = m.MustPayBefore.Size()
		n += 2 + l + sovSubscription(uint64(l))
	}
	if len(m.Subscriptions) > 0 {
		for _, e := range m.Subscriptions {
			l = e.Size()
			n += 2 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *UpdateAsiaPayOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != 0 {
		n += 1 + sovSubscription(uint64(m.OrderId))
	}
	if m.ResponseCode != 0 {
		n += 1 + sovSubscription(uint64(m.ResponseCode))
	}
	l = len(m.FullResponse)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.PaymentMethod)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *UpdateAsiaPayOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *Promotion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PromoType != 0 {
		n += 1 + sovSubscription(uint64(m.PromoType))
	}
	if m.Country != 0 {
		n += 1 + sovSubscription(uint64(m.Country))
	}
	l = len(m.CodePrefix)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.DiscountType != 0 {
		n += 1 + sovSubscription(uint64(m.DiscountType))
	}
	if m.DiscountAmount != 0 {
		n += 9
	}
	if m.Status != 0 {
		n += 1 + sovSubscription(uint64(m.Status))
	}
	if m.StartedDate != nil {
		l = m.StartedDate.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.ExpiredDate != nil {
		l = m.ExpiredDate.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.RedemptionLimitPerCode != 0 {
		n += 1 + sovSubscription(uint64(m.RedemptionLimitPerCode))
	}
	if m.RedemptionLimitPerUser != 0 {
		n += 1 + sovSubscription(uint64(m.RedemptionLimitPerUser))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *PromotionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PromoType != 0 {
		n += 1 + sovSubscription(uint64(m.PromoType))
	}
	if m.DiscountType != 0 {
		n += 1 + sovSubscription(uint64(m.DiscountType))
	}
	if m.DiscountAmount != 0 {
		n += 9
	}
	if m.Conditions != nil {
		l = m.Conditions.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *UpdateGHNOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GhnOrderId)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovSubscription(uint64(m.Action))
	}
	return n
}

func (m *UpdateGHNOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetAdvertisePackageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetAdvertisePackageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Packages) > 0 {
		for _, e := range m.Packages {
			l = e.Size()
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *GetAdvertisePackageResponse_AdvertisePackageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PackageId != 0 {
		n += 1 + sovSubscription(uint64(m.PackageId))
	}
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.PackageItemId)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *GetAdvertisePackageResponse_AdvertisePackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PackageId != 0 {
		n += 1 + sovSubscription(uint64(m.PackageId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovSubscription(uint64(m.Price))
	}
	if len(m.Description) > 0 {
		for _, s := range m.Description {
			l = len(s)
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	if m.Country != 0 {
		n += 1 + sovSubscription(uint64(m.Country))
	}
	if m.PrioritizeLevel != 0 {
		n += 1 + sovSubscription(uint64(m.PrioritizeLevel))
	}
	if len(m.PackageItems) > 0 {
		for _, e := range m.PackageItems {
			l = e.Size()
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func sovSubscription(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSubscription(x uint64) (n int) {
	return sovSubscription(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Plan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Plan{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`AdvertisedPrice:` + fmt.Sprintf("%v", this.AdvertisedPrice) + `,`,
		`IsPurchasable:` + fmt.Sprintf("%v", this.IsPurchasable) + `,`,
		`UpgradeableTo:` + fmt.Sprintf("%v", this.UpgradeableTo) + `,`,
		`Benefits:` + fmt.Sprintf("%v", this.Benefits) + `,`,
		`PrioritizeLevel:` + fmt.Sprintf("%v", this.PrioritizeLevel) + `,`,
		`IsHidden:` + fmt.Sprintf("%v", this.IsHidden) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Package) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPackageItems := "[]*PackageItem{"
	for _, f := range this.PackageItems {
		repeatedStringForPackageItems += strings.Replace(f.String(), "PackageItem", "PackageItem", 1) + ","
	}
	repeatedStringForPackageItems += "}"
	s := strings.Join([]string{`&Package{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`DiscountedPrice:` + fmt.Sprintf("%v", this.DiscountedPrice) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Notice:` + fmt.Sprintf("%v", this.Notice) + `,`,
		`Period:` + strings.Replace(fmt.Sprintf("%v", this.Period), "Timestamp", "types.Timestamp", 1) + `,`,
		`IsRecommended:` + fmt.Sprintf("%v", this.IsRecommended) + `,`,
		`IsEnabled:` + fmt.Sprintf("%v", this.IsEnabled) + `,`,
		`IsHidden:` + fmt.Sprintf("%v", this.IsHidden) + `,`,
		`CarriedOverAmount:` + fmt.Sprintf("%v", this.CarriedOverAmount) + `,`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`PrioritizeLevel:` + fmt.Sprintf("%v", this.PrioritizeLevel) + `,`,
		`PackageItems:` + repeatedStringForPackageItems + `,`,
		`IosBundleId:` + fmt.Sprintf("%v", this.IosBundleId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PackageItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PackageItem{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`ExpiredAt:` + strings.Replace(fmt.Sprintf("%v", this.ExpiredAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Grades:` + fmt.Sprintf("%v", this.Grades) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodOrderInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodOrderInfo{`,
		`CustomerName:` + fmt.Sprintf("%v", this.CustomerName) + `,`,
		`CustomerPhoneNumber:` + fmt.Sprintf("%v", this.CustomerPhoneNumber) + `,`,
		`CustomerAddress:` + fmt.Sprintf("%v", this.CustomerAddress) + `,`,
		`ExpectedDeliveryTime:` + strings.Replace(fmt.Sprintf("%v", this.ExpectedDeliveryTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudentSubscription) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudentSubscription{`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`Grades:` + fmt.Sprintf("%v", this.Grades) + `,`,
		`Subjects:` + fmt.Sprintf("%v", this.Subjects) + `,`,
		`Start:` + strings.Replace(fmt.Sprintf("%v", this.Start), "Timestamp", "types.Timestamp", 1) + `,`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "Timestamp", "types.Timestamp", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubscriptions := "[]*StudentSubscription{"
	for _, f := range this.Subscriptions {
		repeatedStringForSubscriptions += strings.Replace(f.String(), "StudentSubscription", "StudentSubscription", 1) + ","
	}
	repeatedStringForSubscriptions += "}"
	s := strings.Join([]string{`&Order{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Amount:` + fmt.Sprintf("%v", this.Amount) + `,`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`PlanName:` + fmt.Sprintf("%v", this.PlanName) + `,`,
		`ManualCreatedBy:` + fmt.Sprintf("%v", this.ManualCreatedBy) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Coupon:` + fmt.Sprintf("%v", this.Coupon) + `,`,
		`CouponAmount:` + fmt.Sprintf("%v", this.CouponAmount) + `,`,
		`CarriedOverAmount:` + fmt.Sprintf("%v", this.CarriedOverAmount) + `,`,
		`CarriedOverFrom:` + fmt.Sprintf("%v", this.CarriedOverFrom) + `,`,
		`Start:` + strings.Replace(fmt.Sprintf("%v", this.Start), "Timestamp", "types.Timestamp", 1) + `,`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`PaymentMethod:` + fmt.Sprintf("%v", this.PaymentMethod) + `,`,
		`PaymentLink:` + fmt.Sprintf("%v", this.PaymentLink) + `,`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`PackageName:` + fmt.Sprintf("%v", this.PackageName) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`StudentId:` + fmt.Sprintf("%v", this.StudentId) + `,`,
		`ReferenceNumber:` + fmt.Sprintf("%v", this.ReferenceNumber) + `,`,
		`CodOrderInfo:` + strings.Replace(this.CodOrderInfo.String(), "CodOrderInfo", "CodOrderInfo", 1) + `,`,
		`MustPayBefore:` + strings.Replace(fmt.Sprintf("%v", this.MustPayBefore), "Timestamp", "types.Timestamp", 1) + `,`,
		`Subscriptions:` + repeatedStringForSubscriptions + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateAsiaPayOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateAsiaPayOrderRequest{`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`FullResponse:` + fmt.Sprintf("%v", this.FullResponse) + `,`,
		`PaymentMethod:` + fmt.Sprintf("%v", this.PaymentMethod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateAsiaPayOrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateAsiaPayOrderResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Promotion) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*PromotionRule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "PromotionRule", "PromotionRule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&Promotion{`,
		`PromoType:` + fmt.Sprintf("%v", this.PromoType) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`CodePrefix:` + fmt.Sprintf("%v", this.CodePrefix) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`DiscountType:` + fmt.Sprintf("%v", this.DiscountType) + `,`,
		`DiscountAmount:` + fmt.Sprintf("%v", this.DiscountAmount) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`StartedDate:` + strings.Replace(fmt.Sprintf("%v", this.StartedDate), "Timestamp", "types.Timestamp", 1) + `,`,
		`ExpiredDate:` + strings.Replace(fmt.Sprintf("%v", this.ExpiredDate), "Timestamp", "types.Timestamp", 1) + `,`,
		`RedemptionLimitPerCode:` + fmt.Sprintf("%v", this.RedemptionLimitPerCode) + `,`,
		`RedemptionLimitPerUser:` + fmt.Sprintf("%v", this.RedemptionLimitPerUser) + `,`,
		`Notes:` + fmt.Sprintf("%v", this.Notes) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *PromotionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PromotionRule{`,
		`PromoType:` + fmt.Sprintf("%v", this.PromoType) + `,`,
		`DiscountType:` + fmt.Sprintf("%v", this.DiscountType) + `,`,
		`DiscountAmount:` + fmt.Sprintf("%v", this.DiscountAmount) + `,`,
		`Conditions:` + strings.Replace(fmt.Sprintf("%v", this.Conditions), "Struct", "types.Struct", 1) + `,`,
		`Rewards:` + strings.Replace(fmt.Sprintf("%v", this.Rewards), "Struct", "types.Struct", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGHNOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGHNOrderRequest{`,
		`GhnOrderId:` + fmt.Sprintf("%v", this.GhnOrderId) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGHNOrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGHNOrderResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetAdvertisePackageRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAdvertisePackageRequest{`,
		`}`,
	}, "")
	return s
}
func (this *GetAdvertisePackageResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPackages := "[]*GetAdvertisePackageResponse_AdvertisePackage{"
	for _, f := range this.Packages {
		repeatedStringForPackages += strings.Replace(fmt.Sprintf("%v", f), "GetAdvertisePackageResponse_AdvertisePackage", "GetAdvertisePackageResponse_AdvertisePackage", 1) + ","
	}
	repeatedStringForPackages += "}"
	s := strings.Join([]string{`&GetAdvertisePackageResponse{`,
		`Packages:` + repeatedStringForPackages + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAdvertisePackageResponse_AdvertisePackageItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAdvertisePackageResponse_AdvertisePackageItem{`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`PackageItemId:` + fmt.Sprintf("%v", this.PackageItemId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAdvertisePackageResponse_AdvertisePackage) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPackageItems := "[]*GetAdvertisePackageResponse_AdvertisePackageItem{"
	for _, f := range this.PackageItems {
		repeatedStringForPackageItems += strings.Replace(fmt.Sprintf("%v", f), "GetAdvertisePackageResponse_AdvertisePackageItem", "GetAdvertisePackageResponse_AdvertisePackageItem", 1) + ","
	}
	repeatedStringForPackageItems += "}"
	s := strings.Join([]string{`&GetAdvertisePackageResponse_AdvertisePackage{`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`PrioritizeLevel:` + fmt.Sprintf("%v", this.PrioritizeLevel) + `,`,
		`PackageItems:` + repeatedStringForPackageItems + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSubscription(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisedPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisedPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPurchasable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPurchasable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeableTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeableTo = append(m.UpgradeableTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Benefits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Benefits = append(m.Benefits, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizeLevel", wireType)
			}
			m.PrioritizeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrioritizeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Package) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Package: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Package: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountedPrice", wireType)
			}
			m.DiscountedPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountedPrice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = append(m.Description, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Period == nil {
				m.Period = &types.Timestamp{}
			}
			if err := m.Period.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecommended = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnabled = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarriedOverAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CarriedOverAmount = float64(math.Float64frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizeLevel", wireType)
			}
			m.PrioritizeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrioritizeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageItems = append(m.PackageItems, &PackageItem{})
			if err := m.PackageItems[len(m.PackageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IosBundleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IosBundleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiredAt == nil {
				m.ExpiredAt = &types.Timestamp{}
			}
			if err := m.ExpiredAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v Subject
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Subject(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Subject = append(m.Subject, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Subject) == 0 {
					m.Subject = make([]Subject, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Subject
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Subject(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Subject = append(m.Subject, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Grades = append(m.Grades, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Grades) == 0 {
					m.Grades = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Grades = append(m.Grades, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Grades", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodOrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodOrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodOrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerPhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerPhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedDeliveryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpectedDeliveryTime == nil {
				m.ExpectedDeliveryTime = &types.Timestamp{}
			}
			if err := m.ExpectedDeliveryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CodOrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudentSubscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudentSubscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudentSubscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Grades = append(m.Grades, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Grades) == 0 {
					m.Grades = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Grades = append(m.Grades, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Grades", wireType)
			}
		case 3:
			if wireType == 0 {
				var v Subject
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Subject(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Subjects = append(m.Subjects, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Subjects) == 0 {
					m.Subjects = make([]Subject, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Subject
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Subject(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Subjects = append(m.Subjects, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Subjects", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &types.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &types.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SubscriptionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualCreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManualCreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coupon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coupon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CouponAmount = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarriedOverAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CarriedOverAmount = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarriedOverFrom", wireType)
			}
			m.CarriedOverFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarriedOverFrom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &types.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &types.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodOrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodOrderInfo == nil {
				m.CodOrderInfo = &CodOrderInfo{}
			}
			if err := m.CodOrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPayBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MustPayBefore == nil {
				m.MustPayBefore = &types.Timestamp{}
			}
			if err := m.MustPayBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, &StudentSubscription{})
			if err := m.Subscriptions[len(m.Subscriptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAsiaPayOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAsiaPayOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAsiaPayOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullResponse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullResponse = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAsiaPayOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAsiaPayOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAsiaPayOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Promotion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Promotion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Promotion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromoType", wireType)
			}
			m.PromoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromoType |= PromoType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountType", wireType)
			}
			m.DiscountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountType |= PromoDiscountType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiscountAmount = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PromoStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedDate == nil {
				m.StartedDate = &types.Timestamp{}
			}
			if err := m.StartedDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiredDate == nil {
				m.ExpiredDate = &types.Timestamp{}
			}
			if err := m.ExpiredDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionLimitPerCode", wireType)
			}
			m.RedemptionLimitPerCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedemptionLimitPerCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionLimitPerUser", wireType)
			}
			m.RedemptionLimitPerUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedemptionLimitPerUser |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &PromotionRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PromotionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PromotionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PromotionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromoType", wireType)
			}
			m.PromoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromoType |= PromoType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountType", wireType)
			}
			m.DiscountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountType |= PromoDiscountType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiscountAmount = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conditions == nil {
				m.Conditions = &types.Struct{}
			}
			if err := m.Conditions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &types.Struct{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGHNOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGHNOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGHNOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GhnOrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GhnOrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= CodOrderTransitionAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGHNOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGHNOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGHNOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAdvertisePackageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAdvertisePackageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAdvertisePackageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAdvertisePackageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAdvertisePackageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAdvertisePackageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Packages = append(m.Packages, &GetAdvertisePackageResponse_AdvertisePackage{})
			if err := m.Packages[len(m.Packages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAdvertisePackageResponse_AdvertisePackageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertisePackageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertisePackageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageItemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageItemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAdvertisePackageResponse_AdvertisePackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertisePackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertisePackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = append(m.Description, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizeLevel", wireType)
			}
			m.PrioritizeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrioritizeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageItems = append(m.PackageItems, &GetAdvertisePackageResponse_AdvertisePackageItem{})
			if err := m.PackageItems[len(m.PackageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubscription(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSubscription
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSubscription
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSubscription
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSubscription        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubscription          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSubscription = fmt.Errorf("proto: unexpected end of group")
)
