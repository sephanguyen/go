// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ysupload.proto

package pb

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UploadChaptersCsvRequest struct {
	FileName string `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Payload  []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *UploadChaptersCsvRequest) Reset()      { *m = UploadChaptersCsvRequest{} }
func (*UploadChaptersCsvRequest) ProtoMessage() {}
func (*UploadChaptersCsvRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{0}
}
func (m *UploadChaptersCsvRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadChaptersCsvRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadChaptersCsvRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadChaptersCsvRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadChaptersCsvRequest.Merge(m, src)
}
func (m *UploadChaptersCsvRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadChaptersCsvRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadChaptersCsvRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadChaptersCsvRequest proto.InternalMessageInfo

func (m *UploadChaptersCsvRequest) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *UploadChaptersCsvRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type UploadChaptersResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=Successful,proto3" json:"Successful,omitempty"`
}

func (m *UploadChaptersResponse) Reset()      { *m = UploadChaptersResponse{} }
func (*UploadChaptersResponse) ProtoMessage() {}
func (*UploadChaptersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{1}
}
func (m *UploadChaptersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadChaptersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadChaptersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadChaptersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadChaptersResponse.Merge(m, src)
}
func (m *UploadChaptersResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadChaptersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadChaptersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadChaptersResponse proto.InternalMessageInfo

func (m *UploadChaptersResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type UploadCoursesRequest struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *UploadCoursesRequest) Reset()      { *m = UploadCoursesRequest{} }
func (*UploadCoursesRequest) ProtoMessage() {}
func (*UploadCoursesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{2}
}
func (m *UploadCoursesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadCoursesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadCoursesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadCoursesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadCoursesRequest.Merge(m, src)
}
func (m *UploadCoursesRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadCoursesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadCoursesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadCoursesRequest proto.InternalMessageInfo

func (m *UploadCoursesRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type UploadCoursesResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *UploadCoursesResponse) Reset()      { *m = UploadCoursesResponse{} }
func (*UploadCoursesResponse) ProtoMessage() {}
func (*UploadCoursesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{3}
}
func (m *UploadCoursesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadCoursesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadCoursesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadCoursesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadCoursesResponse.Merge(m, src)
}
func (m *UploadCoursesResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadCoursesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadCoursesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadCoursesResponse proto.InternalMessageInfo

func (m *UploadCoursesResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type UploadQuestionsCsvRequest struct {
	FileName string `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Payload  []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *UploadQuestionsCsvRequest) Reset()      { *m = UploadQuestionsCsvRequest{} }
func (*UploadQuestionsCsvRequest) ProtoMessage() {}
func (*UploadQuestionsCsvRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{4}
}
func (m *UploadQuestionsCsvRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadQuestionsCsvRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadQuestionsCsvRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadQuestionsCsvRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadQuestionsCsvRequest.Merge(m, src)
}
func (m *UploadQuestionsCsvRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadQuestionsCsvRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadQuestionsCsvRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadQuestionsCsvRequest proto.InternalMessageInfo

func (m *UploadQuestionsCsvRequest) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *UploadQuestionsCsvRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type UploadQuestionsReponse struct {
	Successful bool `protobuf:"varint,1,opt,name=Successful,proto3" json:"Successful,omitempty"`
}

func (m *UploadQuestionsReponse) Reset()      { *m = UploadQuestionsReponse{} }
func (*UploadQuestionsReponse) ProtoMessage() {}
func (*UploadQuestionsReponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{5}
}
func (m *UploadQuestionsReponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadQuestionsReponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadQuestionsReponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadQuestionsReponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadQuestionsReponse.Merge(m, src)
}
func (m *UploadQuestionsReponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadQuestionsReponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadQuestionsReponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadQuestionsReponse proto.InternalMessageInfo

func (m *UploadQuestionsReponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type UploadQuizSetsRequest struct {
	FileName string `protobuf:"bytes,1,opt,name=fileName,proto3" json:"fileName,omitempty"`
	Payload  []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *UploadQuizSetsRequest) Reset()      { *m = UploadQuizSetsRequest{} }
func (*UploadQuizSetsRequest) ProtoMessage() {}
func (*UploadQuizSetsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{6}
}
func (m *UploadQuizSetsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadQuizSetsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadQuizSetsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadQuizSetsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadQuizSetsRequest.Merge(m, src)
}
func (m *UploadQuizSetsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadQuizSetsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadQuizSetsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadQuizSetsRequest proto.InternalMessageInfo

func (m *UploadQuizSetsRequest) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *UploadQuizSetsRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type UploadQuizSetsResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *UploadQuizSetsResponse) Reset()      { *m = UploadQuizSetsResponse{} }
func (*UploadQuizSetsResponse) ProtoMessage() {}
func (*UploadQuizSetsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{7}
}
func (m *UploadQuizSetsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadQuizSetsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadQuizSetsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadQuizSetsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadQuizSetsResponse.Merge(m, src)
}
func (m *UploadQuizSetsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadQuizSetsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadQuizSetsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadQuizSetsResponse proto.InternalMessageInfo

func (m *UploadQuizSetsResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type UploadCoursesV2Request struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *UploadCoursesV2Request) Reset()      { *m = UploadCoursesV2Request{} }
func (*UploadCoursesV2Request) ProtoMessage() {}
func (*UploadCoursesV2Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{8}
}
func (m *UploadCoursesV2Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadCoursesV2Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadCoursesV2Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadCoursesV2Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadCoursesV2Request.Merge(m, src)
}
func (m *UploadCoursesV2Request) XXX_Size() int {
	return m.Size()
}
func (m *UploadCoursesV2Request) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadCoursesV2Request.DiscardUnknown(m)
}

var xxx_messageInfo_UploadCoursesV2Request proto.InternalMessageInfo

func (m *UploadCoursesV2Request) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type UploadCoursesV2Response struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *UploadCoursesV2Response) Reset()      { *m = UploadCoursesV2Response{} }
func (*UploadCoursesV2Response) ProtoMessage() {}
func (*UploadCoursesV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{9}
}
func (m *UploadCoursesV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadCoursesV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadCoursesV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadCoursesV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadCoursesV2Response.Merge(m, src)
}
func (m *UploadCoursesV2Response) XXX_Size() int {
	return m.Size()
}
func (m *UploadCoursesV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadCoursesV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_UploadCoursesV2Response proto.InternalMessageInfo

func (m *UploadCoursesV2Response) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type UploadBooksRequest struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *UploadBooksRequest) Reset()      { *m = UploadBooksRequest{} }
func (*UploadBooksRequest) ProtoMessage() {}
func (*UploadBooksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{10}
}
func (m *UploadBooksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadBooksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadBooksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadBooksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadBooksRequest.Merge(m, src)
}
func (m *UploadBooksRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadBooksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadBooksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadBooksRequest proto.InternalMessageInfo

func (m *UploadBooksRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type UploadBooksResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *UploadBooksResponse) Reset()      { *m = UploadBooksResponse{} }
func (*UploadBooksResponse) ProtoMessage() {}
func (*UploadBooksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d6d8dfa5130b36, []int{11}
}
func (m *UploadBooksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadBooksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadBooksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadBooksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadBooksResponse.Merge(m, src)
}
func (m *UploadBooksResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadBooksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadBooksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadBooksResponse proto.InternalMessageInfo

func (m *UploadBooksResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

func init() {
	proto.RegisterType((*UploadChaptersCsvRequest)(nil), "manabie.yasuo.UploadChaptersCsvRequest")
	golang_proto.RegisterType((*UploadChaptersCsvRequest)(nil), "manabie.yasuo.UploadChaptersCsvRequest")
	proto.RegisterType((*UploadChaptersResponse)(nil), "manabie.yasuo.UploadChaptersResponse")
	golang_proto.RegisterType((*UploadChaptersResponse)(nil), "manabie.yasuo.UploadChaptersResponse")
	proto.RegisterType((*UploadCoursesRequest)(nil), "manabie.yasuo.UploadCoursesRequest")
	golang_proto.RegisterType((*UploadCoursesRequest)(nil), "manabie.yasuo.UploadCoursesRequest")
	proto.RegisterType((*UploadCoursesResponse)(nil), "manabie.yasuo.UploadCoursesResponse")
	golang_proto.RegisterType((*UploadCoursesResponse)(nil), "manabie.yasuo.UploadCoursesResponse")
	proto.RegisterType((*UploadQuestionsCsvRequest)(nil), "manabie.yasuo.UploadQuestionsCsvRequest")
	golang_proto.RegisterType((*UploadQuestionsCsvRequest)(nil), "manabie.yasuo.UploadQuestionsCsvRequest")
	proto.RegisterType((*UploadQuestionsReponse)(nil), "manabie.yasuo.UploadQuestionsReponse")
	golang_proto.RegisterType((*UploadQuestionsReponse)(nil), "manabie.yasuo.UploadQuestionsReponse")
	proto.RegisterType((*UploadQuizSetsRequest)(nil), "manabie.yasuo.UploadQuizSetsRequest")
	golang_proto.RegisterType((*UploadQuizSetsRequest)(nil), "manabie.yasuo.UploadQuizSetsRequest")
	proto.RegisterType((*UploadQuizSetsResponse)(nil), "manabie.yasuo.UploadQuizSetsResponse")
	golang_proto.RegisterType((*UploadQuizSetsResponse)(nil), "manabie.yasuo.UploadQuizSetsResponse")
	proto.RegisterType((*UploadCoursesV2Request)(nil), "manabie.yasuo.UploadCoursesV2Request")
	golang_proto.RegisterType((*UploadCoursesV2Request)(nil), "manabie.yasuo.UploadCoursesV2Request")
	proto.RegisterType((*UploadCoursesV2Response)(nil), "manabie.yasuo.UploadCoursesV2Response")
	golang_proto.RegisterType((*UploadCoursesV2Response)(nil), "manabie.yasuo.UploadCoursesV2Response")
	proto.RegisterType((*UploadBooksRequest)(nil), "manabie.yasuo.UploadBooksRequest")
	golang_proto.RegisterType((*UploadBooksRequest)(nil), "manabie.yasuo.UploadBooksRequest")
	proto.RegisterType((*UploadBooksResponse)(nil), "manabie.yasuo.UploadBooksResponse")
	golang_proto.RegisterType((*UploadBooksResponse)(nil), "manabie.yasuo.UploadBooksResponse")
}

func init() { proto.RegisterFile("ysupload.proto", fileDescriptor_41d6d8dfa5130b36) }
func init() { golang_proto.RegisterFile("ysupload.proto", fileDescriptor_41d6d8dfa5130b36) }

var fileDescriptor_41d6d8dfa5130b36 = []byte{
	// 513 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0x3d, 0x6f, 0xd3, 0x40,
	0x18, 0xf6, 0x21, 0x04, 0xe5, 0xa0, 0x20, 0x8e, 0xaf, 0xe0, 0xe1, 0x54, 0x4c, 0x0b, 0x5e, 0xea,
	0xa0, 0x00, 0x02, 0xc4, 0xd6, 0xce, 0x20, 0xe2, 0x88, 0x0e, 0x88, 0xe5, 0xec, 0xbe, 0x71, 0xad,
	0x24, 0x3e, 0x93, 0xf3, 0x55, 0x0a, 0x13, 0x3f, 0x81, 0x9f, 0xc1, 0xcf, 0x60, 0x64, 0xcc, 0xd8,
	0x05, 0x89, 0x38, 0x0b, 0x63, 0x7f, 0x42, 0x95, 0x73, 0xce, 0xb5, 0xf3, 0xe1, 0x7a, 0xe8, 0x76,
	0xef, 0xe9, 0x7d, 0x9e, 0xe7, 0xfd, 0x78, 0xee, 0xf0, 0xed, 0x91, 0x90, 0x71, 0x9f, 0xb3, 0x43,
	0x27, 0x1e, 0xf2, 0x84, 0x93, 0xcd, 0x01, 0x8b, 0x98, 0x17, 0x82, 0x33, 0x62, 0x42, 0x72, 0x73,
	0x37, 0x08, 0x93, 0x23, 0xe9, 0x39, 0x3e, 0x1f, 0x34, 0x03, 0x1e, 0xf0, 0xa6, 0xca, 0xf2, 0x64,
	0x57, 0x45, 0x2a, 0x50, 0xa7, 0x0c, 0x6d, 0x7d, 0xc2, 0x8d, 0xcf, 0x8a, 0x6d, 0xff, 0x88, 0xc5,
	0x09, 0x0c, 0xc5, 0xbe, 0x38, 0x76, 0xe1, 0x9b, 0x04, 0x91, 0x10, 0x13, 0x6f, 0x74, 0xc3, 0x3e,
	0x7c, 0x64, 0x03, 0x68, 0xa0, 0x2d, 0x64, 0xdf, 0x70, 0xf3, 0x98, 0x34, 0xf0, 0xf5, 0x98, 0x8d,
	0x66, 0xc0, 0xc6, 0x95, 0x2d, 0x64, 0xdf, 0x72, 0x75, 0x68, 0xbd, 0xc5, 0x0f, 0xcb, 0x8c, 0x2e,
	0x88, 0x98, 0x47, 0x02, 0x08, 0xc5, 0xb8, 0x23, 0x7d, 0x1f, 0x84, 0xe8, 0xca, 0xbe, 0x62, 0xdc,
	0x70, 0x0b, 0x37, 0xd6, 0x0b, 0x7c, 0x7f, 0x8e, 0xe4, 0x72, 0x28, 0x40, 0xe8, 0x3a, 0x0a, 0x5a,
	0xa8, 0xac, 0xf5, 0x06, 0x3f, 0x58, 0x40, 0x9c, 0x4b, 0x89, 0x25, 0xa9, 0xf3, 0x1b, 0xab, 0x8d,
	0x1f, 0x67, 0xc0, 0xf6, 0x4c, 0x21, 0xe4, 0xd1, 0x25, 0xf6, 0x9d, 0x53, 0xba, 0x50, 0xaf, 0xef,
	0x0f, 0xba, 0x8b, 0xb6, 0x0c, 0xbf, 0x77, 0x20, 0x11, 0x97, 0x56, 0x88, 0xa6, 0xab, 0x39, 0x95,
	0x56, 0xbe, 0xba, 0x6c, 0x9c, 0x07, 0xad, 0x8b, 0x57, 0xf0, 0x0e, 0x3f, 0x5a, 0xc2, 0xd4, 0x94,
	0x73, 0x30, 0xc9, 0xa0, 0x7b, 0x9c, 0xf7, 0x6a, 0x6c, 0xfb, 0x35, 0xbe, 0x57, 0xca, 0xaf, 0x27,
	0xd3, 0xfa, 0x7b, 0x15, 0x6f, 0x66, 0xb8, 0x0e, 0x0c, 0x8f, 0x43, 0x1f, 0x08, 0xe0, 0xbb, 0x4b,
	0xa6, 0x27, 0xcf, 0x9d, 0xd2, 0x43, 0x72, 0xd6, 0x3d, 0x0b, 0x73, 0xa7, 0x32, 0x51, 0x97, 0x65,
	0x23, 0xf2, 0x55, 0xeb, 0xce, 0x47, 0x43, 0x9e, 0xae, 0x46, 0x96, 0xdc, 0x6e, 0x6e, 0x57, 0x27,
	0xe5, 0xec, 0x81, 0x9e, 0x5e, 0xd1, 0xc2, 0xc4, 0x5e, 0x89, 0x5e, 0xe1, 0xf2, 0x35, 0x6d, 0x2c,
	0x9a, 0xd7, 0x46, 0xc4, 0xd3, 0xd3, 0xd2, 0x7e, 0x9a, 0xe9, 0x6c, 0xaf, 0x41, 0x97, 0x0c, 0xbc,
	0x56, 0xa3, 0xec, 0x4b, 0xa5, 0x71, 0x67, 0xc1, 0x45, 0x64, 0xa7, 0x6a, 0x0e, 0xb9, 0x33, 0xcd,
	0x67, 0x17, 0xa5, 0xe5, 0x1a, 0x07, 0xf8, 0x66, 0xc1, 0x3e, 0xe4, 0xc9, 0x4a, 0x60, 0xd1, 0x8a,
	0xa6, 0x55, 0x95, 0xa2, 0x79, 0xf7, 0xa2, 0xf1, 0x84, 0x1a, 0x27, 0x13, 0x6a, 0x9c, 0x4e, 0x28,
	0xfa, 0x91, 0x52, 0xf4, 0x2b, 0xa5, 0xe8, 0x4f, 0x4a, 0xd1, 0x38, 0xa5, 0xe8, 0x5f, 0x4a, 0xd1,
	0xff, 0x94, 0x1a, 0xa7, 0x29, 0x45, 0x3f, 0xa7, 0xd4, 0xf8, 0x3d, 0xa5, 0x68, 0x3c, 0xa5, 0xc6,
	0xc9, 0x94, 0x1a, 0x5f, 0x5e, 0x15, 0xfe, 0xea, 0xb9, 0xd2, 0xee, 0xec, 0xec, 0x31, 0xbf, 0x07,
	0xd1, 0x61, 0x33, 0xee, 0x05, 0xcd, 0x00, 0xa2, 0xec, 0xd3, 0x56, 0x25, 0xbc, 0x8f, 0x3d, 0xef,
	0x9a, 0x8a, 0x5f, 0x9e, 0x05, 0x00, 0x00, 0xff, 0xff, 0xce, 0x2c, 0x1c, 0x45, 0x09, 0x06, 0x00,
	0x00,
}

func (this *UploadChaptersCsvRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadChaptersCsvRequest)
	if !ok {
		that2, ok := that.(UploadChaptersCsvRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *UploadChaptersResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadChaptersResponse)
	if !ok {
		that2, ok := that.(UploadChaptersResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *UploadCoursesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadCoursesRequest)
	if !ok {
		that2, ok := that.(UploadCoursesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *UploadCoursesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadCoursesResponse)
	if !ok {
		that2, ok := that.(UploadCoursesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *UploadQuestionsCsvRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadQuestionsCsvRequest)
	if !ok {
		that2, ok := that.(UploadQuestionsCsvRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *UploadQuestionsReponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadQuestionsReponse)
	if !ok {
		that2, ok := that.(UploadQuestionsReponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *UploadQuizSetsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadQuizSetsRequest)
	if !ok {
		that2, ok := that.(UploadQuizSetsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *UploadQuizSetsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadQuizSetsResponse)
	if !ok {
		that2, ok := that.(UploadQuizSetsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *UploadCoursesV2Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadCoursesV2Request)
	if !ok {
		that2, ok := that.(UploadCoursesV2Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *UploadCoursesV2Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadCoursesV2Response)
	if !ok {
		that2, ok := that.(UploadCoursesV2Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *UploadBooksRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadBooksRequest)
	if !ok {
		that2, ok := that.(UploadBooksRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *UploadBooksResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadBooksResponse)
	if !ok {
		that2, ok := that.(UploadBooksResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *UploadChaptersCsvRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.UploadChaptersCsvRequest{")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadChaptersResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadChaptersResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadCoursesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadCoursesRequest{")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadCoursesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadCoursesResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadQuestionsCsvRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.UploadQuestionsCsvRequest{")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadQuestionsReponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadQuestionsReponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadQuizSetsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.UploadQuizSetsRequest{")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadQuizSetsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadQuizSetsResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadCoursesV2Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadCoursesV2Request{")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadCoursesV2Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadCoursesV2Response{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadBooksRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadBooksRequest{")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadBooksResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.UploadBooksResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringYsupload(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UploadServiceClient is the client API for UploadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UploadServiceClient interface {
	UploadChaptersCsv(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadChaptersCsvClient, error)
	UploadCourses(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadCoursesClient, error)
	UploadQuestionsCsv(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadQuestionsCsvClient, error)
	UploadQuizSetsCsv(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadQuizSetsCsvClient, error)
	UploadCoursesV2(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadCoursesV2Client, error)
	UploadBooks(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadBooksClient, error)
}

type uploadServiceClient struct {
	cc *grpc.ClientConn
}

func NewUploadServiceClient(cc *grpc.ClientConn) UploadServiceClient {
	return &uploadServiceClient{cc}
}

func (c *uploadServiceClient) UploadChaptersCsv(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadChaptersCsvClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UploadService_serviceDesc.Streams[0], "/manabie.yasuo.UploadService/UploadChaptersCsv", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadServiceUploadChaptersCsvClient{stream}
	return x, nil
}

type UploadService_UploadChaptersCsvClient interface {
	Send(*UploadChaptersCsvRequest) error
	CloseAndRecv() (*UploadChaptersResponse, error)
	grpc.ClientStream
}

type uploadServiceUploadChaptersCsvClient struct {
	grpc.ClientStream
}

func (x *uploadServiceUploadChaptersCsvClient) Send(m *UploadChaptersCsvRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadServiceUploadChaptersCsvClient) CloseAndRecv() (*UploadChaptersResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadChaptersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadServiceClient) UploadCourses(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadCoursesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UploadService_serviceDesc.Streams[1], "/manabie.yasuo.UploadService/UploadCourses", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadServiceUploadCoursesClient{stream}
	return x, nil
}

type UploadService_UploadCoursesClient interface {
	Send(*UploadCoursesRequest) error
	CloseAndRecv() (*UploadCoursesResponse, error)
	grpc.ClientStream
}

type uploadServiceUploadCoursesClient struct {
	grpc.ClientStream
}

func (x *uploadServiceUploadCoursesClient) Send(m *UploadCoursesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadServiceUploadCoursesClient) CloseAndRecv() (*UploadCoursesResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadCoursesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadServiceClient) UploadQuestionsCsv(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadQuestionsCsvClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UploadService_serviceDesc.Streams[2], "/manabie.yasuo.UploadService/UploadQuestionsCsv", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadServiceUploadQuestionsCsvClient{stream}
	return x, nil
}

type UploadService_UploadQuestionsCsvClient interface {
	Send(*UploadQuestionsCsvRequest) error
	CloseAndRecv() (*UploadQuestionsReponse, error)
	grpc.ClientStream
}

type uploadServiceUploadQuestionsCsvClient struct {
	grpc.ClientStream
}

func (x *uploadServiceUploadQuestionsCsvClient) Send(m *UploadQuestionsCsvRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadServiceUploadQuestionsCsvClient) CloseAndRecv() (*UploadQuestionsReponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadQuestionsReponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadServiceClient) UploadQuizSetsCsv(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadQuizSetsCsvClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UploadService_serviceDesc.Streams[3], "/manabie.yasuo.UploadService/UploadQuizSetsCsv", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadServiceUploadQuizSetsCsvClient{stream}
	return x, nil
}

type UploadService_UploadQuizSetsCsvClient interface {
	Send(*UploadQuizSetsRequest) error
	CloseAndRecv() (*UploadQuizSetsResponse, error)
	grpc.ClientStream
}

type uploadServiceUploadQuizSetsCsvClient struct {
	grpc.ClientStream
}

func (x *uploadServiceUploadQuizSetsCsvClient) Send(m *UploadQuizSetsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadServiceUploadQuizSetsCsvClient) CloseAndRecv() (*UploadQuizSetsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadQuizSetsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadServiceClient) UploadCoursesV2(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadCoursesV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_UploadService_serviceDesc.Streams[4], "/manabie.yasuo.UploadService/UploadCoursesV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadServiceUploadCoursesV2Client{stream}
	return x, nil
}

type UploadService_UploadCoursesV2Client interface {
	Send(*UploadCoursesV2Request) error
	CloseAndRecv() (*UploadCoursesV2Response, error)
	grpc.ClientStream
}

type uploadServiceUploadCoursesV2Client struct {
	grpc.ClientStream
}

func (x *uploadServiceUploadCoursesV2Client) Send(m *UploadCoursesV2Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadServiceUploadCoursesV2Client) CloseAndRecv() (*UploadCoursesV2Response, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadCoursesV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *uploadServiceClient) UploadBooks(ctx context.Context, opts ...grpc.CallOption) (UploadService_UploadBooksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UploadService_serviceDesc.Streams[5], "/manabie.yasuo.UploadService/UploadBooks", opts...)
	if err != nil {
		return nil, err
	}
	x := &uploadServiceUploadBooksClient{stream}
	return x, nil
}

type UploadService_UploadBooksClient interface {
	Send(*UploadBooksRequest) error
	CloseAndRecv() (*UploadBooksResponse, error)
	grpc.ClientStream
}

type uploadServiceUploadBooksClient struct {
	grpc.ClientStream
}

func (x *uploadServiceUploadBooksClient) Send(m *UploadBooksRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *uploadServiceUploadBooksClient) CloseAndRecv() (*UploadBooksResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadBooksResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UploadServiceServer is the server API for UploadService service.
type UploadServiceServer interface {
	UploadChaptersCsv(UploadService_UploadChaptersCsvServer) error
	UploadCourses(UploadService_UploadCoursesServer) error
	UploadQuestionsCsv(UploadService_UploadQuestionsCsvServer) error
	UploadQuizSetsCsv(UploadService_UploadQuizSetsCsvServer) error
	UploadCoursesV2(UploadService_UploadCoursesV2Server) error
	UploadBooks(UploadService_UploadBooksServer) error
}

// UnimplementedUploadServiceServer can be embedded to have forward compatible implementations.
type UnimplementedUploadServiceServer struct {
}

func (*UnimplementedUploadServiceServer) UploadChaptersCsv(srv UploadService_UploadChaptersCsvServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadChaptersCsv not implemented")
}
func (*UnimplementedUploadServiceServer) UploadCourses(srv UploadService_UploadCoursesServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadCourses not implemented")
}
func (*UnimplementedUploadServiceServer) UploadQuestionsCsv(srv UploadService_UploadQuestionsCsvServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadQuestionsCsv not implemented")
}
func (*UnimplementedUploadServiceServer) UploadQuizSetsCsv(srv UploadService_UploadQuizSetsCsvServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadQuizSetsCsv not implemented")
}
func (*UnimplementedUploadServiceServer) UploadCoursesV2(srv UploadService_UploadCoursesV2Server) error {
	return status.Errorf(codes.Unimplemented, "method UploadCoursesV2 not implemented")
}
func (*UnimplementedUploadServiceServer) UploadBooks(srv UploadService_UploadBooksServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadBooks not implemented")
}

func RegisterUploadServiceServer(s *grpc.Server, srv UploadServiceServer) {
	s.RegisterService(&_UploadService_serviceDesc, srv)
}

func _UploadService_UploadChaptersCsv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServiceServer).UploadChaptersCsv(&uploadServiceUploadChaptersCsvServer{stream})
}

type UploadService_UploadChaptersCsvServer interface {
	SendAndClose(*UploadChaptersResponse) error
	Recv() (*UploadChaptersCsvRequest, error)
	grpc.ServerStream
}

type uploadServiceUploadChaptersCsvServer struct {
	grpc.ServerStream
}

func (x *uploadServiceUploadChaptersCsvServer) SendAndClose(m *UploadChaptersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadServiceUploadChaptersCsvServer) Recv() (*UploadChaptersCsvRequest, error) {
	m := new(UploadChaptersCsvRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UploadService_UploadCourses_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServiceServer).UploadCourses(&uploadServiceUploadCoursesServer{stream})
}

type UploadService_UploadCoursesServer interface {
	SendAndClose(*UploadCoursesResponse) error
	Recv() (*UploadCoursesRequest, error)
	grpc.ServerStream
}

type uploadServiceUploadCoursesServer struct {
	grpc.ServerStream
}

func (x *uploadServiceUploadCoursesServer) SendAndClose(m *UploadCoursesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadServiceUploadCoursesServer) Recv() (*UploadCoursesRequest, error) {
	m := new(UploadCoursesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UploadService_UploadQuestionsCsv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServiceServer).UploadQuestionsCsv(&uploadServiceUploadQuestionsCsvServer{stream})
}

type UploadService_UploadQuestionsCsvServer interface {
	SendAndClose(*UploadQuestionsReponse) error
	Recv() (*UploadQuestionsCsvRequest, error)
	grpc.ServerStream
}

type uploadServiceUploadQuestionsCsvServer struct {
	grpc.ServerStream
}

func (x *uploadServiceUploadQuestionsCsvServer) SendAndClose(m *UploadQuestionsReponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadServiceUploadQuestionsCsvServer) Recv() (*UploadQuestionsCsvRequest, error) {
	m := new(UploadQuestionsCsvRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UploadService_UploadQuizSetsCsv_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServiceServer).UploadQuizSetsCsv(&uploadServiceUploadQuizSetsCsvServer{stream})
}

type UploadService_UploadQuizSetsCsvServer interface {
	SendAndClose(*UploadQuizSetsResponse) error
	Recv() (*UploadQuizSetsRequest, error)
	grpc.ServerStream
}

type uploadServiceUploadQuizSetsCsvServer struct {
	grpc.ServerStream
}

func (x *uploadServiceUploadQuizSetsCsvServer) SendAndClose(m *UploadQuizSetsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadServiceUploadQuizSetsCsvServer) Recv() (*UploadQuizSetsRequest, error) {
	m := new(UploadQuizSetsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UploadService_UploadCoursesV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServiceServer).UploadCoursesV2(&uploadServiceUploadCoursesV2Server{stream})
}

type UploadService_UploadCoursesV2Server interface {
	SendAndClose(*UploadCoursesV2Response) error
	Recv() (*UploadCoursesV2Request, error)
	grpc.ServerStream
}

type uploadServiceUploadCoursesV2Server struct {
	grpc.ServerStream
}

func (x *uploadServiceUploadCoursesV2Server) SendAndClose(m *UploadCoursesV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadServiceUploadCoursesV2Server) Recv() (*UploadCoursesV2Request, error) {
	m := new(UploadCoursesV2Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UploadService_UploadBooks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UploadServiceServer).UploadBooks(&uploadServiceUploadBooksServer{stream})
}

type UploadService_UploadBooksServer interface {
	SendAndClose(*UploadBooksResponse) error
	Recv() (*UploadBooksRequest, error)
	grpc.ServerStream
}

type uploadServiceUploadBooksServer struct {
	grpc.ServerStream
}

func (x *uploadServiceUploadBooksServer) SendAndClose(m *UploadBooksResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *uploadServiceUploadBooksServer) Recv() (*UploadBooksRequest, error) {
	m := new(UploadBooksRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _UploadService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "manabie.yasuo.UploadService",
	HandlerType: (*UploadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadChaptersCsv",
			Handler:       _UploadService_UploadChaptersCsv_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadCourses",
			Handler:       _UploadService_UploadCourses_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadQuestionsCsv",
			Handler:       _UploadService_UploadQuestionsCsv_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadQuizSetsCsv",
			Handler:       _UploadService_UploadQuizSetsCsv_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadCoursesV2",
			Handler:       _UploadService_UploadCoursesV2_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadBooks",
			Handler:       _UploadService_UploadBooks_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "ysupload.proto",
}

func (m *UploadChaptersCsvRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadChaptersCsvRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadChaptersCsvRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadChaptersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadChaptersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadChaptersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadCoursesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadCoursesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadCoursesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadCoursesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadCoursesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadCoursesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadQuestionsCsvRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadQuestionsCsvRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadQuestionsCsvRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadQuestionsReponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadQuestionsReponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadQuestionsReponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadQuizSetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadQuizSetsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadQuizSetsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadQuizSetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadQuizSetsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadQuizSetsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadCoursesV2Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadCoursesV2Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadCoursesV2Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadCoursesV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadCoursesV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadCoursesV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadBooksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadBooksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadBooksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintYsupload(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadBooksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadBooksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadBooksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintYsupload(dAtA []byte, offset int, v uint64) int {
	offset -= sovYsupload(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UploadChaptersCsvRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	return n
}

func (m *UploadChaptersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *UploadCoursesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	return n
}

func (m *UploadCoursesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *UploadQuestionsCsvRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	return n
}

func (m *UploadQuestionsReponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *UploadQuizSetsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	return n
}

func (m *UploadQuizSetsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *UploadCoursesV2Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	return n
}

func (m *UploadCoursesV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *UploadBooksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovYsupload(uint64(l))
	}
	return n
}

func (m *UploadBooksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func sovYsupload(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozYsupload(x uint64) (n int) {
	return sovYsupload(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UploadChaptersCsvRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadChaptersCsvRequest{`,
		`FileName:` + fmt.Sprintf("%v", this.FileName) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadChaptersResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadChaptersResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadCoursesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadCoursesRequest{`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadCoursesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadCoursesResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadQuestionsCsvRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadQuestionsCsvRequest{`,
		`FileName:` + fmt.Sprintf("%v", this.FileName) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadQuestionsReponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadQuestionsReponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadQuizSetsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadQuizSetsRequest{`,
		`FileName:` + fmt.Sprintf("%v", this.FileName) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadQuizSetsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadQuizSetsResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadCoursesV2Request) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadCoursesV2Request{`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadCoursesV2Response) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadCoursesV2Response{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadBooksRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadBooksRequest{`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadBooksResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadBooksResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringYsupload(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UploadChaptersCsvRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadChaptersCsvRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadChaptersCsvRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadChaptersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadChaptersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadChaptersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadCoursesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadCoursesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadCoursesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadCoursesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadCoursesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadCoursesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadQuestionsCsvRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadQuestionsCsvRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadQuestionsCsvRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadQuestionsReponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadQuestionsReponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadQuestionsReponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadQuizSetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadQuizSetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadQuizSetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadQuizSetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadQuizSetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadQuizSetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadCoursesV2Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadCoursesV2Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadCoursesV2Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadCoursesV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadCoursesV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadCoursesV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadBooksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadBooksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadBooksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthYsupload
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthYsupload
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadBooksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadBooksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadBooksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYsupload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYsupload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipYsupload(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowYsupload
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowYsupload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthYsupload
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupYsupload
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthYsupload
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthYsupload        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowYsupload          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupYsupload = fmt.Errorf("proto: unexpected end of group")
)
