// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: yssubscription.proto

package pb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	bob "github.com/manabie-com/backend/pkg/genproto/bob"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PromoType int32

const (
	PROMOTION            PromoType = 0
	PROMOTION_TEACHER    PromoType = 1
	PROMOTION_REFERRAL   PromoType = 2
	PROMOTION_LD         PromoType = 3
	PROMOTION_SC         PromoType = 4
	PROMOTION_KOL        PromoType = 5
	PROMOTION_ACTIVATION PromoType = 6
)

var PromoType_name = map[int32]string{
	0: "PROMOTION",
	1: "PROMOTION_TEACHER",
	2: "PROMOTION_REFERRAL",
	3: "PROMOTION_LD",
	4: "PROMOTION_SC",
	5: "PROMOTION_KOL",
	6: "PROMOTION_ACTIVATION",
}

var PromoType_value = map[string]int32{
	"PROMOTION":            0,
	"PROMOTION_TEACHER":    1,
	"PROMOTION_REFERRAL":   2,
	"PROMOTION_LD":         3,
	"PROMOTION_SC":         4,
	"PROMOTION_KOL":        5,
	"PROMOTION_ACTIVATION": 6,
}

func (PromoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{0}
}

type PromoDiscountType int32

const (
	PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT PromoDiscountType = 0
	PROMOTION_DISCOUNT_TYPE_PERCENTAGE   PromoDiscountType = 1
)

var PromoDiscountType_name = map[int32]string{
	0: "PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT",
	1: "PROMOTION_DISCOUNT_TYPE_PERCENTAGE",
}

var PromoDiscountType_value = map[string]int32{
	"PROMOTION_DISCOUNT_TYPE_FIXED_AMOUNT": 0,
	"PROMOTION_DISCOUNT_TYPE_PERCENTAGE":   1,
}

func (PromoDiscountType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{1}
}

type PromoStatus int32

const (
	PROMOTION_STATUS_PUBLISHED PromoStatus = 0
	PROMOTION_STATUS_ARCHIVED  PromoStatus = 1
)

var PromoStatus_name = map[int32]string{
	0: "PROMOTION_STATUS_PUBLISHED",
	1: "PROMOTION_STATUS_ARCHIVED",
}

var PromoStatus_value = map[string]int32{
	"PROMOTION_STATUS_PUBLISHED": 0,
	"PROMOTION_STATUS_ARCHIVED":  1,
}

func (PromoStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{2}
}

type Plan struct {
	Id              string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Description     string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	AdvertisedPrice string   `protobuf:"bytes,3,opt,name=advertised_price,json=advertisedPrice,proto3" json:"advertised_price,omitempty"` // Deprecated: Do not use.
	IsPurchasable   bool     `protobuf:"varint,4,opt,name=is_purchasable,json=isPurchasable,proto3" json:"is_purchasable,omitempty"`
	UpgradeableTo   []string `protobuf:"bytes,5,rep,name=upgradeable_to,json=upgradeableTo,proto3" json:"upgradeable_to,omitempty"` // Deprecated: Do not use.
	Benefits        []string `protobuf:"bytes,6,rep,name=benefits,proto3" json:"benefits,omitempty"`
	PrioritizeLevel int32    `protobuf:"varint,7,opt,name=prioritize_level,json=prioritizeLevel,proto3" json:"prioritize_level,omitempty"`
	IsHidden        bool     `protobuf:"varint,8,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"` // Deprecated: Do not use.
}

func (m *Plan) Reset()      { *m = Plan{} }
func (*Plan) ProtoMessage() {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{0}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.Size()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Plan) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Deprecated: Do not use.
func (m *Plan) GetAdvertisedPrice() string {
	if m != nil {
		return m.AdvertisedPrice
	}
	return ""
}

func (m *Plan) GetIsPurchasable() bool {
	if m != nil {
		return m.IsPurchasable
	}
	return false
}

// Deprecated: Do not use.
func (m *Plan) GetUpgradeableTo() []string {
	if m != nil {
		return m.UpgradeableTo
	}
	return nil
}

func (m *Plan) GetBenefits() []string {
	if m != nil {
		return m.Benefits
	}
	return nil
}

func (m *Plan) GetPrioritizeLevel() int32 {
	if m != nil {
		return m.PrioritizeLevel
	}
	return 0
}

// Deprecated: Do not use.
func (m *Plan) GetIsHidden() bool {
	if m != nil {
		return m.IsHidden
	}
	return false
}

type Package struct {
	Id                int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name              string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Price             int32            `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
	DiscountedPrice   int32            `protobuf:"varint,4,opt,name=discounted_price,json=discountedPrice,proto3" json:"discounted_price,omitempty"`
	Description       []string         `protobuf:"bytes,5,rep,name=description,proto3" json:"description,omitempty"`
	Notice            string           `protobuf:"bytes,6,opt,name=notice,proto3" json:"notice,omitempty"`
	Period            *types.Timestamp `protobuf:"bytes,7,opt,name=period,proto3" json:"period,omitempty"`
	IsRecommended     bool             `protobuf:"varint,8,opt,name=is_recommended,json=isRecommended,proto3" json:"is_recommended,omitempty"`
	IsEnabled         bool             `protobuf:"varint,9,opt,name=is_enabled,json=isEnabled,proto3" json:"is_enabled,omitempty"`
	IsHidden          bool             `protobuf:"varint,10,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"`                               // Deprecated: Do not use.
	CarriedOverAmount float64          `protobuf:"fixed64,11,opt,name=carried_over_amount,json=carriedOverAmount,proto3" json:"carried_over_amount,omitempty"` // Deprecated: Do not use.
	PlanId            string           `protobuf:"bytes,12,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`                                      // Deprecated: Do not use.
	Country           bob.Country      `protobuf:"varint,13,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
	PrioritizeLevel   int32            `protobuf:"varint,14,opt,name=prioritize_level,json=prioritizeLevel,proto3" json:"prioritize_level,omitempty"`
	PackageItems      []*PackageItem   `protobuf:"bytes,15,rep,name=package_items,json=packageItems,proto3" json:"package_items,omitempty"`
	UpgradableFrom    []int32          `protobuf:"varint,16,rep,packed,name=upgradable_from,json=upgradableFrom,proto3" json:"upgradable_from,omitempty"`
}

func (m *Package) Reset()      { *m = Package{} }
func (*Package) ProtoMessage() {}
func (*Package) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{1}
}
func (m *Package) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Package) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Package.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Package) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Package.Merge(m, src)
}
func (m *Package) XXX_Size() int {
	return m.Size()
}
func (m *Package) XXX_DiscardUnknown() {
	xxx_messageInfo_Package.DiscardUnknown(m)
}

var xxx_messageInfo_Package proto.InternalMessageInfo

func (m *Package) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Package) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Package) GetDiscountedPrice() int32 {
	if m != nil {
		return m.DiscountedPrice
	}
	return 0
}

func (m *Package) GetDescription() []string {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *Package) GetNotice() string {
	if m != nil {
		return m.Notice
	}
	return ""
}

func (m *Package) GetPeriod() *types.Timestamp {
	if m != nil {
		return m.Period
	}
	return nil
}

func (m *Package) GetIsRecommended() bool {
	if m != nil {
		return m.IsRecommended
	}
	return false
}

func (m *Package) GetIsEnabled() bool {
	if m != nil {
		return m.IsEnabled
	}
	return false
}

// Deprecated: Do not use.
func (m *Package) GetIsHidden() bool {
	if m != nil {
		return m.IsHidden
	}
	return false
}

// Deprecated: Do not use.
func (m *Package) GetCarriedOverAmount() float64 {
	if m != nil {
		return m.CarriedOverAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *Package) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *Package) GetCountry() bob.Country {
	if m != nil {
		return m.Country
	}
	return bob.COUNTRY_NONE
}

func (m *Package) GetPrioritizeLevel() int32 {
	if m != nil {
		return m.PrioritizeLevel
	}
	return 0
}

func (m *Package) GetPackageItems() []*PackageItem {
	if m != nil {
		return m.PackageItems
	}
	return nil
}

func (m *Package) GetUpgradableFrom() []int32 {
	if m != nil {
		return m.UpgradableFrom
	}
	return nil
}

type PackageItem struct {
	Id              string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PackageId       int32            `protobuf:"varint,2,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	PlanId          string           `protobuf:"bytes,3,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	ExpiredAt       *types.Timestamp `protobuf:"bytes,4,opt,name=expired_at,json=expiredAt,proto3" json:"expired_at,omitempty"`
	Duration        int32            `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
	Subject         []bob.Subject    `protobuf:"varint,6,rep,packed,name=subject,proto3,enum=manabie.bob.Subject" json:"subject,omitempty"`
	Grades          []int32          `protobuf:"varint,7,rep,packed,name=grades,proto3" json:"grades,omitempty"`
	Price           int32            `protobuf:"varint,8,opt,name=price,proto3" json:"price,omitempty"`
	DiscountedPrice int32            `protobuf:"varint,9,opt,name=discounted_price,json=discountedPrice,proto3" json:"discounted_price,omitempty"`
	Country         bob.Country      `protobuf:"varint,10,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
}

func (m *PackageItem) Reset()      { *m = PackageItem{} }
func (*PackageItem) ProtoMessage() {}
func (*PackageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{2}
}
func (m *PackageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackageItem.Merge(m, src)
}
func (m *PackageItem) XXX_Size() int {
	return m.Size()
}
func (m *PackageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PackageItem.DiscardUnknown(m)
}

var xxx_messageInfo_PackageItem proto.InternalMessageInfo

func (m *PackageItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PackageItem) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *PackageItem) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *PackageItem) GetExpiredAt() *types.Timestamp {
	if m != nil {
		return m.ExpiredAt
	}
	return nil
}

func (m *PackageItem) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *PackageItem) GetSubject() []bob.Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *PackageItem) GetGrades() []int32 {
	if m != nil {
		return m.Grades
	}
	return nil
}

func (m *PackageItem) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *PackageItem) GetDiscountedPrice() int32 {
	if m != nil {
		return m.DiscountedPrice
	}
	return 0
}

func (m *PackageItem) GetCountry() bob.Country {
	if m != nil {
		return m.Country
	}
	return bob.COUNTRY_NONE
}

type Order struct {
	Id                  int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Amount              float64                `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount,omitempty"`
	PlanId              string                 `protobuf:"bytes,3,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	PlanName            string                 `protobuf:"bytes,4,opt,name=plan_name,json=planName,proto3" json:"plan_name,omitempty"` // Deprecated: Do not use.
	ManualCreatedBy     string                 `protobuf:"bytes,5,opt,name=manual_created_by,json=manualCreatedBy,proto3" json:"manual_created_by,omitempty"`
	Status              OrderStatus            `protobuf:"varint,6,opt,name=status,proto3,enum=manabie.yasuo.OrderStatus" json:"status,omitempty"`
	Coupon              string                 `protobuf:"bytes,7,opt,name=coupon,proto3" json:"coupon,omitempty"`
	CouponAmount        float64                `protobuf:"fixed64,8,opt,name=coupon_amount,json=couponAmount,proto3" json:"coupon_amount,omitempty"`
	CarriedOverAmount   float64                `protobuf:"fixed64,9,opt,name=carried_over_amount,json=carriedOverAmount,proto3" json:"carried_over_amount,omitempty"` // Deprecated: Do not use.
	CarriedOverFrom     int32                  `protobuf:"varint,10,opt,name=carried_over_from,json=carriedOverFrom,proto3" json:"carried_over_from,omitempty"`       // Deprecated: Do not use.
	Start               *types.Timestamp       `protobuf:"bytes,11,opt,name=start,proto3" json:"start,omitempty"`                                                     // Deprecated: Do not use.
	End                 *types.Timestamp       `protobuf:"bytes,12,opt,name=end,proto3" json:"end,omitempty"`                                                         // Deprecated: Do not use.
	UpdatedAt           *types.Timestamp       `protobuf:"bytes,13,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	CreatedAt           *types.Timestamp       `protobuf:"bytes,14,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Currency            string                 `protobuf:"bytes,15,opt,name=currency,proto3" json:"currency,omitempty"`
	PaymentMethod       string                 `protobuf:"bytes,16,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
	PaymentLink         string                 `protobuf:"bytes,17,opt,name=payment_link,json=paymentLink,proto3" json:"payment_link,omitempty"`
	PackageId           int32                  `protobuf:"varint,18,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	PackageName         string                 `protobuf:"bytes,19,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	Country             bob.Country            `protobuf:"varint,20,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
	StudentId           string                 `protobuf:"bytes,21,opt,name=student_id,json=studentId,proto3" json:"student_id,omitempty"`
	ReferenceNumber     string                 `protobuf:"bytes,22,opt,name=reference_number,json=referenceNumber,proto3" json:"reference_number,omitempty"`
	CodOrderInfo        *CodOrderInfo          `protobuf:"bytes,23,opt,name=cod_order_info,json=codOrderInfo,proto3" json:"cod_order_info,omitempty"`
	MustPayBefore       *types.Timestamp       `protobuf:"bytes,24,opt,name=must_pay_before,json=mustPayBefore,proto3" json:"must_pay_before,omitempty"`
	Subscriptions       []*StudentSubscription `protobuf:"bytes,25,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	GatewayFullFeedback string                 `protobuf:"bytes,26,opt,name=gateway_full_feedback,json=gatewayFullFeedback,proto3" json:"gateway_full_feedback,omitempty"`
	GatewayLink         string                 `protobuf:"bytes,27,opt,name=gateway_link,json=gatewayLink,proto3" json:"gateway_link,omitempty"`
	GatewayName         PaymentGateway         `protobuf:"varint,28,opt,name=gateway_name,json=gatewayName,proto3,enum=manabie.yasuo.PaymentGateway" json:"gateway_name,omitempty"`
	GatewayResponse     string                 `protobuf:"bytes,29,opt,name=gateway_response,json=gatewayResponse,proto3" json:"gateway_response,omitempty"`
	CreatedByEmail      string                 `protobuf:"bytes,30,opt,name=created_by_email,json=createdByEmail,proto3" json:"created_by_email,omitempty"`
	IsManualCreated     bool                   `protobuf:"varint,31,opt,name=is_manual_created,json=isManualCreated,proto3" json:"is_manual_created,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{3}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Order) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Order) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

// Deprecated: Do not use.
func (m *Order) GetPlanName() string {
	if m != nil {
		return m.PlanName
	}
	return ""
}

func (m *Order) GetManualCreatedBy() string {
	if m != nil {
		return m.ManualCreatedBy
	}
	return ""
}

func (m *Order) GetStatus() OrderStatus {
	if m != nil {
		return m.Status
	}
	return ORDER_STATUS_NONE
}

func (m *Order) GetCoupon() string {
	if m != nil {
		return m.Coupon
	}
	return ""
}

func (m *Order) GetCouponAmount() float64 {
	if m != nil {
		return m.CouponAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *Order) GetCarriedOverAmount() float64 {
	if m != nil {
		return m.CarriedOverAmount
	}
	return 0
}

// Deprecated: Do not use.
func (m *Order) GetCarriedOverFrom() int32 {
	if m != nil {
		return m.CarriedOverFrom
	}
	return 0
}

// Deprecated: Do not use.
func (m *Order) GetStart() *types.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

// Deprecated: Do not use.
func (m *Order) GetEnd() *types.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Order) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *Order) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Order) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Order) GetPaymentMethod() string {
	if m != nil {
		return m.PaymentMethod
	}
	return ""
}

func (m *Order) GetPaymentLink() string {
	if m != nil {
		return m.PaymentLink
	}
	return ""
}

func (m *Order) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *Order) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *Order) GetCountry() bob.Country {
	if m != nil {
		return m.Country
	}
	return bob.COUNTRY_NONE
}

func (m *Order) GetStudentId() string {
	if m != nil {
		return m.StudentId
	}
	return ""
}

func (m *Order) GetReferenceNumber() string {
	if m != nil {
		return m.ReferenceNumber
	}
	return ""
}

func (m *Order) GetCodOrderInfo() *CodOrderInfo {
	if m != nil {
		return m.CodOrderInfo
	}
	return nil
}

func (m *Order) GetMustPayBefore() *types.Timestamp {
	if m != nil {
		return m.MustPayBefore
	}
	return nil
}

func (m *Order) GetSubscriptions() []*StudentSubscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

func (m *Order) GetGatewayFullFeedback() string {
	if m != nil {
		return m.GatewayFullFeedback
	}
	return ""
}

func (m *Order) GetGatewayLink() string {
	if m != nil {
		return m.GatewayLink
	}
	return ""
}

func (m *Order) GetGatewayName() PaymentGateway {
	if m != nil {
		return m.GatewayName
	}
	return GATEWAY_NONE
}

func (m *Order) GetGatewayResponse() string {
	if m != nil {
		return m.GatewayResponse
	}
	return ""
}

func (m *Order) GetCreatedByEmail() string {
	if m != nil {
		return m.CreatedByEmail
	}
	return ""
}

func (m *Order) GetIsManualCreated() bool {
	if m != nil {
		return m.IsManualCreated
	}
	return false
}

type ManualOrder struct {
	StudentOrderId int32              `protobuf:"varint,1,opt,name=student_order_id,json=studentOrderId,proto3" json:"student_order_id,omitempty"`
	Amount         float64            `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount,omitempty"`
	Currency       *types.StringValue `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	PaymentMethod  *types.StringValue `protobuf:"bytes,4,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
	StudentId      *types.StringValue `protobuf:"bytes,5,opt,name=student_id,json=studentId,proto3" json:"student_id,omitempty"`
	PackageId      int32              `protobuf:"varint,6,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	PackageName    *types.StringValue `protobuf:"bytes,7,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	PlanId         *types.StringValue `protobuf:"bytes,8,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	Coupon         *types.StringValue `protobuf:"bytes,9,opt,name=coupon,proto3" json:"coupon,omitempty"`
	CouponAmount   float64            `protobuf:"fixed64,10,opt,name=coupon_amount,json=couponAmount,proto3" json:"coupon_amount,omitempty"`
	Country        bob.Country        `protobuf:"varint,11,opt,name=country,proto3,enum=manabie.bob.Country" json:"country,omitempty"`
	// bool is_manual_created = 10;
	CreatedByEmail string           `protobuf:"bytes,12,opt,name=created_by_email,json=createdByEmail,proto3" json:"created_by_email,omitempty"`
	Start          *types.Timestamp `protobuf:"bytes,13,opt,name=start,proto3" json:"start,omitempty"`
	End            *types.Timestamp `protobuf:"bytes,14,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *ManualOrder) Reset()      { *m = ManualOrder{} }
func (*ManualOrder) ProtoMessage() {}
func (*ManualOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{4}
}
func (m *ManualOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManualOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManualOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManualOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManualOrder.Merge(m, src)
}
func (m *ManualOrder) XXX_Size() int {
	return m.Size()
}
func (m *ManualOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_ManualOrder.DiscardUnknown(m)
}

var xxx_messageInfo_ManualOrder proto.InternalMessageInfo

func (m *ManualOrder) GetStudentOrderId() int32 {
	if m != nil {
		return m.StudentOrderId
	}
	return 0
}

func (m *ManualOrder) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ManualOrder) GetCurrency() *types.StringValue {
	if m != nil {
		return m.Currency
	}
	return nil
}

func (m *ManualOrder) GetPaymentMethod() *types.StringValue {
	if m != nil {
		return m.PaymentMethod
	}
	return nil
}

func (m *ManualOrder) GetStudentId() *types.StringValue {
	if m != nil {
		return m.StudentId
	}
	return nil
}

func (m *ManualOrder) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *ManualOrder) GetPackageName() *types.StringValue {
	if m != nil {
		return m.PackageName
	}
	return nil
}

func (m *ManualOrder) GetPlanId() *types.StringValue {
	if m != nil {
		return m.PlanId
	}
	return nil
}

func (m *ManualOrder) GetCoupon() *types.StringValue {
	if m != nil {
		return m.Coupon
	}
	return nil
}

func (m *ManualOrder) GetCouponAmount() float64 {
	if m != nil {
		return m.CouponAmount
	}
	return 0
}

func (m *ManualOrder) GetCountry() bob.Country {
	if m != nil {
		return m.Country
	}
	return bob.COUNTRY_NONE
}

func (m *ManualOrder) GetCreatedByEmail() string {
	if m != nil {
		return m.CreatedByEmail
	}
	return ""
}

func (m *ManualOrder) GetStart() *types.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *ManualOrder) GetEnd() *types.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

type CodOrderInfo struct {
	CustomerName         string           `protobuf:"bytes,1,opt,name=customer_name,json=customerName,proto3" json:"customer_name,omitempty"`
	CustomerPhoneNumber  string           `protobuf:"bytes,2,opt,name=customer_phone_number,json=customerPhoneNumber,proto3" json:"customer_phone_number,omitempty"`
	CustomerAddress      string           `protobuf:"bytes,3,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address,omitempty"`
	ExpectedDeliveryTime *types.Timestamp `protobuf:"bytes,4,opt,name=expected_delivery_time,json=expectedDeliveryTime,proto3" json:"expected_delivery_time,omitempty"`
	Status               CodOrderStatus   `protobuf:"varint,5,opt,name=status,proto3,enum=manabie.yasuo.CodOrderStatus" json:"status,omitempty"`
}

func (m *CodOrderInfo) Reset()      { *m = CodOrderInfo{} }
func (*CodOrderInfo) ProtoMessage() {}
func (*CodOrderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{5}
}
func (m *CodOrderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodOrderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodOrderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodOrderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodOrderInfo.Merge(m, src)
}
func (m *CodOrderInfo) XXX_Size() int {
	return m.Size()
}
func (m *CodOrderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CodOrderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CodOrderInfo proto.InternalMessageInfo

func (m *CodOrderInfo) GetCustomerName() string {
	if m != nil {
		return m.CustomerName
	}
	return ""
}

func (m *CodOrderInfo) GetCustomerPhoneNumber() string {
	if m != nil {
		return m.CustomerPhoneNumber
	}
	return ""
}

func (m *CodOrderInfo) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

func (m *CodOrderInfo) GetExpectedDeliveryTime() *types.Timestamp {
	if m != nil {
		return m.ExpectedDeliveryTime
	}
	return nil
}

func (m *CodOrderInfo) GetStatus() CodOrderStatus {
	if m != nil {
		return m.Status
	}
	return COD_ORDER_STATUS_NONE
}

type StudentSubscription struct {
	PlanId   string             `protobuf:"bytes,1,opt,name=plan_id,json=planId,proto3" json:"plan_id,omitempty"`
	Grades   []int32            `protobuf:"varint,2,rep,packed,name=grades,proto3" json:"grades,omitempty"`
	Subjects []bob.Subject      `protobuf:"varint,3,rep,packed,name=subjects,proto3,enum=manabie.bob.Subject" json:"subjects,omitempty"`
	Start    *types.Timestamp   `protobuf:"bytes,4,opt,name=start,proto3" json:"start,omitempty"`
	End      *types.Timestamp   `protobuf:"bytes,5,opt,name=end,proto3" json:"end,omitempty"`
	Status   SubscriptionStatus `protobuf:"varint,6,opt,name=status,proto3,enum=manabie.yasuo.SubscriptionStatus" json:"status,omitempty"`
}

func (m *StudentSubscription) Reset()      { *m = StudentSubscription{} }
func (*StudentSubscription) ProtoMessage() {}
func (*StudentSubscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{6}
}
func (m *StudentSubscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StudentSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StudentSubscription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StudentSubscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StudentSubscription.Merge(m, src)
}
func (m *StudentSubscription) XXX_Size() int {
	return m.Size()
}
func (m *StudentSubscription) XXX_DiscardUnknown() {
	xxx_messageInfo_StudentSubscription.DiscardUnknown(m)
}

var xxx_messageInfo_StudentSubscription proto.InternalMessageInfo

func (m *StudentSubscription) GetPlanId() string {
	if m != nil {
		return m.PlanId
	}
	return ""
}

func (m *StudentSubscription) GetGrades() []int32 {
	if m != nil {
		return m.Grades
	}
	return nil
}

func (m *StudentSubscription) GetSubjects() []bob.Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *StudentSubscription) GetStart() *types.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *StudentSubscription) GetEnd() *types.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *StudentSubscription) GetStatus() SubscriptionStatus {
	if m != nil {
		return m.Status
	}
	return SUBSCRIPTION_STATUS_NONE
}

type CreateManualOrderRequest struct {
	Order *ManualOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *CreateManualOrderRequest) Reset()      { *m = CreateManualOrderRequest{} }
func (*CreateManualOrderRequest) ProtoMessage() {}
func (*CreateManualOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{7}
}
func (m *CreateManualOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateManualOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateManualOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateManualOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateManualOrderRequest.Merge(m, src)
}
func (m *CreateManualOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateManualOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateManualOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateManualOrderRequest proto.InternalMessageInfo

func (m *CreateManualOrderRequest) GetOrder() *ManualOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type CreateManualOrderResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *CreateManualOrderResponse) Reset()      { *m = CreateManualOrderResponse{} }
func (*CreateManualOrderResponse) ProtoMessage() {}
func (*CreateManualOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{8}
}
func (m *CreateManualOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateManualOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateManualOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateManualOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateManualOrderResponse.Merge(m, src)
}
func (m *CreateManualOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateManualOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateManualOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateManualOrderResponse proto.InternalMessageInfo

func (m *CreateManualOrderResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type CreatePackageRequest struct {
	Package      *Package       `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	PackageItems []*PackageItem `protobuf:"bytes,2,rep,name=package_items,json=packageItems,proto3" json:"package_items,omitempty"`
}

func (m *CreatePackageRequest) Reset()      { *m = CreatePackageRequest{} }
func (*CreatePackageRequest) ProtoMessage() {}
func (*CreatePackageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{9}
}
func (m *CreatePackageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePackageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePackageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePackageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePackageRequest.Merge(m, src)
}
func (m *CreatePackageRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreatePackageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePackageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePackageRequest proto.InternalMessageInfo

func (m *CreatePackageRequest) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

func (m *CreatePackageRequest) GetPackageItems() []*PackageItem {
	if m != nil {
		return m.PackageItems
	}
	return nil
}

type CreatePackageResponse struct {
	Successful bool  `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
	PackageId  int32 `protobuf:"varint,2,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
}

func (m *CreatePackageResponse) Reset()      { *m = CreatePackageResponse{} }
func (*CreatePackageResponse) ProtoMessage() {}
func (*CreatePackageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{10}
}
func (m *CreatePackageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePackageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePackageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePackageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePackageResponse.Merge(m, src)
}
func (m *CreatePackageResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreatePackageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePackageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePackageResponse proto.InternalMessageInfo

func (m *CreatePackageResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

func (m *CreatePackageResponse) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

type Pagination struct {
	Limit  uint32 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset uint32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *Pagination) Reset()      { *m = Pagination{} }
func (*Pagination) ProtoMessage() {}
func (*Pagination) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{11}
}
func (m *Pagination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pagination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pagination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pagination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pagination.Merge(m, src)
}
func (m *Pagination) XXX_Size() int {
	return m.Size()
}
func (m *Pagination) XXX_DiscardUnknown() {
	xxx_messageInfo_Pagination.DiscardUnknown(m)
}

var xxx_messageInfo_Pagination proto.InternalMessageInfo

func (m *Pagination) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Pagination) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type Sort struct {
	Field string        `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	Order SortOrderType `protobuf:"varint,2,opt,name=order,proto3,enum=manabie.yasuo.SortOrderType" json:"order,omitempty"`
}

func (m *Sort) Reset()      { *m = Sort{} }
func (*Sort) ProtoMessage() {}
func (*Sort) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{12}
}
func (m *Sort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sort.Merge(m, src)
}
func (m *Sort) XXX_Size() int {
	return m.Size()
}
func (m *Sort) XXX_DiscardUnknown() {
	xxx_messageInfo_Sort.DiscardUnknown(m)
}

var xxx_messageInfo_Sort proto.InternalMessageInfo

func (m *Sort) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Sort) GetOrder() SortOrderType {
	if m != nil {
		return m.Order
	}
	return SORT_ORDER_TYPE_DESC
}

type DisableSubscriptionRequest struct {
	StudentSubscriptionIds []string `protobuf:"bytes,1,rep,name=student_subscription_ids,json=studentSubscriptionIds,proto3" json:"student_subscription_ids,omitempty"`
}

func (m *DisableSubscriptionRequest) Reset()      { *m = DisableSubscriptionRequest{} }
func (*DisableSubscriptionRequest) ProtoMessage() {}
func (*DisableSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{13}
}
func (m *DisableSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisableSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisableSubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisableSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisableSubscriptionRequest.Merge(m, src)
}
func (m *DisableSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DisableSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DisableSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DisableSubscriptionRequest proto.InternalMessageInfo

func (m *DisableSubscriptionRequest) GetStudentSubscriptionIds() []string {
	if m != nil {
		return m.StudentSubscriptionIds
	}
	return nil
}

type DisableSubscriptionResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *DisableSubscriptionResponse) Reset()      { *m = DisableSubscriptionResponse{} }
func (*DisableSubscriptionResponse) ProtoMessage() {}
func (*DisableSubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{14}
}
func (m *DisableSubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisableSubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisableSubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisableSubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisableSubscriptionResponse.Merge(m, src)
}
func (m *DisableSubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *DisableSubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DisableSubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DisableSubscriptionResponse proto.InternalMessageInfo

func (m *DisableSubscriptionResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type ToggleEnabledPackageRequest struct {
	PackageId int32 `protobuf:"varint,1,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
}

func (m *ToggleEnabledPackageRequest) Reset()      { *m = ToggleEnabledPackageRequest{} }
func (*ToggleEnabledPackageRequest) ProtoMessage() {}
func (*ToggleEnabledPackageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{15}
}
func (m *ToggleEnabledPackageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToggleEnabledPackageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToggleEnabledPackageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToggleEnabledPackageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToggleEnabledPackageRequest.Merge(m, src)
}
func (m *ToggleEnabledPackageRequest) XXX_Size() int {
	return m.Size()
}
func (m *ToggleEnabledPackageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ToggleEnabledPackageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ToggleEnabledPackageRequest proto.InternalMessageInfo

func (m *ToggleEnabledPackageRequest) GetPackageId() int32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

type ToggleEnabledPackageResponse struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *ToggleEnabledPackageResponse) Reset()      { *m = ToggleEnabledPackageResponse{} }
func (*ToggleEnabledPackageResponse) ProtoMessage() {}
func (*ToggleEnabledPackageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{16}
}
func (m *ToggleEnabledPackageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToggleEnabledPackageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToggleEnabledPackageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToggleEnabledPackageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToggleEnabledPackageResponse.Merge(m, src)
}
func (m *ToggleEnabledPackageResponse) XXX_Size() int {
	return m.Size()
}
func (m *ToggleEnabledPackageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ToggleEnabledPackageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ToggleEnabledPackageResponse proto.InternalMessageInfo

func (m *ToggleEnabledPackageResponse) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

type ExtendSubscriptionRequest struct {
	SubscriptionId string           `protobuf:"bytes,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	ExpiredDate    *types.Timestamp `protobuf:"bytes,2,opt,name=expired_date,json=expiredDate,proto3" json:"expired_date,omitempty"`
}

func (m *ExtendSubscriptionRequest) Reset()      { *m = ExtendSubscriptionRequest{} }
func (*ExtendSubscriptionRequest) ProtoMessage() {}
func (*ExtendSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{17}
}
func (m *ExtendSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtendSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtendSubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtendSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendSubscriptionRequest.Merge(m, src)
}
func (m *ExtendSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExtendSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendSubscriptionRequest proto.InternalMessageInfo

func (m *ExtendSubscriptionRequest) GetSubscriptionId() string {
	if m != nil {
		return m.SubscriptionId
	}
	return ""
}

func (m *ExtendSubscriptionRequest) GetExpiredDate() *types.Timestamp {
	if m != nil {
		return m.ExpiredDate
	}
	return nil
}

type ExtendSubscriptionResponse struct {
}

func (m *ExtendSubscriptionResponse) Reset()      { *m = ExtendSubscriptionResponse{} }
func (*ExtendSubscriptionResponse) ProtoMessage() {}
func (*ExtendSubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{18}
}
func (m *ExtendSubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtendSubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtendSubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtendSubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendSubscriptionResponse.Merge(m, src)
}
func (m *ExtendSubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExtendSubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendSubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendSubscriptionResponse proto.InternalMessageInfo

type DisableOrdersRequest struct {
	OrderIds []int32 `protobuf:"varint,1,rep,packed,name=order_ids,json=orderIds,proto3" json:"order_ids,omitempty"`
}

func (m *DisableOrdersRequest) Reset()      { *m = DisableOrdersRequest{} }
func (*DisableOrdersRequest) ProtoMessage() {}
func (*DisableOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{19}
}
func (m *DisableOrdersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisableOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisableOrdersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisableOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisableOrdersRequest.Merge(m, src)
}
func (m *DisableOrdersRequest) XXX_Size() int {
	return m.Size()
}
func (m *DisableOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DisableOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DisableOrdersRequest proto.InternalMessageInfo

func (m *DisableOrdersRequest) GetOrderIds() []int32 {
	if m != nil {
		return m.OrderIds
	}
	return nil
}

type DisableOrdersResponse struct {
	OrderIds []int32 `protobuf:"varint,1,rep,packed,name=order_ids,json=orderIds,proto3" json:"order_ids,omitempty"`
}

func (m *DisableOrdersResponse) Reset()      { *m = DisableOrdersResponse{} }
func (*DisableOrdersResponse) ProtoMessage() {}
func (*DisableOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_37d2bc937472db71, []int{20}
}
func (m *DisableOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisableOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DisableOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DisableOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisableOrdersResponse.Merge(m, src)
}
func (m *DisableOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *DisableOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DisableOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DisableOrdersResponse proto.InternalMessageInfo

func (m *DisableOrdersResponse) GetOrderIds() []int32 {
	if m != nil {
		return m.OrderIds
	}
	return nil
}

func init() {
	proto.RegisterEnum("manabie.yasuo.PromoType", PromoType_name, PromoType_value)
	golang_proto.RegisterEnum("manabie.yasuo.PromoType", PromoType_name, PromoType_value)
	proto.RegisterEnum("manabie.yasuo.PromoDiscountType", PromoDiscountType_name, PromoDiscountType_value)
	golang_proto.RegisterEnum("manabie.yasuo.PromoDiscountType", PromoDiscountType_name, PromoDiscountType_value)
	proto.RegisterEnum("manabie.yasuo.PromoStatus", PromoStatus_name, PromoStatus_value)
	golang_proto.RegisterEnum("manabie.yasuo.PromoStatus", PromoStatus_name, PromoStatus_value)
	proto.RegisterType((*Plan)(nil), "manabie.yasuo.Plan")
	golang_proto.RegisterType((*Plan)(nil), "manabie.yasuo.Plan")
	proto.RegisterType((*Package)(nil), "manabie.yasuo.Package")
	golang_proto.RegisterType((*Package)(nil), "manabie.yasuo.Package")
	proto.RegisterType((*PackageItem)(nil), "manabie.yasuo.PackageItem")
	golang_proto.RegisterType((*PackageItem)(nil), "manabie.yasuo.PackageItem")
	proto.RegisterType((*Order)(nil), "manabie.yasuo.Order")
	golang_proto.RegisterType((*Order)(nil), "manabie.yasuo.Order")
	proto.RegisterType((*ManualOrder)(nil), "manabie.yasuo.ManualOrder")
	golang_proto.RegisterType((*ManualOrder)(nil), "manabie.yasuo.ManualOrder")
	proto.RegisterType((*CodOrderInfo)(nil), "manabie.yasuo.CodOrderInfo")
	golang_proto.RegisterType((*CodOrderInfo)(nil), "manabie.yasuo.CodOrderInfo")
	proto.RegisterType((*StudentSubscription)(nil), "manabie.yasuo.StudentSubscription")
	golang_proto.RegisterType((*StudentSubscription)(nil), "manabie.yasuo.StudentSubscription")
	proto.RegisterType((*CreateManualOrderRequest)(nil), "manabie.yasuo.CreateManualOrderRequest")
	golang_proto.RegisterType((*CreateManualOrderRequest)(nil), "manabie.yasuo.CreateManualOrderRequest")
	proto.RegisterType((*CreateManualOrderResponse)(nil), "manabie.yasuo.CreateManualOrderResponse")
	golang_proto.RegisterType((*CreateManualOrderResponse)(nil), "manabie.yasuo.CreateManualOrderResponse")
	proto.RegisterType((*CreatePackageRequest)(nil), "manabie.yasuo.CreatePackageRequest")
	golang_proto.RegisterType((*CreatePackageRequest)(nil), "manabie.yasuo.CreatePackageRequest")
	proto.RegisterType((*CreatePackageResponse)(nil), "manabie.yasuo.CreatePackageResponse")
	golang_proto.RegisterType((*CreatePackageResponse)(nil), "manabie.yasuo.CreatePackageResponse")
	proto.RegisterType((*Pagination)(nil), "manabie.yasuo.Pagination")
	golang_proto.RegisterType((*Pagination)(nil), "manabie.yasuo.Pagination")
	proto.RegisterType((*Sort)(nil), "manabie.yasuo.Sort")
	golang_proto.RegisterType((*Sort)(nil), "manabie.yasuo.Sort")
	proto.RegisterType((*DisableSubscriptionRequest)(nil), "manabie.yasuo.DisableSubscriptionRequest")
	golang_proto.RegisterType((*DisableSubscriptionRequest)(nil), "manabie.yasuo.DisableSubscriptionRequest")
	proto.RegisterType((*DisableSubscriptionResponse)(nil), "manabie.yasuo.DisableSubscriptionResponse")
	golang_proto.RegisterType((*DisableSubscriptionResponse)(nil), "manabie.yasuo.DisableSubscriptionResponse")
	proto.RegisterType((*ToggleEnabledPackageRequest)(nil), "manabie.yasuo.ToggleEnabledPackageRequest")
	golang_proto.RegisterType((*ToggleEnabledPackageRequest)(nil), "manabie.yasuo.ToggleEnabledPackageRequest")
	proto.RegisterType((*ToggleEnabledPackageResponse)(nil), "manabie.yasuo.ToggleEnabledPackageResponse")
	golang_proto.RegisterType((*ToggleEnabledPackageResponse)(nil), "manabie.yasuo.ToggleEnabledPackageResponse")
	proto.RegisterType((*ExtendSubscriptionRequest)(nil), "manabie.yasuo.ExtendSubscriptionRequest")
	golang_proto.RegisterType((*ExtendSubscriptionRequest)(nil), "manabie.yasuo.ExtendSubscriptionRequest")
	proto.RegisterType((*ExtendSubscriptionResponse)(nil), "manabie.yasuo.ExtendSubscriptionResponse")
	golang_proto.RegisterType((*ExtendSubscriptionResponse)(nil), "manabie.yasuo.ExtendSubscriptionResponse")
	proto.RegisterType((*DisableOrdersRequest)(nil), "manabie.yasuo.DisableOrdersRequest")
	golang_proto.RegisterType((*DisableOrdersRequest)(nil), "manabie.yasuo.DisableOrdersRequest")
	proto.RegisterType((*DisableOrdersResponse)(nil), "manabie.yasuo.DisableOrdersResponse")
	golang_proto.RegisterType((*DisableOrdersResponse)(nil), "manabie.yasuo.DisableOrdersResponse")
}

func init() { proto.RegisterFile("yssubscription.proto", fileDescriptor_37d2bc937472db71) }
func init() { golang_proto.RegisterFile("yssubscription.proto", fileDescriptor_37d2bc937472db71) }

var fileDescriptor_37d2bc937472db71 = []byte{
	// 2215 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xcf, 0x73, 0xdb, 0xc6,
	0xf5, 0x17, 0x28, 0x52, 0x22, 0x9f, 0x44, 0x8a, 0x5a, 0xfd, 0x08, 0x4c, 0x59, 0xb4, 0xc2, 0xe4,
	0xfb, 0x8d, 0xe4, 0x36, 0x94, 0x47, 0x71, 0x66, 0x92, 0xba, 0x69, 0x4a, 0x49, 0x74, 0xcc, 0xa9,
	0x6c, 0x71, 0x20, 0xda, 0xd3, 0xe6, 0x82, 0x01, 0x89, 0x25, 0xbd, 0x35, 0x81, 0x45, 0xb1, 0x80,
	0x62, 0xf6, 0xd4, 0x99, 0x9e, 0x7a, 0xeb, 0x4c, 0x6f, 0xed, 0xa9, 0xb7, 0xfe, 0x07, 0xbd, 0xf6,
	0xd8, 0xa3, 0x2f, 0x9d, 0x49, 0x6f, 0xb5, 0x3c, 0x9d, 0xe9, 0x31, 0xff, 0x41, 0x3b, 0xfb, 0x03,
	0x04, 0x08, 0x52, 0x12, 0x73, 0xe3, 0x7b, 0xfb, 0xde, 0x62, 0xf7, 0xf3, 0x3e, 0x9f, 0xb7, 0xbb,
	0x84, 0xcd, 0x11, 0x63, 0x61, 0x97, 0xf5, 0x7c, 0xe2, 0x05, 0x84, 0xba, 0x75, 0xcf, 0xa7, 0x01,
	0x45, 0x45, 0xc7, 0x72, 0xad, 0x2e, 0xc1, 0xf5, 0x91, 0xc5, 0x42, 0x5a, 0x59, 0x1d, 0x31, 0xec,
	0x86, 0x8e, 0x1c, 0xac, 0x94, 0xba, 0xb4, 0x7b, 0x98, 0xb0, 0xef, 0x0d, 0x28, 0x1d, 0x0c, 0xf1,
	0xa1, 0xb0, 0xba, 0x61, 0xff, 0x30, 0x20, 0x0e, 0x66, 0x81, 0xe5, 0x78, 0x2a, 0xa0, 0x9a, 0x0e,
	0xf8, 0xc6, 0xb7, 0x3c, 0x0f, 0xfb, 0x4c, 0x8d, 0x7f, 0x3c, 0x20, 0xc1, 0xcb, 0xb0, 0x5b, 0xef,
	0x51, 0xe7, 0x70, 0x40, 0x07, 0x34, 0x0e, 0xe4, 0x96, 0x30, 0xc4, 0x2f, 0x19, 0x5e, 0xfb, 0x73,
	0x06, 0xb2, 0xed, 0xa1, 0xe5, 0xa2, 0x12, 0x64, 0x88, 0xad, 0x6b, 0x7b, 0xda, 0x7e, 0xc1, 0xc8,
	0x10, 0x1b, 0xed, 0xc1, 0x8a, 0x8d, 0xc7, 0x5b, 0xd1, 0x33, 0x62, 0x20, 0xe9, 0x42, 0x1f, 0x43,
	0xd9, 0xb2, 0x2f, 0xb1, 0x1f, 0x10, 0x86, 0x6d, 0xd3, 0xf3, 0x49, 0x0f, 0xeb, 0x8b, 0x3c, 0xec,
	0x38, 0xa3, 0x6b, 0xc6, 0x5a, 0x3c, 0xd6, 0xe6, 0x43, 0xe8, 0xff, 0xa0, 0x44, 0x98, 0xe9, 0x85,
	0x7e, 0xef, 0xa5, 0xc5, 0xac, 0xee, 0x10, 0xeb, 0xd9, 0x3d, 0x6d, 0x3f, 0x6f, 0x14, 0x09, 0x6b,
	0xc7, 0x4e, 0x74, 0x00, 0xa5, 0xd0, 0x1b, 0xf8, 0x96, 0x8d, 0xb9, 0x69, 0x06, 0x54, 0xcf, 0xed,
	0x2d, 0xaa, 0x39, 0x8b, 0x89, 0x91, 0x0e, 0x45, 0x15, 0xc8, 0x77, 0xb1, 0x8b, 0xfb, 0x24, 0x60,
	0xfa, 0x12, 0x0f, 0x32, 0xc6, 0x36, 0x3a, 0x80, 0xb2, 0xe7, 0x13, 0xea, 0x93, 0x80, 0xfc, 0x1a,
	0x9b, 0x43, 0x7c, 0x89, 0x87, 0xfa, 0xf2, 0x9e, 0xb6, 0x9f, 0x33, 0xd6, 0x62, 0xff, 0x19, 0x77,
	0xa3, 0x7b, 0x50, 0x20, 0xcc, 0x7c, 0x49, 0x6c, 0x1b, 0xbb, 0x7a, 0x9e, 0xaf, 0x49, 0x7c, 0x2c,
	0x4f, 0xd8, 0x13, 0xe1, 0xab, 0xfd, 0x33, 0x0b, 0xcb, 0x6d, 0xab, 0xf7, 0xca, 0x1a, 0xe0, 0x04,
	0x4c, 0x39, 0x01, 0x13, 0x82, 0xac, 0x6b, 0x39, 0x58, 0xe1, 0x23, 0x7e, 0xa3, 0x4d, 0xc8, 0xc5,
	0x68, 0xe4, 0x0c, 0x69, 0xf0, 0x15, 0xd9, 0x84, 0xf5, 0x68, 0xe8, 0x06, 0x63, 0xb8, 0xb2, 0x72,
	0x45, 0xb1, 0x5f, 0x42, 0x95, 0xc2, 0x5e, 0x00, 0x30, 0x89, 0xfd, 0x36, 0x2c, 0xb9, 0x34, 0xe0,
	0x53, 0x2c, 0x89, 0x0f, 0x2b, 0x0b, 0x1d, 0xc1, 0x92, 0x87, 0x7d, 0x42, 0x6d, 0xb1, 0xd9, 0x95,
	0xa3, 0x4a, 0x5d, 0xd2, 0xa5, 0x1e, 0xb1, 0xa0, 0xde, 0x89, 0xf8, 0x64, 0xa8, 0x48, 0x55, 0x18,
	0x1f, 0xf7, 0xa8, 0xe3, 0x60, 0xd7, 0xc6, 0xb6, 0x04, 0x81, 0x17, 0xc6, 0x88, 0x9d, 0x68, 0x17,
	0x80, 0x30, 0x13, 0xbb, 0x1c, 0x7c, 0x5b, 0x2f, 0x88, 0x90, 0x02, 0x61, 0x4d, 0xe9, 0x98, 0x44,
	0x11, 0xa6, 0x51, 0x44, 0x47, 0xb0, 0xd1, 0xb3, 0x7c, 0x9f, 0x60, 0xdb, 0xa4, 0x97, 0xd8, 0x37,
	0x2d, 0x87, 0x6f, 0x59, 0x5f, 0xd9, 0xd3, 0xf6, 0x35, 0x11, 0xba, 0xae, 0x86, 0xcf, 0x2f, 0xb1,
	0xdf, 0x10, 0x83, 0x68, 0x07, 0x96, 0xbd, 0xa1, 0xe5, 0x9a, 0xc4, 0xd6, 0x57, 0xc7, 0xcc, 0x5a,
	0xe2, 0xae, 0x96, 0x8d, 0xea, 0xb0, 0x2c, 0x50, 0xf3, 0x47, 0x7a, 0x71, 0x4f, 0xdb, 0x2f, 0x1d,
	0x6d, 0xd6, 0x23, 0xa5, 0x75, 0x69, 0xb7, 0x7e, 0x22, 0xc7, 0x8c, 0x28, 0x68, 0x26, 0x25, 0x4a,
	0xb3, 0x29, 0xf1, 0x25, 0x14, 0x3d, 0x59, 0x70, 0x93, 0x04, 0xd8, 0x61, 0xfa, 0xda, 0xde, 0xa2,
	0x40, 0x73, 0x42, 0xca, 0x75, 0x45, 0x8a, 0x56, 0x80, 0x1d, 0x63, 0xd5, 0x8b, 0x0d, 0x86, 0x3e,
	0x82, 0x35, 0xc9, 0x55, 0x41, 0xe2, 0xbe, 0x4f, 0x1d, 0xbd, 0xbc, 0xb7, 0xb8, 0x9f, 0x33, 0x4a,
	0xb1, 0xfb, 0xb1, 0x4f, 0x9d, 0xda, 0xbf, 0x33, 0xb0, 0x92, 0x98, 0x66, 0x4a, 0x86, 0xbb, 0x00,
	0xe3, 0x95, 0xd8, 0x82, 0x65, 0x39, 0xa3, 0x10, 0x7d, 0xca, 0x46, 0xef, 0xc5, 0x00, 0x2d, 0x4a,
	0x22, 0x28, 0x70, 0x3e, 0x07, 0xc0, 0xaf, 0x3d, 0xe2, 0x63, 0xdb, 0xb4, 0x02, 0xc1, 0xb3, 0x9b,
	0xc9, 0x50, 0x50, 0xd1, 0x8d, 0x80, 0xcb, 0xca, 0x0e, 0x7d, 0x4b, 0x51, 0x8f, 0x7f, 0x70, 0x6c,
	0x73, 0xcc, 0x59, 0xd8, 0xfd, 0x25, 0xee, 0x05, 0x42, 0x71, 0x69, 0xcc, 0x2f, 0xe4, 0x98, 0x11,
	0x05, 0x71, 0x9e, 0x0a, 0xc5, 0x32, 0x7d, 0x59, 0x6c, 0x5f, 0x59, 0xb1, 0x44, 0xf2, 0xb7, 0x49,
	0xa4, 0x30, 0x5b, 0x22, 0x89, 0xe2, 0xc3, 0x1c, 0xc5, 0xaf, 0xfd, 0x03, 0x20, 0x77, 0xee, 0xdb,
	0xd8, 0x9f, 0x52, 0xf0, 0x36, 0x2c, 0x29, 0x2a, 0x72, 0x74, 0x35, 0x43, 0x59, 0xd7, 0x43, 0x7b,
	0x0f, 0x0a, 0x62, 0x40, 0xe8, 0x3e, 0x3b, 0xa6, 0x65, 0x9e, 0x3b, 0x9f, 0x71, 0xfd, 0xdf, 0x87,
	0x75, 0xc7, 0x72, 0x43, 0x6b, 0x68, 0xf6, 0x7c, 0x6c, 0xf1, 0xad, 0x74, 0x47, 0x02, 0xc9, 0x82,
	0xb1, 0x26, 0x07, 0x4e, 0xa4, 0xff, 0x78, 0xc4, 0x05, 0xcb, 0x02, 0x2b, 0x08, 0x99, 0x10, 0x72,
	0x69, 0x8a, 0x62, 0x62, 0xcd, 0x17, 0x22, 0xc2, 0x50, 0x91, 0x7c, 0xc5, 0x3d, 0x1a, 0x7a, 0xd4,
	0x15, 0x22, 0x2f, 0x18, 0xca, 0x42, 0x1f, 0x40, 0x51, 0xfe, 0x8a, 0xb4, 0x95, 0x17, 0x1b, 0x5a,
	0x95, 0x4e, 0x25, 0xa9, 0x6b, 0x64, 0x58, 0xb8, 0x49, 0x86, 0x75, 0x58, 0x9f, 0xc8, 0x11, 0x7c,
	0xe6, 0xb0, 0xe7, 0x64, 0xab, 0x4f, 0x64, 0x70, 0x52, 0xa3, 0x87, 0x90, 0x63, 0x81, 0xe5, 0x4b,
	0x71, 0xdf, 0xc8, 0x3b, 0x91, 0x2f, 0x83, 0xd1, 0x03, 0x58, 0xc4, 0xae, 0x14, 0xfa, 0xed, 0x39,
	0x3c, 0x94, 0x93, 0x3c, 0xf4, 0x6c, 0x81, 0xb0, 0x15, 0x88, 0x26, 0x70, 0x0b, 0xc9, 0x55, 0x74,
	0x23, 0xe0, 0xa9, 0x51, 0x71, 0xac, 0x40, 0xb4, 0x81, 0x5b, 0x52, 0x55, 0xb4, 0xd4, 0x47, 0x2f,
	0xf4, 0x7d, 0xec, 0xf6, 0x46, 0xfa, 0x9a, 0x28, 0xc0, 0xd8, 0xe6, 0xbd, 0xd4, 0xb3, 0x46, 0x0e,
	0x76, 0x03, 0xd3, 0xc1, 0xc1, 0x4b, 0x6a, 0xeb, 0x65, 0x11, 0x51, 0x54, 0xde, 0xa7, 0xc2, 0x89,
	0xde, 0x87, 0xd5, 0x28, 0x6c, 0x48, 0xdc, 0x57, 0xfa, 0xba, 0x3c, 0x5d, 0x95, 0xef, 0x8c, 0xb8,
	0xaf, 0x52, 0xc2, 0x47, 0x69, 0xe1, 0x8b, 0x19, 0xe4, 0xb0, 0xe0, 0xe1, 0x46, 0x34, 0x83, 0xf0,
	0x09, 0x1a, 0x26, 0x24, 0xb2, 0x39, 0x4f, 0x7f, 0xdc, 0x05, 0x60, 0x41, 0x68, 0xf3, 0x45, 0x11,
	0x5b, 0xdf, 0x12, 0x13, 0x16, 0x94, 0xa7, 0x65, 0x73, 0x71, 0xfa, 0xb8, 0x8f, 0xf9, 0x3e, 0xb1,
	0xe9, 0x86, 0x4e, 0x17, 0xfb, 0xfa, 0xb6, 0x24, 0xf5, 0xd8, 0xff, 0x4c, 0xb8, 0x51, 0x03, 0x4a,
	0x3d, 0x6a, 0x9b, 0x94, 0x73, 0xd7, 0x24, 0x6e, 0x9f, 0xea, 0xef, 0x09, 0x80, 0x77, 0x52, 0xe4,
	0x3e, 0xa1, 0xb6, 0xe0, 0x77, 0xcb, 0xed, 0x53, 0x4e, 0xd3, 0xd8, 0x42, 0xc7, 0xb0, 0xe6, 0x84,
	0x2c, 0x30, 0x3d, 0x6b, 0x64, 0x76, 0x71, 0x9f, 0xfa, 0x58, 0xd7, 0x6f, 0x2d, 0x52, 0x91, 0xa7,
	0xb4, 0xad, 0xd1, 0xb1, 0x48, 0x40, 0x4f, 0xa0, 0x98, 0xbc, 0x8e, 0x31, 0xfd, 0x8e, 0xe8, 0xe2,
	0xb5, 0xd4, 0x2a, 0x2e, 0xe4, 0x16, 0x2f, 0x12, 0xa1, 0xc6, 0x64, 0x22, 0x3a, 0x82, 0xad, 0x81,
	0x15, 0xe0, 0x6f, 0xac, 0x91, 0xd9, 0x0f, 0x87, 0x43, 0xb3, 0x8f, 0xb1, 0xdd, 0xb5, 0x7a, 0xaf,
	0xf4, 0x8a, 0x00, 0x60, 0x43, 0x0d, 0x3e, 0x0e, 0x87, 0xc3, 0xc7, 0x6a, 0x88, 0x57, 0x28, 0xca,
	0x11, 0x35, 0xde, 0x91, 0x15, 0x52, 0x3e, 0x51, 0xe3, 0x9f, 0xc6, 0x21, 0xa2, 0x88, 0x77, 0x45,
	0x99, 0x76, 0xa7, 0x4e, 0x19, 0xc1, 0x8a, 0xaf, 0x64, 0xe4, 0x78, 0x06, 0x51, 0xe3, 0x03, 0x28,
	0x47, 0x33, 0xf8, 0x98, 0x79, 0xd4, 0x65, 0x58, 0xdf, 0x95, 0x45, 0x51, 0x7e, 0x43, 0xb9, 0xd1,
	0x3e, 0x94, 0xe3, 0x76, 0x64, 0x62, 0xc7, 0x22, 0x43, 0xbd, 0x2a, 0x42, 0x4b, 0xbd, 0xa8, 0x1d,
	0x35, 0xb9, 0x97, 0xf7, 0x2f, 0xc2, 0xcc, 0xc9, 0x16, 0xa6, 0xdf, 0x13, 0x07, 0xfe, 0x1a, 0x61,
	0x4f, 0x93, 0x1d, 0xac, 0xf6, 0xd7, 0x1c, 0xac, 0x48, 0x8f, 0xec, 0xae, 0xfb, 0x50, 0x8e, 0x48,
	0xa4, 0xca, 0x1f, 0xf5, 0xda, 0x92, 0xf2, 0xcb, 0x1a, 0x5f, 0xdf, 0x77, 0x3f, 0x4b, 0xc8, 0x6b,
	0x51, 0x94, 0xfc, 0xee, 0x54, 0xc9, 0x2f, 0x02, 0x9f, 0xb8, 0x83, 0x17, 0xd6, 0x30, 0xc4, 0x09,
	0xf1, 0x9d, 0x4c, 0x89, 0x2f, 0x3b, 0x47, 0x7e, 0x4a, 0x9a, 0x8f, 0x26, 0x54, 0x90, 0x9b, 0x63,
	0x82, 0x84, 0x46, 0x26, 0x45, 0xbb, 0x94, 0x16, 0xed, 0x97, 0x29, 0xd1, 0x2e, 0xcf, 0x31, 0xfb,
	0x84, 0xa4, 0x3f, 0x8d, 0xcf, 0xa4, 0xfc, 0x1c, 0xb9, 0xd1, 0x89, 0xf5, 0x70, 0x7c, 0x60, 0x14,
	0xe6, 0xc9, 0xba, 0xee, 0x38, 0x81, 0x19, 0xc7, 0x49, 0xa2, 0xc9, 0xac, 0xcc, 0xd3, 0x64, 0x66,
	0xb1, 0x70, 0x75, 0x26, 0x0b, 0x1f, 0x44, 0x87, 0xc8, 0xed, 0x7d, 0x5d, 0x1d, 0x20, 0x3f, 0x94,
	0x07, 0xc8, 0xed, 0xcd, 0x9c, 0x87, 0xd5, 0xfe, 0x94, 0x81, 0xd5, 0x64, 0x03, 0x12, 0xfb, 0x0d,
	0x59, 0x40, 0x1d, 0xec, 0xcb, 0xf2, 0xc8, 0x5b, 0xd8, 0x6a, 0xe4, 0x14, 0x15, 0x38, 0x82, 0xad,
	0x71, 0x90, 0xf7, 0x92, 0xba, 0xe3, 0x56, 0x28, 0x1f, 0x00, 0x1b, 0xd1, 0x60, 0x9b, 0x8f, 0xa9,
	0x76, 0x78, 0x00, 0xe5, 0x71, 0x8e, 0x65, 0xdb, 0x3e, 0x66, 0x4c, 0x5d, 0x29, 0xd6, 0x22, 0x7f,
	0x43, 0xba, 0x51, 0x1b, 0xb6, 0xf1, 0x6b, 0x0f, 0xf7, 0x38, 0x3e, 0x36, 0x1e, 0x92, 0x4b, 0xec,
	0x8f, 0x4c, 0xfe, 0x04, 0x9c, 0xe3, 0x0a, 0xb7, 0x19, 0x65, 0x9e, 0xaa, 0x44, 0x3e, 0x84, 0x3e,
	0x1d, 0x5f, 0x30, 0x72, 0x33, 0xbb, 0x4b, 0x04, 0xc1, 0xe4, 0x1d, 0xa3, 0xf6, 0x87, 0x0c, 0x6c,
	0xcc, 0x68, 0x8c, 0xc9, 0x5b, 0x91, 0x36, 0x71, 0x2b, 0x8a, 0x6f, 0x7a, 0x99, 0x89, 0x9b, 0xde,
	0x03, 0xc8, 0xab, 0xcb, 0x20, 0xdf, 0xf4, 0xf5, 0x57, 0xc6, 0x71, 0x54, 0x5c, 0xf8, 0xec, 0xf7,
	0x2c, 0x7c, 0x6e, 0xae, 0xc2, 0xa3, 0xcf, 0x53, 0x57, 0xae, 0xf7, 0xd3, 0xe7, 0x41, 0x62, 0xbf,
	0x29, 0x54, 0xce, 0x40, 0x97, 0x8d, 0x2f, 0xd1, 0xf2, 0x0c, 0xfc, 0xab, 0x10, 0x33, 0x7e, 0x7d,
	0xc9, 0x89, 0x8e, 0x27, 0x70, 0x99, 0x7e, 0x2b, 0x24, 0x33, 0x64, 0x60, 0xed, 0x11, 0xdc, 0x99,
	0x31, 0x9b, 0x6a, 0xd7, 0x55, 0x00, 0x16, 0xf6, 0x7a, 0x98, 0xb1, 0x7e, 0x38, 0x14, 0x73, 0xe6,
	0x8d, 0x84, 0xa7, 0xf6, 0x3b, 0x0d, 0x36, 0x65, 0xb6, 0x7a, 0x3e, 0xc4, 0xeb, 0x58, 0x56, 0x2d,
	0x43, 0xad, 0x64, 0x7b, 0xf6, 0xab, 0xc5, 0x88, 0xc2, 0xa6, 0x5f, 0x3b, 0x99, 0xef, 0xf7, 0xda,
	0xa9, 0xbd, 0x80, 0xad, 0xd4, 0x52, 0xe6, 0xdb, 0xc4, 0x2d, 0xaf, 0x9b, 0xda, 0x8f, 0x00, 0xda,
	0xd6, 0x80, 0xb8, 0xf2, 0xed, 0xb1, 0x09, 0xb9, 0x21, 0x71, 0x48, 0x20, 0xe6, 0x29, 0x1a, 0xd2,
	0xe0, 0xbc, 0xa3, 0xfd, 0x3e, 0xc3, 0xf2, 0x18, 0x29, 0x1a, 0xca, 0xaa, 0xb5, 0x21, 0x7b, 0x41,
	0xfd, 0x80, 0x67, 0xf5, 0x09, 0x1e, 0x46, 0x74, 0x95, 0x06, 0x3a, 0x8a, 0x8a, 0x95, 0x11, 0x14,
	0xb8, 0x9b, 0xa6, 0x00, 0xf5, 0xe5, 0x39, 0xd5, 0x19, 0x79, 0x38, 0x2a, 0xd7, 0x0b, 0xa8, 0x9c,
	0x12, 0xf1, 0x27, 0xc5, 0xc4, 0x55, 0x41, 0xc1, 0xfe, 0x19, 0xe8, 0xd1, 0xb9, 0x91, 0xbc, 0x3b,
	0x98, 0xc4, 0x66, 0xba, 0x26, 0x1e, 0xf0, 0xdb, 0x6c, 0x5a, 0x4f, 0x2d, 0x9b, 0xd5, 0xbe, 0x80,
	0x9d, 0x99, 0xf3, 0xce, 0x49, 0x84, 0x1f, 0xc3, 0x4e, 0x87, 0x0e, 0x06, 0x43, 0xac, 0x5e, 0xe2,
	0x29, 0x3a, 0x4c, 0x42, 0xac, 0xa5, 0x21, 0xfe, 0x09, 0xdc, 0x9d, 0x9d, 0x3d, 0xe7, 0xd7, 0x7f,
	0xab, 0xc1, 0x9d, 0xe6, 0xeb, 0x00, 0xbb, 0xf6, 0x2c, 0x50, 0x3e, 0x82, 0xb5, 0x14, 0x18, 0xaa,
	0x0c, 0x25, 0x36, 0x01, 0x02, 0xfa, 0x02, 0x56, 0xa3, 0xe7, 0x2a, 0xbf, 0xa1, 0x8b, 0xb2, 0xdc,
	0x2c, 0xe5, 0x15, 0x15, 0x7f, 0x6a, 0x05, 0xb8, 0x76, 0x17, 0x2a, 0xb3, 0x16, 0x21, 0xf7, 0x50,
	0xfb, 0x04, 0x36, 0x15, 0xc0, 0xa2, 0xa6, 0x2c, 0x5a, 0xdd, 0x0e, 0x14, 0xa2, 0x3b, 0x8a, 0xac,
	0x51, 0xce, 0xc8, 0x53, 0x79, 0x3b, 0x61, 0xb5, 0x87, 0xb0, 0x95, 0x4a, 0x52, 0x88, 0xdc, 0x94,
	0x75, 0xff, 0x8f, 0x1a, 0x14, 0xda, 0x3e, 0x75, 0x28, 0x27, 0x0e, 0x2a, 0x42, 0xa1, 0x6d, 0x9c,
	0x3f, 0x3d, 0xef, 0xb4, 0xce, 0x9f, 0x95, 0x17, 0xd0, 0x16, 0xac, 0x8f, 0x4d, 0xb3, 0xd3, 0x6c,
	0x9c, 0x3c, 0x69, 0x1a, 0x65, 0x0d, 0x6d, 0x03, 0x8a, 0xdd, 0x46, 0xf3, 0x71, 0xd3, 0x30, 0x1a,
	0x67, 0xe5, 0x0c, 0x2a, 0xc3, 0x6a, 0xec, 0x3f, 0x3b, 0x2d, 0x2f, 0x4e, 0x7a, 0x2e, 0x4e, 0xca,
	0x59, 0xb4, 0x0e, 0xc5, 0xd8, 0xf3, 0xb3, 0xf3, 0xb3, 0x72, 0x0e, 0xe9, 0xb0, 0x19, 0xbb, 0x1a,
	0x27, 0x9d, 0xd6, 0x8b, 0x86, 0xf8, 0xfe, 0xd2, 0x7d, 0x0c, 0xeb, 0x62, 0x6d, 0xa7, 0xea, 0x2d,
	0x2d, 0xd6, 0xb8, 0x0f, 0x1f, 0xc6, 0xe1, 0xa7, 0xad, 0x8b, 0x93, 0xf3, 0xe7, 0xcf, 0x3a, 0x66,
	0xe7, 0x17, 0xed, 0xa6, 0xf9, 0xb8, 0xf5, 0xf3, 0xe6, 0xa9, 0xd9, 0x78, 0xca, 0x3d, 0xe5, 0x05,
	0xf4, 0xff, 0x50, 0xbb, 0x2e, 0xb2, 0xdd, 0x34, 0x4e, 0x9a, 0xcf, 0x3a, 0x8d, 0xaf, 0x9a, 0x65,
	0xed, 0xfe, 0x19, 0xac, 0x88, 0xcf, 0xc8, 0xde, 0x89, 0xaa, 0x50, 0x49, 0x2c, 0xba, 0xd3, 0xe8,
	0x3c, 0xbf, 0x30, 0xdb, 0xcf, 0x8f, 0xcf, 0x5a, 0x17, 0x4f, 0x9a, 0xa7, 0xe5, 0x05, 0xb4, 0x0b,
	0x77, 0xa6, 0xc6, 0x1b, 0xc6, 0xc9, 0x93, 0xd6, 0x8b, 0xe6, 0x69, 0x59, 0x3b, 0xfa, 0x6f, 0x16,
	0x36, 0x26, 0x3a, 0x32, 0xf6, 0x2f, 0x49, 0x0f, 0xa3, 0x3e, 0xac, 0x4f, 0x35, 0x4f, 0xf4, 0x51,
	0xfa, 0x70, 0xbb, 0xa6, 0x59, 0x57, 0xf6, 0x6f, 0x0f, 0x54, 0xe5, 0xfe, 0x1a, 0x8a, 0x13, 0xbd,
	0x0d, 0x7d, 0x30, 0x33, 0x75, 0x52, 0x75, 0x95, 0x0f, 0x6f, 0x0e, 0x52, 0x73, 0x0f, 0x61, 0x63,
	0x86, 0xf2, 0xd1, 0x41, 0x2a, 0xf9, 0xfa, 0xae, 0x53, 0xb9, 0x3f, 0x4f, 0xa8, 0xfa, 0x1a, 0x85,
	0xcd, 0x59, 0x52, 0x47, 0xe9, 0x39, 0x6e, 0xe8, 0x26, 0x95, 0x1f, 0xcc, 0x15, 0xab, 0x3e, 0x48,
	0x00, 0x4d, 0xab, 0x12, 0xa5, 0xa1, 0xbf, 0xb6, 0x7b, 0x54, 0x0e, 0xe6, 0x88, 0x8c, 0xab, 0x34,
	0xa1, 0xd6, 0xa9, 0x2a, 0xcd, 0x6a, 0x00, 0x53, 0x55, 0x9a, 0x29, 0xf8, 0x63, 0xf7, 0xcd, 0xdb,
	0xea, 0xc2, 0xb7, 0x6f, 0xab, 0x0b, 0xdf, 0xbd, 0xad, 0x6a, 0xbf, 0xb9, 0xaa, 0x6a, 0x7f, 0xb9,
	0xaa, 0x6a, 0x7f, 0xbf, 0xaa, 0x6a, 0x6f, 0xae, 0xaa, 0xda, 0xbf, 0xae, 0xaa, 0xda, 0x7f, 0xae,
	0xaa, 0x0b, 0xdf, 0x5d, 0x55, 0xb5, 0xdf, 0xbf, 0xab, 0x2e, 0xfc, 0xed, 0x5d, 0x55, 0x7b, 0xf3,
	0xae, 0xba, 0xf0, 0xed, 0xbb, 0xea, 0xc2, 0xd7, 0x0f, 0x13, 0xff, 0xc5, 0xab, 0x2f, 0x7d, 0xcc,
	0x7f, 0xf3, 0xf7, 0x21, 0x76, 0xed, 0x43, 0xef, 0xd5, 0xe0, 0x70, 0x80, 0x5d, 0xf9, 0xa7, 0xbc,
	0x58, 0xc2, 0x23, 0xaf, 0xdb, 0x5d, 0x12, 0xf6, 0x27, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x35,
	0x51, 0x5d, 0xad, 0x4e, 0x18, 0x00, 0x00,
}

func (x PromoType) String() string {
	s, ok := PromoType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PromoDiscountType) String() string {
	s, ok := PromoDiscountType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PromoStatus) String() string {
	s, ok := PromoStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Plan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Plan)
	if !ok {
		that2, ok := that.(Plan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.AdvertisedPrice != that1.AdvertisedPrice {
		return false
	}
	if this.IsPurchasable != that1.IsPurchasable {
		return false
	}
	if len(this.UpgradeableTo) != len(that1.UpgradeableTo) {
		return false
	}
	for i := range this.UpgradeableTo {
		if this.UpgradeableTo[i] != that1.UpgradeableTo[i] {
			return false
		}
	}
	if len(this.Benefits) != len(that1.Benefits) {
		return false
	}
	for i := range this.Benefits {
		if this.Benefits[i] != that1.Benefits[i] {
			return false
		}
	}
	if this.PrioritizeLevel != that1.PrioritizeLevel {
		return false
	}
	if this.IsHidden != that1.IsHidden {
		return false
	}
	return true
}
func (this *Package) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Package)
	if !ok {
		that2, ok := that.(Package)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.DiscountedPrice != that1.DiscountedPrice {
		return false
	}
	if len(this.Description) != len(that1.Description) {
		return false
	}
	for i := range this.Description {
		if this.Description[i] != that1.Description[i] {
			return false
		}
	}
	if this.Notice != that1.Notice {
		return false
	}
	if !this.Period.Equal(that1.Period) {
		return false
	}
	if this.IsRecommended != that1.IsRecommended {
		return false
	}
	if this.IsEnabled != that1.IsEnabled {
		return false
	}
	if this.IsHidden != that1.IsHidden {
		return false
	}
	if this.CarriedOverAmount != that1.CarriedOverAmount {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	if this.PrioritizeLevel != that1.PrioritizeLevel {
		return false
	}
	if len(this.PackageItems) != len(that1.PackageItems) {
		return false
	}
	for i := range this.PackageItems {
		if !this.PackageItems[i].Equal(that1.PackageItems[i]) {
			return false
		}
	}
	if len(this.UpgradableFrom) != len(that1.UpgradableFrom) {
		return false
	}
	for i := range this.UpgradableFrom {
		if this.UpgradableFrom[i] != that1.UpgradableFrom[i] {
			return false
		}
	}
	return true
}
func (this *PackageItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PackageItem)
	if !ok {
		that2, ok := that.(PackageItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if !this.ExpiredAt.Equal(that1.ExpiredAt) {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if len(this.Subject) != len(that1.Subject) {
		return false
	}
	for i := range this.Subject {
		if this.Subject[i] != that1.Subject[i] {
			return false
		}
	}
	if len(this.Grades) != len(that1.Grades) {
		return false
	}
	for i := range this.Grades {
		if this.Grades[i] != that1.Grades[i] {
			return false
		}
	}
	if this.Price != that1.Price {
		return false
	}
	if this.DiscountedPrice != that1.DiscountedPrice {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if this.PlanName != that1.PlanName {
		return false
	}
	if this.ManualCreatedBy != that1.ManualCreatedBy {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Coupon != that1.Coupon {
		return false
	}
	if this.CouponAmount != that1.CouponAmount {
		return false
	}
	if this.CarriedOverAmount != that1.CarriedOverAmount {
		return false
	}
	if this.CarriedOverFrom != that1.CarriedOverFrom {
		return false
	}
	if !this.Start.Equal(that1.Start) {
		return false
	}
	if !this.End.Equal(that1.End) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Currency != that1.Currency {
		return false
	}
	if this.PaymentMethod != that1.PaymentMethod {
		return false
	}
	if this.PaymentLink != that1.PaymentLink {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	if this.PackageName != that1.PackageName {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	if this.StudentId != that1.StudentId {
		return false
	}
	if this.ReferenceNumber != that1.ReferenceNumber {
		return false
	}
	if !this.CodOrderInfo.Equal(that1.CodOrderInfo) {
		return false
	}
	if !this.MustPayBefore.Equal(that1.MustPayBefore) {
		return false
	}
	if len(this.Subscriptions) != len(that1.Subscriptions) {
		return false
	}
	for i := range this.Subscriptions {
		if !this.Subscriptions[i].Equal(that1.Subscriptions[i]) {
			return false
		}
	}
	if this.GatewayFullFeedback != that1.GatewayFullFeedback {
		return false
	}
	if this.GatewayLink != that1.GatewayLink {
		return false
	}
	if this.GatewayName != that1.GatewayName {
		return false
	}
	if this.GatewayResponse != that1.GatewayResponse {
		return false
	}
	if this.CreatedByEmail != that1.CreatedByEmail {
		return false
	}
	if this.IsManualCreated != that1.IsManualCreated {
		return false
	}
	return true
}
func (this *ManualOrder) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ManualOrder)
	if !ok {
		that2, ok := that.(ManualOrder)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StudentOrderId != that1.StudentOrderId {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	if !this.Currency.Equal(that1.Currency) {
		return false
	}
	if !this.PaymentMethod.Equal(that1.PaymentMethod) {
		return false
	}
	if !this.StudentId.Equal(that1.StudentId) {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	if !this.PackageName.Equal(that1.PackageName) {
		return false
	}
	if !this.PlanId.Equal(that1.PlanId) {
		return false
	}
	if !this.Coupon.Equal(that1.Coupon) {
		return false
	}
	if this.CouponAmount != that1.CouponAmount {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	if this.CreatedByEmail != that1.CreatedByEmail {
		return false
	}
	if !this.Start.Equal(that1.Start) {
		return false
	}
	if !this.End.Equal(that1.End) {
		return false
	}
	return true
}
func (this *CodOrderInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CodOrderInfo)
	if !ok {
		that2, ok := that.(CodOrderInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomerName != that1.CustomerName {
		return false
	}
	if this.CustomerPhoneNumber != that1.CustomerPhoneNumber {
		return false
	}
	if this.CustomerAddress != that1.CustomerAddress {
		return false
	}
	if !this.ExpectedDeliveryTime.Equal(that1.ExpectedDeliveryTime) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *StudentSubscription) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StudentSubscription)
	if !ok {
		that2, ok := that.(StudentSubscription)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PlanId != that1.PlanId {
		return false
	}
	if len(this.Grades) != len(that1.Grades) {
		return false
	}
	for i := range this.Grades {
		if this.Grades[i] != that1.Grades[i] {
			return false
		}
	}
	if len(this.Subjects) != len(that1.Subjects) {
		return false
	}
	for i := range this.Subjects {
		if this.Subjects[i] != that1.Subjects[i] {
			return false
		}
	}
	if !this.Start.Equal(that1.Start) {
		return false
	}
	if !this.End.Equal(that1.End) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *CreateManualOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateManualOrderRequest)
	if !ok {
		that2, ok := that.(CreateManualOrderRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Order.Equal(that1.Order) {
		return false
	}
	return true
}
func (this *CreateManualOrderResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateManualOrderResponse)
	if !ok {
		that2, ok := that.(CreateManualOrderResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *CreatePackageRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreatePackageRequest)
	if !ok {
		that2, ok := that.(CreatePackageRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Package.Equal(that1.Package) {
		return false
	}
	if len(this.PackageItems) != len(that1.PackageItems) {
		return false
	}
	for i := range this.PackageItems {
		if !this.PackageItems[i].Equal(that1.PackageItems[i]) {
			return false
		}
	}
	return true
}
func (this *CreatePackageResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreatePackageResponse)
	if !ok {
		that2, ok := that.(CreatePackageResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	return true
}
func (this *Pagination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Pagination)
	if !ok {
		that2, ok := that.(Pagination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	return true
}
func (this *Sort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sort)
	if !ok {
		that2, ok := that.(Sort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if this.Order != that1.Order {
		return false
	}
	return true
}
func (this *DisableSubscriptionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DisableSubscriptionRequest)
	if !ok {
		that2, ok := that.(DisableSubscriptionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StudentSubscriptionIds) != len(that1.StudentSubscriptionIds) {
		return false
	}
	for i := range this.StudentSubscriptionIds {
		if this.StudentSubscriptionIds[i] != that1.StudentSubscriptionIds[i] {
			return false
		}
	}
	return true
}
func (this *DisableSubscriptionResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DisableSubscriptionResponse)
	if !ok {
		that2, ok := that.(DisableSubscriptionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *ToggleEnabledPackageRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToggleEnabledPackageRequest)
	if !ok {
		that2, ok := that.(ToggleEnabledPackageRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PackageId != that1.PackageId {
		return false
	}
	return true
}
func (this *ToggleEnabledPackageResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToggleEnabledPackageResponse)
	if !ok {
		that2, ok := that.(ToggleEnabledPackageResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Successful != that1.Successful {
		return false
	}
	return true
}
func (this *ExtendSubscriptionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtendSubscriptionRequest)
	if !ok {
		that2, ok := that.(ExtendSubscriptionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscriptionId != that1.SubscriptionId {
		return false
	}
	if !this.ExpiredDate.Equal(that1.ExpiredDate) {
		return false
	}
	return true
}
func (this *ExtendSubscriptionResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExtendSubscriptionResponse)
	if !ok {
		that2, ok := that.(ExtendSubscriptionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DisableOrdersRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DisableOrdersRequest)
	if !ok {
		that2, ok := that.(DisableOrdersRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.OrderIds) != len(that1.OrderIds) {
		return false
	}
	for i := range this.OrderIds {
		if this.OrderIds[i] != that1.OrderIds[i] {
			return false
		}
	}
	return true
}
func (this *DisableOrdersResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DisableOrdersResponse)
	if !ok {
		that2, ok := that.(DisableOrdersResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.OrderIds) != len(that1.OrderIds) {
		return false
	}
	for i := range this.OrderIds {
		if this.OrderIds[i] != that1.OrderIds[i] {
			return false
		}
	}
	return true
}
func (this *Plan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&pb.Plan{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "AdvertisedPrice: "+fmt.Sprintf("%#v", this.AdvertisedPrice)+",\n")
	s = append(s, "IsPurchasable: "+fmt.Sprintf("%#v", this.IsPurchasable)+",\n")
	s = append(s, "UpgradeableTo: "+fmt.Sprintf("%#v", this.UpgradeableTo)+",\n")
	s = append(s, "Benefits: "+fmt.Sprintf("%#v", this.Benefits)+",\n")
	s = append(s, "PrioritizeLevel: "+fmt.Sprintf("%#v", this.PrioritizeLevel)+",\n")
	s = append(s, "IsHidden: "+fmt.Sprintf("%#v", this.IsHidden)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Package) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&pb.Package{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "DiscountedPrice: "+fmt.Sprintf("%#v", this.DiscountedPrice)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Notice: "+fmt.Sprintf("%#v", this.Notice)+",\n")
	if this.Period != nil {
		s = append(s, "Period: "+fmt.Sprintf("%#v", this.Period)+",\n")
	}
	s = append(s, "IsRecommended: "+fmt.Sprintf("%#v", this.IsRecommended)+",\n")
	s = append(s, "IsEnabled: "+fmt.Sprintf("%#v", this.IsEnabled)+",\n")
	s = append(s, "IsHidden: "+fmt.Sprintf("%#v", this.IsHidden)+",\n")
	s = append(s, "CarriedOverAmount: "+fmt.Sprintf("%#v", this.CarriedOverAmount)+",\n")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "PrioritizeLevel: "+fmt.Sprintf("%#v", this.PrioritizeLevel)+",\n")
	if this.PackageItems != nil {
		s = append(s, "PackageItems: "+fmt.Sprintf("%#v", this.PackageItems)+",\n")
	}
	s = append(s, "UpgradableFrom: "+fmt.Sprintf("%#v", this.UpgradableFrom)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PackageItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&pb.PackageItem{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	if this.ExpiredAt != nil {
		s = append(s, "ExpiredAt: "+fmt.Sprintf("%#v", this.ExpiredAt)+",\n")
	}
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	s = append(s, "Subject: "+fmt.Sprintf("%#v", this.Subject)+",\n")
	s = append(s, "Grades: "+fmt.Sprintf("%#v", this.Grades)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "DiscountedPrice: "+fmt.Sprintf("%#v", this.DiscountedPrice)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 35)
	s = append(s, "&pb.Order{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	s = append(s, "PlanName: "+fmt.Sprintf("%#v", this.PlanName)+",\n")
	s = append(s, "ManualCreatedBy: "+fmt.Sprintf("%#v", this.ManualCreatedBy)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Coupon: "+fmt.Sprintf("%#v", this.Coupon)+",\n")
	s = append(s, "CouponAmount: "+fmt.Sprintf("%#v", this.CouponAmount)+",\n")
	s = append(s, "CarriedOverAmount: "+fmt.Sprintf("%#v", this.CarriedOverAmount)+",\n")
	s = append(s, "CarriedOverFrom: "+fmt.Sprintf("%#v", this.CarriedOverFrom)+",\n")
	if this.Start != nil {
		s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	}
	if this.End != nil {
		s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	}
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "PaymentMethod: "+fmt.Sprintf("%#v", this.PaymentMethod)+",\n")
	s = append(s, "PaymentLink: "+fmt.Sprintf("%#v", this.PaymentLink)+",\n")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "PackageName: "+fmt.Sprintf("%#v", this.PackageName)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "StudentId: "+fmt.Sprintf("%#v", this.StudentId)+",\n")
	s = append(s, "ReferenceNumber: "+fmt.Sprintf("%#v", this.ReferenceNumber)+",\n")
	if this.CodOrderInfo != nil {
		s = append(s, "CodOrderInfo: "+fmt.Sprintf("%#v", this.CodOrderInfo)+",\n")
	}
	if this.MustPayBefore != nil {
		s = append(s, "MustPayBefore: "+fmt.Sprintf("%#v", this.MustPayBefore)+",\n")
	}
	if this.Subscriptions != nil {
		s = append(s, "Subscriptions: "+fmt.Sprintf("%#v", this.Subscriptions)+",\n")
	}
	s = append(s, "GatewayFullFeedback: "+fmt.Sprintf("%#v", this.GatewayFullFeedback)+",\n")
	s = append(s, "GatewayLink: "+fmt.Sprintf("%#v", this.GatewayLink)+",\n")
	s = append(s, "GatewayName: "+fmt.Sprintf("%#v", this.GatewayName)+",\n")
	s = append(s, "GatewayResponse: "+fmt.Sprintf("%#v", this.GatewayResponse)+",\n")
	s = append(s, "CreatedByEmail: "+fmt.Sprintf("%#v", this.CreatedByEmail)+",\n")
	s = append(s, "IsManualCreated: "+fmt.Sprintf("%#v", this.IsManualCreated)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ManualOrder) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&pb.ManualOrder{")
	s = append(s, "StudentOrderId: "+fmt.Sprintf("%#v", this.StudentOrderId)+",\n")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	if this.Currency != nil {
		s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	}
	if this.PaymentMethod != nil {
		s = append(s, "PaymentMethod: "+fmt.Sprintf("%#v", this.PaymentMethod)+",\n")
	}
	if this.StudentId != nil {
		s = append(s, "StudentId: "+fmt.Sprintf("%#v", this.StudentId)+",\n")
	}
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	if this.PackageName != nil {
		s = append(s, "PackageName: "+fmt.Sprintf("%#v", this.PackageName)+",\n")
	}
	if this.PlanId != nil {
		s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	}
	if this.Coupon != nil {
		s = append(s, "Coupon: "+fmt.Sprintf("%#v", this.Coupon)+",\n")
	}
	s = append(s, "CouponAmount: "+fmt.Sprintf("%#v", this.CouponAmount)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "CreatedByEmail: "+fmt.Sprintf("%#v", this.CreatedByEmail)+",\n")
	if this.Start != nil {
		s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	}
	if this.End != nil {
		s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodOrderInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.CodOrderInfo{")
	s = append(s, "CustomerName: "+fmt.Sprintf("%#v", this.CustomerName)+",\n")
	s = append(s, "CustomerPhoneNumber: "+fmt.Sprintf("%#v", this.CustomerPhoneNumber)+",\n")
	s = append(s, "CustomerAddress: "+fmt.Sprintf("%#v", this.CustomerAddress)+",\n")
	if this.ExpectedDeliveryTime != nil {
		s = append(s, "ExpectedDeliveryTime: "+fmt.Sprintf("%#v", this.ExpectedDeliveryTime)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StudentSubscription) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&pb.StudentSubscription{")
	s = append(s, "PlanId: "+fmt.Sprintf("%#v", this.PlanId)+",\n")
	s = append(s, "Grades: "+fmt.Sprintf("%#v", this.Grades)+",\n")
	s = append(s, "Subjects: "+fmt.Sprintf("%#v", this.Subjects)+",\n")
	if this.Start != nil {
		s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	}
	if this.End != nil {
		s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateManualOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.CreateManualOrderRequest{")
	if this.Order != nil {
		s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateManualOrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.CreateManualOrderResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreatePackageRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.CreatePackageRequest{")
	if this.Package != nil {
		s = append(s, "Package: "+fmt.Sprintf("%#v", this.Package)+",\n")
	}
	if this.PackageItems != nil {
		s = append(s, "PackageItems: "+fmt.Sprintf("%#v", this.PackageItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreatePackageResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.CreatePackageResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pagination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.Pagination{")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.Sort{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DisableSubscriptionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.DisableSubscriptionRequest{")
	s = append(s, "StudentSubscriptionIds: "+fmt.Sprintf("%#v", this.StudentSubscriptionIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DisableSubscriptionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.DisableSubscriptionResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ToggleEnabledPackageRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.ToggleEnabledPackageRequest{")
	s = append(s, "PackageId: "+fmt.Sprintf("%#v", this.PackageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ToggleEnabledPackageResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.ToggleEnabledPackageResponse{")
	s = append(s, "Successful: "+fmt.Sprintf("%#v", this.Successful)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExtendSubscriptionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.ExtendSubscriptionRequest{")
	s = append(s, "SubscriptionId: "+fmt.Sprintf("%#v", this.SubscriptionId)+",\n")
	if this.ExpiredDate != nil {
		s = append(s, "ExpiredDate: "+fmt.Sprintf("%#v", this.ExpiredDate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExtendSubscriptionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&pb.ExtendSubscriptionResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DisableOrdersRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.DisableOrdersRequest{")
	s = append(s, "OrderIds: "+fmt.Sprintf("%#v", this.OrderIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DisableOrdersResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.DisableOrdersResponse{")
	s = append(s, "OrderIds: "+fmt.Sprintf("%#v", this.OrderIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringYssubscription(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SubscriptionServiceClient is the client API for SubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubscriptionServiceClient interface {
	CreateManualOrder(ctx context.Context, in *CreateManualOrderRequest, opts ...grpc.CallOption) (*CreateManualOrderResponse, error)
	CreatePackage(ctx context.Context, in *CreatePackageRequest, opts ...grpc.CallOption) (*CreatePackageResponse, error)
	DisableSubscription(ctx context.Context, in *DisableSubscriptionRequest, opts ...grpc.CallOption) (*DisableSubscriptionResponse, error)
	ToggleEnabledPackage(ctx context.Context, in *ToggleEnabledPackageRequest, opts ...grpc.CallOption) (*ToggleEnabledPackageResponse, error)
	ExtendSubscription(ctx context.Context, in *ExtendSubscriptionRequest, opts ...grpc.CallOption) (*ExtendSubscriptionResponse, error)
	DisableOrders(ctx context.Context, in *DisableOrdersRequest, opts ...grpc.CallOption) (*DisableOrdersResponse, error)
}

type subscriptionServiceClient struct {
	cc *grpc.ClientConn
}

func NewSubscriptionServiceClient(cc *grpc.ClientConn) SubscriptionServiceClient {
	return &subscriptionServiceClient{cc}
}

func (c *subscriptionServiceClient) CreateManualOrder(ctx context.Context, in *CreateManualOrderRequest, opts ...grpc.CallOption) (*CreateManualOrderResponse, error) {
	out := new(CreateManualOrderResponse)
	err := c.cc.Invoke(ctx, "/manabie.yasuo.SubscriptionService/CreateManualOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) CreatePackage(ctx context.Context, in *CreatePackageRequest, opts ...grpc.CallOption) (*CreatePackageResponse, error) {
	out := new(CreatePackageResponse)
	err := c.cc.Invoke(ctx, "/manabie.yasuo.SubscriptionService/CreatePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) DisableSubscription(ctx context.Context, in *DisableSubscriptionRequest, opts ...grpc.CallOption) (*DisableSubscriptionResponse, error) {
	out := new(DisableSubscriptionResponse)
	err := c.cc.Invoke(ctx, "/manabie.yasuo.SubscriptionService/DisableSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) ToggleEnabledPackage(ctx context.Context, in *ToggleEnabledPackageRequest, opts ...grpc.CallOption) (*ToggleEnabledPackageResponse, error) {
	out := new(ToggleEnabledPackageResponse)
	err := c.cc.Invoke(ctx, "/manabie.yasuo.SubscriptionService/ToggleEnabledPackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) ExtendSubscription(ctx context.Context, in *ExtendSubscriptionRequest, opts ...grpc.CallOption) (*ExtendSubscriptionResponse, error) {
	out := new(ExtendSubscriptionResponse)
	err := c.cc.Invoke(ctx, "/manabie.yasuo.SubscriptionService/ExtendSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) DisableOrders(ctx context.Context, in *DisableOrdersRequest, opts ...grpc.CallOption) (*DisableOrdersResponse, error) {
	out := new(DisableOrdersResponse)
	err := c.cc.Invoke(ctx, "/manabie.yasuo.SubscriptionService/DisableOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscriptionServiceServer is the server API for SubscriptionService service.
type SubscriptionServiceServer interface {
	CreateManualOrder(context.Context, *CreateManualOrderRequest) (*CreateManualOrderResponse, error)
	CreatePackage(context.Context, *CreatePackageRequest) (*CreatePackageResponse, error)
	DisableSubscription(context.Context, *DisableSubscriptionRequest) (*DisableSubscriptionResponse, error)
	ToggleEnabledPackage(context.Context, *ToggleEnabledPackageRequest) (*ToggleEnabledPackageResponse, error)
	ExtendSubscription(context.Context, *ExtendSubscriptionRequest) (*ExtendSubscriptionResponse, error)
	DisableOrders(context.Context, *DisableOrdersRequest) (*DisableOrdersResponse, error)
}

// UnimplementedSubscriptionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSubscriptionServiceServer struct {
}

func (*UnimplementedSubscriptionServiceServer) CreateManualOrder(ctx context.Context, req *CreateManualOrderRequest) (*CreateManualOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateManualOrder not implemented")
}
func (*UnimplementedSubscriptionServiceServer) CreatePackage(ctx context.Context, req *CreatePackageRequest) (*CreatePackageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePackage not implemented")
}
func (*UnimplementedSubscriptionServiceServer) DisableSubscription(ctx context.Context, req *DisableSubscriptionRequest) (*DisableSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableSubscription not implemented")
}
func (*UnimplementedSubscriptionServiceServer) ToggleEnabledPackage(ctx context.Context, req *ToggleEnabledPackageRequest) (*ToggleEnabledPackageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleEnabledPackage not implemented")
}
func (*UnimplementedSubscriptionServiceServer) ExtendSubscription(ctx context.Context, req *ExtendSubscriptionRequest) (*ExtendSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtendSubscription not implemented")
}
func (*UnimplementedSubscriptionServiceServer) DisableOrders(ctx context.Context, req *DisableOrdersRequest) (*DisableOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableOrders not implemented")
}

func RegisterSubscriptionServiceServer(s *grpc.Server, srv SubscriptionServiceServer) {
	s.RegisterService(&_SubscriptionService_serviceDesc, srv)
}

func _SubscriptionService_CreateManualOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateManualOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).CreateManualOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.yasuo.SubscriptionService/CreateManualOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).CreateManualOrder(ctx, req.(*CreateManualOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_CreatePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).CreatePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.yasuo.SubscriptionService/CreatePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).CreatePackage(ctx, req.(*CreatePackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_DisableSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).DisableSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.yasuo.SubscriptionService/DisableSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).DisableSubscription(ctx, req.(*DisableSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_ToggleEnabledPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleEnabledPackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).ToggleEnabledPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.yasuo.SubscriptionService/ToggleEnabledPackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).ToggleEnabledPackage(ctx, req.(*ToggleEnabledPackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_ExtendSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtendSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).ExtendSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.yasuo.SubscriptionService/ExtendSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).ExtendSubscription(ctx, req.(*ExtendSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_DisableOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).DisableOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manabie.yasuo.SubscriptionService/DisableOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).DisableOrders(ctx, req.(*DisableOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SubscriptionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "manabie.yasuo.SubscriptionService",
	HandlerType: (*SubscriptionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateManualOrder",
			Handler:    _SubscriptionService_CreateManualOrder_Handler,
		},
		{
			MethodName: "CreatePackage",
			Handler:    _SubscriptionService_CreatePackage_Handler,
		},
		{
			MethodName: "DisableSubscription",
			Handler:    _SubscriptionService_DisableSubscription_Handler,
		},
		{
			MethodName: "ToggleEnabledPackage",
			Handler:    _SubscriptionService_ToggleEnabledPackage_Handler,
		},
		{
			MethodName: "ExtendSubscription",
			Handler:    _SubscriptionService_ExtendSubscription_Handler,
		},
		{
			MethodName: "DisableOrders",
			Handler:    _SubscriptionService_DisableOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "yssubscription.proto",
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.PrioritizeLevel != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.PrioritizeLevel))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Benefits) > 0 {
		for iNdEx := len(m.Benefits) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Benefits[iNdEx])
			copy(dAtA[i:], m.Benefits[iNdEx])
			i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Benefits[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.UpgradeableTo) > 0 {
		for iNdEx := len(m.UpgradeableTo) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpgradeableTo[iNdEx])
			copy(dAtA[i:], m.UpgradeableTo[iNdEx])
			i = encodeVarintYssubscription(dAtA, i, uint64(len(m.UpgradeableTo[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IsPurchasable {
		i--
		if m.IsPurchasable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.AdvertisedPrice) > 0 {
		i -= len(m.AdvertisedPrice)
		copy(dAtA[i:], m.AdvertisedPrice)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.AdvertisedPrice)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Package) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Package) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Package) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpgradableFrom) > 0 {
		dAtA2 := make([]byte, len(m.UpgradableFrom)*10)
		var j1 int
		for _, num1 := range m.UpgradableFrom {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintYssubscription(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.PackageItems) > 0 {
		for iNdEx := len(m.PackageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintYssubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.PrioritizeLevel != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.PrioritizeLevel))
		i--
		dAtA[i] = 0x70
	}
	if m.Country != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x68
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0x62
	}
	if m.CarriedOverAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CarriedOverAmount))))
		i--
		dAtA[i] = 0x59
	}
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IsEnabled {
		i--
		if m.IsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IsRecommended {
		i--
		if m.IsRecommended {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Period != nil {
		{
			size, err := m.Period.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Notice) > 0 {
		i -= len(m.Notice)
		copy(dAtA[i:], m.Notice)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Notice)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		for iNdEx := len(m.Description) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Description[iNdEx])
			copy(dAtA[i:], m.Description[iNdEx])
			i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Description[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DiscountedPrice != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.DiscountedPrice))
		i--
		dAtA[i] = 0x20
	}
	if m.Price != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PackageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PackageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Country != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x50
	}
	if m.DiscountedPrice != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.DiscountedPrice))
		i--
		dAtA[i] = 0x48
	}
	if m.Price != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Grades) > 0 {
		dAtA5 := make([]byte, len(m.Grades)*10)
		var j4 int
		for _, num1 := range m.Grades {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintYssubscription(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Subject) > 0 {
		dAtA7 := make([]byte, len(m.Subject)*10)
		var j6 int
		for _, num := range m.Subject {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintYssubscription(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x32
	}
	if m.Duration != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpiredAt != nil {
		{
			size, err := m.ExpiredAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PackageId != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsManualCreated {
		i--
		if m.IsManualCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.CreatedByEmail) > 0 {
		i -= len(m.CreatedByEmail)
		copy(dAtA[i:], m.CreatedByEmail)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.CreatedByEmail)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.GatewayResponse) > 0 {
		i -= len(m.GatewayResponse)
		copy(dAtA[i:], m.GatewayResponse)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.GatewayResponse)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.GatewayName != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.GatewayName))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if len(m.GatewayLink) > 0 {
		i -= len(m.GatewayLink)
		copy(dAtA[i:], m.GatewayLink)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.GatewayLink)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.GatewayFullFeedback) > 0 {
		i -= len(m.GatewayFullFeedback)
		copy(dAtA[i:], m.GatewayFullFeedback)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.GatewayFullFeedback)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.Subscriptions) > 0 {
		for iNdEx := len(m.Subscriptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subscriptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintYssubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.MustPayBefore != nil {
		{
			size, err := m.MustPayBefore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.CodOrderInfo != nil {
		{
			size, err := m.CodOrderInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ReferenceNumber) > 0 {
		i -= len(m.ReferenceNumber)
		copy(dAtA[i:], m.ReferenceNumber)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.ReferenceNumber)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.StudentId) > 0 {
		i -= len(m.StudentId)
		copy(dAtA[i:], m.StudentId)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.StudentId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Country != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.PackageName) > 0 {
		i -= len(m.PackageName)
		copy(dAtA[i:], m.PackageName)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PackageName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.PackageId != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.PaymentLink) > 0 {
		i -= len(m.PaymentLink)
		copy(dAtA[i:], m.PaymentLink)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PaymentLink)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PaymentMethod) > 0 {
		i -= len(m.PaymentMethod)
		copy(dAtA[i:], m.PaymentMethod)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PaymentMethod)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x7a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CarriedOverFrom != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.CarriedOverFrom))
		i--
		dAtA[i] = 0x50
	}
	if m.CarriedOverAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CarriedOverAmount))))
		i--
		dAtA[i] = 0x49
	}
	if m.CouponAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CouponAmount))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.Coupon) > 0 {
		i -= len(m.Coupon)
		copy(dAtA[i:], m.Coupon)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Coupon)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ManualCreatedBy) > 0 {
		i -= len(m.ManualCreatedBy)
		copy(dAtA[i:], m.ManualCreatedBy)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.ManualCreatedBy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PlanName) > 0 {
		i -= len(m.PlanName)
		copy(dAtA[i:], m.PlanName)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PlanName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x11
	}
	if m.Id != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ManualOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManualOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CreatedByEmail) > 0 {
		i -= len(m.CreatedByEmail)
		copy(dAtA[i:], m.CreatedByEmail)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.CreatedByEmail)))
		i--
		dAtA[i] = 0x62
	}
	if m.Country != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Country))
		i--
		dAtA[i] = 0x58
	}
	if m.CouponAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CouponAmount))))
		i--
		dAtA[i] = 0x51
	}
	if m.Coupon != nil {
		{
			size, err := m.Coupon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.PlanId != nil {
		{
			size, err := m.PlanId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PackageName != nil {
		{
			size, err := m.PackageName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PackageId != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x30
	}
	if m.StudentId != nil {
		{
			size, err := m.StudentId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PaymentMethod != nil {
		{
			size, err := m.PaymentMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Currency != nil {
		{
			size, err := m.Currency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x11
	}
	if m.StudentOrderId != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.StudentOrderId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CodOrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodOrderInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodOrderInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpectedDeliveryTime != nil {
		{
			size, err := m.ExpectedDeliveryTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CustomerPhoneNumber) > 0 {
		i -= len(m.CustomerPhoneNumber)
		copy(dAtA[i:], m.CustomerPhoneNumber)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.CustomerPhoneNumber)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CustomerName) > 0 {
		i -= len(m.CustomerName)
		copy(dAtA[i:], m.CustomerName)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.CustomerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StudentSubscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StudentSubscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StudentSubscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Subjects) > 0 {
		dAtA27 := make([]byte, len(m.Subjects)*10)
		var j26 int
		for _, num := range m.Subjects {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintYssubscription(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grades) > 0 {
		dAtA29 := make([]byte, len(m.Grades)*10)
		var j28 int
		for _, num1 := range m.Grades {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintYssubscription(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlanId) > 0 {
		i -= len(m.PlanId)
		copy(dAtA[i:], m.PlanId)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.PlanId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateManualOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateManualOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateManualOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateManualOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateManualOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateManualOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreatePackageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePackageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePackageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PackageItems) > 0 {
		for iNdEx := len(m.PackageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintYssubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Package != nil {
		{
			size, err := m.Package.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreatePackageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePackageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePackageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PackageId != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x10
	}
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pagination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pagination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pagination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DisableSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisableSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StudentSubscriptionIds) > 0 {
		for iNdEx := len(m.StudentSubscriptionIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StudentSubscriptionIds[iNdEx])
			copy(dAtA[i:], m.StudentSubscriptionIds[iNdEx])
			i = encodeVarintYssubscription(dAtA, i, uint64(len(m.StudentSubscriptionIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DisableSubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableSubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisableSubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ToggleEnabledPackageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToggleEnabledPackageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToggleEnabledPackageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PackageId != 0 {
		i = encodeVarintYssubscription(dAtA, i, uint64(m.PackageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ToggleEnabledPackageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToggleEnabledPackageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToggleEnabledPackageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Successful {
		i--
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtendSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtendSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiredDate != nil {
		{
			size, err := m.ExpiredDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintYssubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubscriptionId) > 0 {
		i -= len(m.SubscriptionId)
		copy(dAtA[i:], m.SubscriptionId)
		i = encodeVarintYssubscription(dAtA, i, uint64(len(m.SubscriptionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtendSubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendSubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtendSubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DisableOrdersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableOrdersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisableOrdersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		dAtA34 := make([]byte, len(m.OrderIds)*10)
		var j33 int
		for _, num1 := range m.OrderIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintYssubscription(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DisableOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisableOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisableOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		dAtA36 := make([]byte, len(m.OrderIds)*10)
		var j35 int
		for _, num1 := range m.OrderIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintYssubscription(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintYssubscription(dAtA []byte, offset int, v uint64) int {
	offset -= sovYssubscription(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Plan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.AdvertisedPrice)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.IsPurchasable {
		n += 2
	}
	if len(m.UpgradeableTo) > 0 {
		for _, s := range m.UpgradeableTo {
			l = len(s)
			n += 1 + l + sovYssubscription(uint64(l))
		}
	}
	if len(m.Benefits) > 0 {
		for _, s := range m.Benefits {
			l = len(s)
			n += 1 + l + sovYssubscription(uint64(l))
		}
	}
	if m.PrioritizeLevel != 0 {
		n += 1 + sovYssubscription(uint64(m.PrioritizeLevel))
	}
	if m.IsHidden {
		n += 2
	}
	return n
}

func (m *Package) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovYssubscription(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovYssubscription(uint64(m.Price))
	}
	if m.DiscountedPrice != 0 {
		n += 1 + sovYssubscription(uint64(m.DiscountedPrice))
	}
	if len(m.Description) > 0 {
		for _, s := range m.Description {
			l = len(s)
			n += 1 + l + sovYssubscription(uint64(l))
		}
	}
	l = len(m.Notice)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Period != nil {
		l = m.Period.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.IsRecommended {
		n += 2
	}
	if m.IsEnabled {
		n += 2
	}
	if m.IsHidden {
		n += 2
	}
	if m.CarriedOverAmount != 0 {
		n += 9
	}
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Country != 0 {
		n += 1 + sovYssubscription(uint64(m.Country))
	}
	if m.PrioritizeLevel != 0 {
		n += 1 + sovYssubscription(uint64(m.PrioritizeLevel))
	}
	if len(m.PackageItems) > 0 {
		for _, e := range m.PackageItems {
			l = e.Size()
			n += 1 + l + sovYssubscription(uint64(l))
		}
	}
	if len(m.UpgradableFrom) > 0 {
		l = 0
		for _, e := range m.UpgradableFrom {
			l += sovYssubscription(uint64(e))
		}
		n += 2 + sovYssubscription(uint64(l)) + l
	}
	return n
}

func (m *PackageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.PackageId != 0 {
		n += 1 + sovYssubscription(uint64(m.PackageId))
	}
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.ExpiredAt != nil {
		l = m.ExpiredAt.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovYssubscription(uint64(m.Duration))
	}
	if len(m.Subject) > 0 {
		l = 0
		for _, e := range m.Subject {
			l += sovYssubscription(uint64(e))
		}
		n += 1 + sovYssubscription(uint64(l)) + l
	}
	if len(m.Grades) > 0 {
		l = 0
		for _, e := range m.Grades {
			l += sovYssubscription(uint64(e))
		}
		n += 1 + sovYssubscription(uint64(l)) + l
	}
	if m.Price != 0 {
		n += 1 + sovYssubscription(uint64(m.Price))
	}
	if m.DiscountedPrice != 0 {
		n += 1 + sovYssubscription(uint64(m.DiscountedPrice))
	}
	if m.Country != 0 {
		n += 1 + sovYssubscription(uint64(m.Country))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovYssubscription(uint64(m.Id))
	}
	if m.Amount != 0 {
		n += 9
	}
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.PlanName)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.ManualCreatedBy)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovYssubscription(uint64(m.Status))
	}
	l = len(m.Coupon)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.CouponAmount != 0 {
		n += 9
	}
	if m.CarriedOverAmount != 0 {
		n += 9
	}
	if m.CarriedOverFrom != 0 {
		n += 1 + sovYssubscription(uint64(m.CarriedOverFrom))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.PaymentMethod)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	l = len(m.PaymentLink)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	if m.PackageId != 0 {
		n += 2 + sovYssubscription(uint64(m.PackageId))
	}
	l = len(m.PackageName)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	if m.Country != 0 {
		n += 2 + sovYssubscription(uint64(m.Country))
	}
	l = len(m.StudentId)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	l = len(m.ReferenceNumber)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	if m.CodOrderInfo != nil {
		l = m.CodOrderInfo.Size()
		n += 2 + l + sovYssubscription(uint64(l))
	}
	if m.MustPayBefore != nil {
		l = m.MustPayBefore.Size()
		n += 2 + l + sovYssubscription(uint64(l))
	}
	if len(m.Subscriptions) > 0 {
		for _, e := range m.Subscriptions {
			l = e.Size()
			n += 2 + l + sovYssubscription(uint64(l))
		}
	}
	l = len(m.GatewayFullFeedback)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	l = len(m.GatewayLink)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	if m.GatewayName != 0 {
		n += 2 + sovYssubscription(uint64(m.GatewayName))
	}
	l = len(m.GatewayResponse)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	l = len(m.CreatedByEmail)
	if l > 0 {
		n += 2 + l + sovYssubscription(uint64(l))
	}
	if m.IsManualCreated {
		n += 3
	}
	return n
}

func (m *ManualOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StudentOrderId != 0 {
		n += 1 + sovYssubscription(uint64(m.StudentOrderId))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.Currency != nil {
		l = m.Currency.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.PaymentMethod != nil {
		l = m.PaymentMethod.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.StudentId != nil {
		l = m.StudentId.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.PackageId != 0 {
		n += 1 + sovYssubscription(uint64(m.PackageId))
	}
	if m.PackageName != nil {
		l = m.PackageName.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.PlanId != nil {
		l = m.PlanId.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Coupon != nil {
		l = m.Coupon.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.CouponAmount != 0 {
		n += 9
	}
	if m.Country != 0 {
		n += 1 + sovYssubscription(uint64(m.Country))
	}
	l = len(m.CreatedByEmail)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	return n
}

func (m *CodOrderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerName)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.CustomerPhoneNumber)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.ExpectedDeliveryTime != nil {
		l = m.ExpectedDeliveryTime.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovYssubscription(uint64(m.Status))
	}
	return n
}

func (m *StudentSubscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlanId)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if len(m.Grades) > 0 {
		l = 0
		for _, e := range m.Grades {
			l += sovYssubscription(uint64(e))
		}
		n += 1 + sovYssubscription(uint64(l)) + l
	}
	if len(m.Subjects) > 0 {
		l = 0
		for _, e := range m.Subjects {
			l += sovYssubscription(uint64(e))
		}
		n += 1 + sovYssubscription(uint64(l)) + l
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovYssubscription(uint64(m.Status))
	}
	return n
}

func (m *CreateManualOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	return n
}

func (m *CreateManualOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *CreatePackageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Package != nil {
		l = m.Package.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if len(m.PackageItems) > 0 {
		for _, e := range m.PackageItems {
			l = e.Size()
			n += 1 + l + sovYssubscription(uint64(l))
		}
	}
	return n
}

func (m *CreatePackageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	if m.PackageId != 0 {
		n += 1 + sovYssubscription(uint64(m.PackageId))
	}
	return n
}

func (m *Pagination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovYssubscription(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovYssubscription(uint64(m.Offset))
	}
	return n
}

func (m *Sort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovYssubscription(uint64(m.Order))
	}
	return n
}

func (m *DisableSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StudentSubscriptionIds) > 0 {
		for _, s := range m.StudentSubscriptionIds {
			l = len(s)
			n += 1 + l + sovYssubscription(uint64(l))
		}
	}
	return n
}

func (m *DisableSubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *ToggleEnabledPackageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PackageId != 0 {
		n += 1 + sovYssubscription(uint64(m.PackageId))
	}
	return n
}

func (m *ToggleEnabledPackageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *ExtendSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubscriptionId)
	if l > 0 {
		n += 1 + l + sovYssubscription(uint64(l))
	}
	if m.ExpiredDate != nil {
		l = m.ExpiredDate.Size()
		n += 1 + l + sovYssubscription(uint64(l))
	}
	return n
}

func (m *ExtendSubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DisableOrdersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		l = 0
		for _, e := range m.OrderIds {
			l += sovYssubscription(uint64(e))
		}
		n += 1 + sovYssubscription(uint64(l)) + l
	}
	return n
}

func (m *DisableOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderIds) > 0 {
		l = 0
		for _, e := range m.OrderIds {
			l += sovYssubscription(uint64(e))
		}
		n += 1 + sovYssubscription(uint64(l)) + l
	}
	return n
}

func sovYssubscription(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozYssubscription(x uint64) (n int) {
	return sovYssubscription(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Plan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Plan{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`AdvertisedPrice:` + fmt.Sprintf("%v", this.AdvertisedPrice) + `,`,
		`IsPurchasable:` + fmt.Sprintf("%v", this.IsPurchasable) + `,`,
		`UpgradeableTo:` + fmt.Sprintf("%v", this.UpgradeableTo) + `,`,
		`Benefits:` + fmt.Sprintf("%v", this.Benefits) + `,`,
		`PrioritizeLevel:` + fmt.Sprintf("%v", this.PrioritizeLevel) + `,`,
		`IsHidden:` + fmt.Sprintf("%v", this.IsHidden) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Package) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPackageItems := "[]*PackageItem{"
	for _, f := range this.PackageItems {
		repeatedStringForPackageItems += strings.Replace(f.String(), "PackageItem", "PackageItem", 1) + ","
	}
	repeatedStringForPackageItems += "}"
	s := strings.Join([]string{`&Package{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`DiscountedPrice:` + fmt.Sprintf("%v", this.DiscountedPrice) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Notice:` + fmt.Sprintf("%v", this.Notice) + `,`,
		`Period:` + strings.Replace(fmt.Sprintf("%v", this.Period), "Timestamp", "types.Timestamp", 1) + `,`,
		`IsRecommended:` + fmt.Sprintf("%v", this.IsRecommended) + `,`,
		`IsEnabled:` + fmt.Sprintf("%v", this.IsEnabled) + `,`,
		`IsHidden:` + fmt.Sprintf("%v", this.IsHidden) + `,`,
		`CarriedOverAmount:` + fmt.Sprintf("%v", this.CarriedOverAmount) + `,`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`PrioritizeLevel:` + fmt.Sprintf("%v", this.PrioritizeLevel) + `,`,
		`PackageItems:` + repeatedStringForPackageItems + `,`,
		`UpgradableFrom:` + fmt.Sprintf("%v", this.UpgradableFrom) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PackageItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PackageItem{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`ExpiredAt:` + strings.Replace(fmt.Sprintf("%v", this.ExpiredAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Grades:` + fmt.Sprintf("%v", this.Grades) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`DiscountedPrice:` + fmt.Sprintf("%v", this.DiscountedPrice) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubscriptions := "[]*StudentSubscription{"
	for _, f := range this.Subscriptions {
		repeatedStringForSubscriptions += strings.Replace(f.String(), "StudentSubscription", "StudentSubscription", 1) + ","
	}
	repeatedStringForSubscriptions += "}"
	s := strings.Join([]string{`&Order{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Amount:` + fmt.Sprintf("%v", this.Amount) + `,`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`PlanName:` + fmt.Sprintf("%v", this.PlanName) + `,`,
		`ManualCreatedBy:` + fmt.Sprintf("%v", this.ManualCreatedBy) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Coupon:` + fmt.Sprintf("%v", this.Coupon) + `,`,
		`CouponAmount:` + fmt.Sprintf("%v", this.CouponAmount) + `,`,
		`CarriedOverAmount:` + fmt.Sprintf("%v", this.CarriedOverAmount) + `,`,
		`CarriedOverFrom:` + fmt.Sprintf("%v", this.CarriedOverFrom) + `,`,
		`Start:` + strings.Replace(fmt.Sprintf("%v", this.Start), "Timestamp", "types.Timestamp", 1) + `,`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`PaymentMethod:` + fmt.Sprintf("%v", this.PaymentMethod) + `,`,
		`PaymentLink:` + fmt.Sprintf("%v", this.PaymentLink) + `,`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`PackageName:` + fmt.Sprintf("%v", this.PackageName) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`StudentId:` + fmt.Sprintf("%v", this.StudentId) + `,`,
		`ReferenceNumber:` + fmt.Sprintf("%v", this.ReferenceNumber) + `,`,
		`CodOrderInfo:` + strings.Replace(this.CodOrderInfo.String(), "CodOrderInfo", "CodOrderInfo", 1) + `,`,
		`MustPayBefore:` + strings.Replace(fmt.Sprintf("%v", this.MustPayBefore), "Timestamp", "types.Timestamp", 1) + `,`,
		`Subscriptions:` + repeatedStringForSubscriptions + `,`,
		`GatewayFullFeedback:` + fmt.Sprintf("%v", this.GatewayFullFeedback) + `,`,
		`GatewayLink:` + fmt.Sprintf("%v", this.GatewayLink) + `,`,
		`GatewayName:` + fmt.Sprintf("%v", this.GatewayName) + `,`,
		`GatewayResponse:` + fmt.Sprintf("%v", this.GatewayResponse) + `,`,
		`CreatedByEmail:` + fmt.Sprintf("%v", this.CreatedByEmail) + `,`,
		`IsManualCreated:` + fmt.Sprintf("%v", this.IsManualCreated) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ManualOrder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ManualOrder{`,
		`StudentOrderId:` + fmt.Sprintf("%v", this.StudentOrderId) + `,`,
		`Amount:` + fmt.Sprintf("%v", this.Amount) + `,`,
		`Currency:` + strings.Replace(fmt.Sprintf("%v", this.Currency), "StringValue", "types.StringValue", 1) + `,`,
		`PaymentMethod:` + strings.Replace(fmt.Sprintf("%v", this.PaymentMethod), "StringValue", "types.StringValue", 1) + `,`,
		`StudentId:` + strings.Replace(fmt.Sprintf("%v", this.StudentId), "StringValue", "types.StringValue", 1) + `,`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`PackageName:` + strings.Replace(fmt.Sprintf("%v", this.PackageName), "StringValue", "types.StringValue", 1) + `,`,
		`PlanId:` + strings.Replace(fmt.Sprintf("%v", this.PlanId), "StringValue", "types.StringValue", 1) + `,`,
		`Coupon:` + strings.Replace(fmt.Sprintf("%v", this.Coupon), "StringValue", "types.StringValue", 1) + `,`,
		`CouponAmount:` + fmt.Sprintf("%v", this.CouponAmount) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`CreatedByEmail:` + fmt.Sprintf("%v", this.CreatedByEmail) + `,`,
		`Start:` + strings.Replace(fmt.Sprintf("%v", this.Start), "Timestamp", "types.Timestamp", 1) + `,`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodOrderInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodOrderInfo{`,
		`CustomerName:` + fmt.Sprintf("%v", this.CustomerName) + `,`,
		`CustomerPhoneNumber:` + fmt.Sprintf("%v", this.CustomerPhoneNumber) + `,`,
		`CustomerAddress:` + fmt.Sprintf("%v", this.CustomerAddress) + `,`,
		`ExpectedDeliveryTime:` + strings.Replace(fmt.Sprintf("%v", this.ExpectedDeliveryTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StudentSubscription) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StudentSubscription{`,
		`PlanId:` + fmt.Sprintf("%v", this.PlanId) + `,`,
		`Grades:` + fmt.Sprintf("%v", this.Grades) + `,`,
		`Subjects:` + fmt.Sprintf("%v", this.Subjects) + `,`,
		`Start:` + strings.Replace(fmt.Sprintf("%v", this.Start), "Timestamp", "types.Timestamp", 1) + `,`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "Timestamp", "types.Timestamp", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateManualOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateManualOrderRequest{`,
		`Order:` + strings.Replace(this.Order.String(), "ManualOrder", "ManualOrder", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateManualOrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateManualOrderResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreatePackageRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPackageItems := "[]*PackageItem{"
	for _, f := range this.PackageItems {
		repeatedStringForPackageItems += strings.Replace(f.String(), "PackageItem", "PackageItem", 1) + ","
	}
	repeatedStringForPackageItems += "}"
	s := strings.Join([]string{`&CreatePackageRequest{`,
		`Package:` + strings.Replace(this.Package.String(), "Package", "Package", 1) + `,`,
		`PackageItems:` + repeatedStringForPackageItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreatePackageResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreatePackageResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Pagination) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Pagination{`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sort{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Order:` + fmt.Sprintf("%v", this.Order) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DisableSubscriptionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DisableSubscriptionRequest{`,
		`StudentSubscriptionIds:` + fmt.Sprintf("%v", this.StudentSubscriptionIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DisableSubscriptionResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DisableSubscriptionResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ToggleEnabledPackageRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToggleEnabledPackageRequest{`,
		`PackageId:` + fmt.Sprintf("%v", this.PackageId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ToggleEnabledPackageResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToggleEnabledPackageResponse{`,
		`Successful:` + fmt.Sprintf("%v", this.Successful) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExtendSubscriptionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExtendSubscriptionRequest{`,
		`SubscriptionId:` + fmt.Sprintf("%v", this.SubscriptionId) + `,`,
		`ExpiredDate:` + strings.Replace(fmt.Sprintf("%v", this.ExpiredDate), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExtendSubscriptionResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExtendSubscriptionResponse{`,
		`}`,
	}, "")
	return s
}
func (this *DisableOrdersRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DisableOrdersRequest{`,
		`OrderIds:` + fmt.Sprintf("%v", this.OrderIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DisableOrdersResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DisableOrdersResponse{`,
		`OrderIds:` + fmt.Sprintf("%v", this.OrderIds) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringYssubscription(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisedPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisedPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPurchasable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPurchasable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeableTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradeableTo = append(m.UpgradeableTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Benefits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Benefits = append(m.Benefits, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizeLevel", wireType)
			}
			m.PrioritizeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrioritizeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Package) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Package: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Package: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountedPrice", wireType)
			}
			m.DiscountedPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountedPrice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = append(m.Description, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Period == nil {
				m.Period = &types.Timestamp{}
			}
			if err := m.Period.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecommended = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnabled = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarriedOverAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CarriedOverAmount = float64(math.Float64frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= bob.Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizeLevel", wireType)
			}
			m.PrioritizeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrioritizeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageItems = append(m.PackageItems, &PackageItem{})
			if err := m.PackageItems[len(m.PackageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpgradableFrom = append(m.UpgradableFrom, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthYssubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthYssubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpgradableFrom) == 0 {
					m.UpgradableFrom = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowYssubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpgradableFrom = append(m.UpgradableFrom, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradableFrom", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiredAt == nil {
				m.ExpiredAt = &types.Timestamp{}
			}
			if err := m.ExpiredAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v bob.Subject
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= bob.Subject(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Subject = append(m.Subject, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthYssubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthYssubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Subject) == 0 {
					m.Subject = make([]bob.Subject, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v bob.Subject
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowYssubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= bob.Subject(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Subject = append(m.Subject, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Grades = append(m.Grades, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthYssubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthYssubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Grades) == 0 {
					m.Grades = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowYssubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Grades = append(m.Grades, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Grades", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountedPrice", wireType)
			}
			m.DiscountedPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountedPrice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= bob.Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualCreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManualCreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coupon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coupon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CouponAmount = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarriedOverAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CarriedOverAmount = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarriedOverFrom", wireType)
			}
			m.CarriedOverFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarriedOverFrom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &types.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &types.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= bob.Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodOrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodOrderInfo == nil {
				m.CodOrderInfo = &CodOrderInfo{}
			}
			if err := m.CodOrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPayBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MustPayBefore == nil {
				m.MustPayBefore = &types.Timestamp{}
			}
			if err := m.MustPayBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, &StudentSubscription{})
			if err := m.Subscriptions[len(m.Subscriptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayFullFeedback", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayFullFeedback = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayName", wireType)
			}
			m.GatewayName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayName |= PaymentGateway(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayResponse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayResponse = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedByEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedByEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsManualCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsManualCreated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentOrderId", wireType)
			}
			m.StudentOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StudentOrderId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Currency == nil {
				m.Currency = &types.StringValue{}
			}
			if err := m.Currency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaymentMethod == nil {
				m.PaymentMethod = &types.StringValue{}
			}
			if err := m.PaymentMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StudentId == nil {
				m.StudentId = &types.StringValue{}
			}
			if err := m.StudentId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PackageName == nil {
				m.PackageName = &types.StringValue{}
			}
			if err := m.PackageName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlanId == nil {
				m.PlanId = &types.StringValue{}
			}
			if err := m.PlanId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coupon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coupon == nil {
				m.Coupon = &types.StringValue{}
			}
			if err := m.Coupon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CouponAmount = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			m.Country = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Country |= bob.Country(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedByEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedByEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &types.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &types.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodOrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodOrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodOrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerPhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerPhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedDeliveryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpectedDeliveryTime == nil {
				m.ExpectedDeliveryTime = &types.Timestamp{}
			}
			if err := m.ExpectedDeliveryTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CodOrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StudentSubscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StudentSubscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StudentSubscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Grades = append(m.Grades, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthYssubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthYssubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Grades) == 0 {
					m.Grades = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowYssubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Grades = append(m.Grades, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Grades", wireType)
			}
		case 3:
			if wireType == 0 {
				var v bob.Subject
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= bob.Subject(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Subjects = append(m.Subjects, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthYssubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthYssubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Subjects) == 0 {
					m.Subjects = make([]bob.Subject, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v bob.Subject
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowYssubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= bob.Subject(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Subjects = append(m.Subjects, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Subjects", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &types.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &types.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SubscriptionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateManualOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateManualOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateManualOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &ManualOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateManualOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateManualOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateManualOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePackageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePackageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePackageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Package == nil {
				m.Package = &Package{}
			}
			if err := m.Package.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageItems = append(m.PackageItems, &PackageItem{})
			if err := m.PackageItems[len(m.PackageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePackageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePackageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePackageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pagination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pagination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pagination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= SortOrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentSubscriptionIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentSubscriptionIds = append(m.StudentSubscriptionIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableSubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableSubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableSubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToggleEnabledPackageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToggleEnabledPackageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToggleEnabledPackageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToggleEnabledPackageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToggleEnabledPackageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToggleEnabledPackageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtendSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthYssubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthYssubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiredDate == nil {
				m.ExpiredDate = &types.Timestamp{}
			}
			if err := m.ExpiredDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtendSubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendSubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendSubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableOrdersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableOrdersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableOrdersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderIds = append(m.OrderIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthYssubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthYssubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderIds) == 0 {
					m.OrderIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowYssubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderIds = append(m.OrderIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisableOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisableOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisableOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderIds = append(m.OrderIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowYssubscription
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthYssubscription
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthYssubscription
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderIds) == 0 {
					m.OrderIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowYssubscription
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderIds = append(m.OrderIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipYssubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthYssubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipYssubscription(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowYssubscription
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowYssubscription
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthYssubscription
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupYssubscription
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthYssubscription
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthYssubscription        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowYssubscription          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupYssubscription = fmt.Errorf("proto: unexpected end of group")
)
