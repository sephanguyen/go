// Code generated by mockery. DO NOT EDIT.

// This file can be generated by running: make gen-mock-repo

package mock_kafka

import (
	context "context"

	kafka "github.com/manabie-com/backend/internal/golibs/kafka"
	kafka_go "github.com/segmentio/kafka-go"

	mock "github.com/stretchr/testify/mock"
)

// KafkaManagement is an autogenerated mock type for the KafkaManagement type
type KafkaManagement struct {
	mock.Mock
}

// Close provides a mock function with given fields:
func (_m *KafkaManagement) Close() {
	_m.Called()
}

// ConnectToKafka provides a mock function with given fields:
func (_m *KafkaManagement) ConnectToKafka() {
	_m.Called()
}

// Consume provides a mock function with given fields: topic, consumerGroupID, option, handleMsg
func (_m *KafkaManagement) Consume(topic string, consumerGroupID string, option kafka.Option, handleMsg kafka.MsgHandler) error {
	ret := _m.Called(topic, consumerGroupID, option, handleMsg)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, kafka.Option, kafka.MsgHandler) error); ok {
		r0 = rf(topic, consumerGroupID, option, handleMsg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenNewConsumerGroupID provides a mock function with given fields: serviceName, topicName
func (_m *KafkaManagement) GenNewConsumerGroupID(serviceName string, topicName string) string {
	ret := _m.Called(serviceName, topicName)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(serviceName, topicName)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetObjectNamePrefix provides a mock function with given fields:
func (_m *KafkaManagement) GetObjectNamePrefix() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PublishContext provides a mock function with given fields: ctx, topic, key, value
func (_m *KafkaManagement) PublishContext(ctx context.Context, topic string, key []byte, value []byte) error {
	ret := _m.Called(ctx, topic, key, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, []byte) error); ok {
		r0 = rf(ctx, topic, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TracedPublishContext provides a mock function with given fields: ctx, spanName, topic, key, value
func (_m *KafkaManagement) TracedPublishContext(ctx context.Context, spanName string, topic string, key []byte, value []byte) error {
	ret := _m.Called(ctx, spanName, topic, key, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []byte, []byte) error); ok {
		r0 = rf(ctx, spanName, topic, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTopic provides a mock function with given fields: topicConfig
func (_m *KafkaManagement) UpsertTopic(topicConfig *kafka_go.TopicConfig) error {
	ret := _m.Called(topicConfig)

	var r0 error
	if rf, ok := ret.Get(0).(func(*kafka_go.TopicConfig) error); ok {
		r0 = rf(topicConfig)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewKafkaManagement interface {
	mock.TestingT
	Cleanup(func())
}

// NewKafkaManagement creates a new instance of KafkaManagement. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewKafkaManagement(t mockConstructorTestingTNewKafkaManagement) *KafkaManagement {
	mock := &KafkaManagement{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
