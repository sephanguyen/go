// Code generated by mockery v2.25.1. DO NOT EDIT.

package kafka

import (
        kafka "github.com/segmentio/kafka-go"
        mock "github.com/stretchr/testify/mock"
)

// MockConn is an autogenerated mock type for the Conn type
type MockConn struct {
        mock.Mock
}

// ApiVersions provides a mock function with given fields:
func (_m *MockConn) ApiVersions() ([]kafka.ApiVersion, error) {
        ret := _m.Called()

        var r0 []kafka.ApiVersion
        var r1 error
        if rf, ok := ret.Get(0).(func() ([]kafka.ApiVersion, error)); ok {
                return rf()
        }
        if rf, ok := ret.Get(0).(func() []kafka.ApiVersion); ok {
                r0 = rf()
        } else {
                if ret.Get(0) != nil {
                        r0 = ret.Get(0).([]kafka.ApiVersion)
                }
        }

        if rf, ok := ret.Get(1).(func() error); ok {
                r1 = rf()
        } else {
                r1 = ret.Error(1)
        }

        return r0, r1
}

// Close provides a mock function with given fields:
func (_m *MockConn) Close() error {
        ret := _m.Called()

        var r0 error
        if rf, ok := ret.Get(0).(func() error); ok {
                r0 = rf()
        } else {
                r0 = ret.Error(0)
        }

        return r0
}

// Controller provides a mock function with given fields:
func (_m *MockConn) Controller() (kafka.Broker, error) {
        ret := _m.Called()

        var r0 kafka.Broker
        var r1 error
        if rf, ok := ret.Get(0).(func() (kafka.Broker, error)); ok {
                return rf()
        }
        if rf, ok := ret.Get(0).(func() kafka.Broker); ok {
                r0 = rf()
        } else {
                r0 = ret.Get(0).(kafka.Broker)
        }

        if rf, ok := ret.Get(1).(func() error); ok {
                r1 = rf()
        } else {
                r1 = ret.Error(1)
        }

        return r0, r1
}

// CreateTopics provides a mock function with given fields: topics
func (_m *MockConn) CreateTopics(topics ...kafka.TopicConfig) error {
        _va := make([]interface{}, len(topics))
        for _i := range topics {
                _va[_i] = topics[_i]
        }
        var _ca []interface{}
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        var r0 error
        if rf, ok := ret.Get(0).(func(...kafka.TopicConfig) error); ok {
                r0 = rf(topics...)
        } else {
                r0 = ret.Error(0)
        }

        return r0
}

// ReadPartitions provides a mock function with given fields: topics
func (_m *MockConn) ReadPartitions(topics ...string) ([]kafka.Partition, error) {
        _va := make([]interface{}, len(topics))
        for _i := range topics {
                _va[_i] = topics[_i]
        }
        var _ca []interface{}
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        var r0 []kafka.Partition
        var r1 error
        if rf, ok := ret.Get(0).(func(...string) ([]kafka.Partition, error)); ok {
                return rf(topics...)
        }
        if rf, ok := ret.Get(0).(func(...string) []kafka.Partition); ok {
                r0 = rf(topics...)
        } else {
                if ret.Get(0) != nil {
                        r0 = ret.Get(0).([]kafka.Partition)
                }
        }

        if rf, ok := ret.Get(1).(func(...string) error); ok {
                r1 = rf(topics...)
        } else {
                r1 = ret.Error(1)
        }

        return r0, r1
}

type mockConstructorTestingTNewMockConn interface {
        mock.TestingT
        Cleanup(func())
}

// NewMockConn creates a new instance of MockConn. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockConn(t mockConstructorTestingTNewMockConn) *MockConn {
        mock := &MockConn{}
        mock.Mock.Test(t)

        t.Cleanup(func() { mock.AssertExpectations(t) })

        return mock
}
