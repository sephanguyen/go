package main

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// Golden represents a test case.
type Golden struct {
	name           string
	trimPrefix     string
	lineComment    bool
	input          string
	expectedOutput string
}

var golden = []Golden{
	{"user", "", false, input, generatedCode},
}

var input = `
type User interface {
	UserID() field.String
}
`

var generatedCode = `// This statement will fail to compile if *NullUser ever stops matching the interface.
var _ User = (*NullUser)(nil)

type NullUser struct {
}

func (nullUser NullUser) UserID() field.String {
	return field.NewNullString()
}

// CompareUserValues compare values of two User entities
func CompareUserValues(user1 User, user2 User, fieldsToCompare ...UserField) error {
	// By default, compare all fields if number of fields to compare is 0
	if len(fieldsToCompare) < 1 {
		fieldsToCompare = []UserField{
			UserFieldUserID,
		}
	}

	for _, fieldToCompare := range fieldsToCompare {
		switch fieldToCompare {
		case UserFieldUserID:
			if user1.UserID().String() != user2.UserID().String() {
				return errors.New("UserID is not equal")
			}
		}
	}

	return nil
}

// Users represents for a slice of User
type Users []User

func (users Users) UserIDs() field.Strings {
	userIDs := make([]field.String, 0, len(users))
	for _, user := range users {
		userIDs = append(userIDs, user.UserID())
	}
	return userIDs
}

type user struct {
	NullUser

	userID field.String
}

func (user *user) UserID() field.String {
	return user.userID
}

type UserOption interface {
	apply(*user)
}
type userOption func(*user)

func (userOption userOption) apply(user *user) {
	userOption(user)
}

type UserFieldsImpl struct{}

var UserFields = UserFieldsImpl{}

func (userFieldsImpl UserFieldsImpl) From(srcUser User) UserOption {
	return userOption(func(user *user) {
		user.userID = srcUser.UserID()
	})
}
func (userFieldsImpl UserFieldsImpl) UserID(userID field.String) UserOption {
	return userOption(func(user *user) {
		user.userID = userID
	})
}

func NewUser(options ...UserOption) User {
	user := &user{}
	for _, option := range options {
		option.apply(user)
	}
	return user
}
`

func TestGolden(t *testing.T) {
	tempDir := t.TempDir()

	for _, test := range golden {
		g := Generator{
			trimPrefix:  test.trimPrefix,
			lineComment: test.lineComment,
		}

		input := "package test\n" + test.input
		file := test.name + ".go"

		absFile := filepath.Join(tempDir, file)
		err := os.WriteFile(absFile, []byte(input), 0644)
		if err != nil {
			t.Error(err)
		}

		g.addPackages(ParsePackage([]string{absFile}, nil))

		// Extract the name and type of the constant from the first line.
		tokens := strings.SplitN(test.input, " ", 3)
		if len(tokens) != 3 {
			t.Fatalf("%s: need type declaration on first line", test.name)
		}

		buffer, _ := generateEntImpl(g.pkgs, tokens[1])
		got := string(gofmt(buffer))

		if got != test.expectedOutput {
			t.Errorf("%s: got(%d)\n====\n%q====\nexpected(%d)\n====%q", test.name, len(got), got, len(test.expectedOutput), test.expectedOutput)
		}
	}
}

var expectedHeader = `// Code generated by "hexagen --type=TestUser --output=/tmp ." (v0.1.0); DO NOT EDIT.

package tmp
`

func TestHeaderAndPackageClause(t *testing.T) {
	actual := headerAndPackageClause("TestUser", "/tmp", "tmp", []string{"."})
	assert.Equal(t, expectedHeader, string(actual))
}

func TestParsePackage(t *testing.T) {
	packages := ParsePackage([]string{"./tmp/e2e"}, nil)
	pkg := packages[0]

	assert.Equal(t, "main", pkg.Name)
	for _, syntax := range pkg.Syntax {
		fmt.Println(syntax)
	}
}
