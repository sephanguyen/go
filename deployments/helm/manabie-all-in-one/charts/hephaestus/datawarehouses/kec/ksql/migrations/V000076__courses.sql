SET 'auto.offset.reset' = 'earliest';

CREATE STREAM IF NOT EXISTS COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1 WITH (kafka_topic='{{ .Values.global.environment }}.kec.datalake.fatima.course_access_paths', value_format='AVRO');

CREATE STREAM IF NOT EXISTS COURSE_ACCESS_PATHS_STREAM_FORMATTED_V1
    AS SELECT
        COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->COURSE_ID + COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->LOCATION_ID as KEY,
        COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->COURSE_ID AS COURSE_ID,
        COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->LOCATION_ID AS LOCATION_ID,
        COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->CREATED_AT AS COURSE_ACCESS_PATHS_CREATED_AT,
        COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->UPDATED_AT AS COURSE_ACCESS_PATHS_UPDATED_AT,
        COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->DELETED_AT AS COURSE_ACCESS_PATHS_DELETED_AT
    FROM COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1
    WHERE COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->RESOURCE_PATH = '{{ .Values.kecResourcePath }}'
    PARTITION BY COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->COURSE_ID + COURSE_ACCESS_PATHS_STREAM_ORIGIN_V1.AFTER->LOCATION_ID
    EMIT CHANGES;

CREATE TABLE IF NOT EXISTS COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1 (KEY VARCHAR PRIMARY KEY) with (kafka_topic='{{ .Values.topicPrefix }}COURSE_ACCESS_PATHS_STREAM_FORMATTED_V1', value_format='AVRO');



CREATE STREAM IF NOT EXISTS COURSE_STREAM_ORIGIN_V1  WITH (kafka_topic='{{ .Values.global.environment }}.kec.datalake.fatima.courses', value_format='AVRO');

CREATE STREAM IF NOT EXISTS COURSE_STREAM_FORMATTED_V1
    AS SELECT
        COURSE_STREAM_ORIGIN_V1.AFTER->COURSE_ID as KEY,
        AS_VALUE(COURSE_STREAM_ORIGIN_V1.AFTER->COURSE_ID) AS COURSE_ID,
        COURSE_STREAM_ORIGIN_V1.AFTER->NAME AS COURSES_NAME,
        COURSE_STREAM_ORIGIN_V1.AFTER->GRADE AS GRADE,
        COURSE_STREAM_ORIGIN_V1.AFTER->TEACHING_METHOD AS TEACHING_METHOD,
        COURSE_STREAM_ORIGIN_V1.AFTER->CREATED_AT AS COURSE_CREATED_AT,
        COURSE_STREAM_ORIGIN_V1.AFTER->UPDATED_AT AS COURSE_UPDATED_AT,
        COURSE_STREAM_ORIGIN_V1.AFTER->DELETED_AT AS COURSE_DELETED_AT
    FROM COURSE_STREAM_ORIGIN_V1
    WHERE COURSE_STREAM_ORIGIN_V1.AFTER->RESOURCE_PATH = '{{ .Values.kecResourcePath }}'
    PARTITION BY COURSE_STREAM_ORIGIN_V1.AFTER->COURSE_ID
    EMIT CHANGES;

CREATE TABLE IF NOT EXISTS COURSE_TABLE_FORMATTED_V1 (KEY VARCHAR PRIMARY KEY) with (kafka_topic='{{ .Values.topicPrefix }}COURSE_STREAM_FORMATTED_V1', value_format='AVRO');


CREATE TABLE IF NOT EXISTS COURSE_PUBLIC_INFO_V1
AS SELECT
    COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1.KEY AS ROW_KEY,
    AS_VALUE(COURSE_TABLE_FORMATTED_V1.KEY) AS COURSE_ID,
    COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1.LOCATION_ID AS LOCATION_ID,
    COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1.COURSE_ACCESS_PATHS_CREATED_AT AS COURSE_ACCESS_PATHS_CREATED_AT,
    COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1.COURSE_ACCESS_PATHS_UPDATED_AT AS COURSE_ACCESS_PATHS_UPDATED_AT,
    COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1.COURSE_ACCESS_PATHS_DELETED_AT AS COURSE_ACCESS_PATHS_DELETED_AT,
    COURSE_TABLE_FORMATTED_V1.COURSES_NAME AS COURSES_NAME,
    COURSE_TABLE_FORMATTED_V1.GRADE AS GRADE,
    COURSE_TABLE_FORMATTED_V1.TEACHING_METHOD AS TEACHING_METHOD,
    COURSE_TABLE_FORMATTED_V1.COURSE_CREATED_AT AS COURSE_CREATED_AT,
    COURSE_TABLE_FORMATTED_V1.COURSE_UPDATED_AT AS COURSE_UPDATED_AT,
    COURSE_TABLE_FORMATTED_V1.COURSE_DELETED_AT AS COURSE_DELETED_AT
FROM COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1
JOIN COURSE_TABLE_FORMATTED_V1
ON COURSE_ACCESS_PATHS_TABLE_FORMATTED_V1.COURSE_ID = COURSE_TABLE_FORMATTED_V1.KEY;

CREATE SINK CONNECTOR IF NOT EXISTS SINK_COURSE_PUBLIC_INFO_V1 WITH (
      'connector.class'='io.confluent.connect.jdbc.JdbcSinkConnector',
      'transforms.unwrap.delete.handling.mode'='drop',
      'tasks.max'='1',
      'topics'='{{ .Values.topicPrefix }}COURSE_PUBLIC_INFO_V1',
      'fields.whitelist'='course_id,location_id,course_access_paths_created_at,course_access_paths_updated_at,course_access_paths_deleted_at,courses_name,grade,teaching_method,course_created_at,course_updated_at,course_deleted_at',
      'key.converter'='org.apache.kafka.connect.storage.StringConverter',
      'value.converter'='io.confluent.connect.avro.AvroConverter',
      'value.converter.schema.registry.url'='{{ .Values.cpRegistryHost }}',
      'delete.enabled'='false',
      'transforms.unwrap.drop.tombstones'='true',
      'auto.create'='true',
      'connection.url'='${file:/decrypted/kafka-connect.secrets.properties:kec_url}',
      'insert.mode'='upsert',
      'table.name.format'='public.courses',
      'pk.mode'='record_value',
      'transforms'='RenameField',
      'transforms.RenameField.type'= 'org.apache.kafka.connect.transforms.ReplaceField$Value',
      'transforms.RenameField.renames'='COURSE_ID:course_id,LOCATION_ID:location_id,COURSE_ACCESS_PATHS_CREATED_AT:course_access_paths_created_at,COURSE_ACCESS_PATHS_UPDATED_AT:course_access_paths_updated_at,COURSE_ACCESS_PATHS_DELETED_AT:course_access_paths_deleted_at,COURSES_NAME:courses_name,GRADE:grade,TEACHING_METHOD:teaching_method,COURSE_CREATED_AT:course_created_at,COURSE_UPDATED_AT:course_updated_at,COURSE_DELETED_AT:course_deleted_at',
      'pk.fields'='course_id,location_id'
);
